/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Preferences
 *
 */
export type Preferences = $Result.DefaultSelection<Prisma.$PreferencesPayload>;
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Reservation
 *
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>;
/**
 * Model DraftReservation
 *
 */
export type DraftReservation =
  $Result.DefaultSelection<Prisma.$DraftReservationPayload>;
/**
 * Model StatusChange
 *
 */
export type StatusChange =
  $Result.DefaultSelection<Prisma.$StatusChangePayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model VerificationToken
 *
 */
export type VerificationToken =
  $Result.DefaultSelection<Prisma.$VerificationTokenPayload>;
/**
 * Model Vehicle
 *
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>;
/**
 * Model MaintenanceBlock
 *
 */
export type MaintenanceBlock =
  $Result.DefaultSelection<Prisma.$MaintenanceBlockPayload>;
/**
 * Model Payment
 *
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>;
/**
 * Model Document
 *
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>;
/**
 * Model Image
 *
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>;
/**
 * Model PushSubscription
 *
 */
export type PushSubscription =
  $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>;
/**
 * Model Onboarding
 *
 */
export type Onboarding = $Result.DefaultSelection<Prisma.$OnboardingPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const ReservationStatus: {
    PENDING: "PENDING";
    CONFIRMED: "CONFIRMED";
    ACTIVE: "ACTIVE";
    COMPLETED: "COMPLETED";
    CANCELLED: "CANCELLED";
  };

  export type ReservationStatus =
    (typeof ReservationStatus)[keyof typeof ReservationStatus];

  export const VehicleCategory: {
    SEDAN: "SEDAN";
    SUV: "SUV";
    COUPE: "COUPE";
    CONVERTIBLE: "CONVERTIBLE";
    WAGON: "WAGON";
    HATCHBACK: "HATCHBACK";
  };

  export type VehicleCategory =
    (typeof VehicleCategory)[keyof typeof VehicleCategory];

  export const VehicleTransmission: {
    AUTOMATIC: "AUTOMATIC";
    MANUAL: "MANUAL";
  };

  export type VehicleTransmission =
    (typeof VehicleTransmission)[keyof typeof VehicleTransmission];

  export const VehicleFuelType: {
    GASOLINE: "GASOLINE";
    DIESEL: "DIESEL";
    HYBRID: "HYBRID";
    ELECTRIC: "ELECTRIC";
  };

  export type VehicleFuelType =
    (typeof VehicleFuelType)[keyof typeof VehicleFuelType];

  export const VehicleStatus: {
    AVAILABLE: "AVAILABLE";
    UNAVAILABLE: "UNAVAILABLE";
    PENDING: "PENDING";
    RENTED: "RENTED";
    MAINTENANCE: "MAINTENANCE";
  };

  export type VehicleStatus =
    (typeof VehicleStatus)[keyof typeof VehicleStatus];

  export const PaymentStatus: {
    UNPAID: "UNPAID";
    PAID: "PAID";
    PARTIAL: "PARTIAL";
    REFUNDED: "REFUNDED";
  };

  export type PaymentStatus =
    (typeof PaymentStatus)[keyof typeof PaymentStatus];
}

export type ReservationStatus = $Enums.ReservationStatus;

export const ReservationStatus: typeof $Enums.ReservationStatus;

export type VehicleCategory = $Enums.VehicleCategory;

export const VehicleCategory: typeof $Enums.VehicleCategory;

export type VehicleTransmission = $Enums.VehicleTransmission;

export const VehicleTransmission: typeof $Enums.VehicleTransmission;

export type VehicleFuelType = $Enums.VehicleFuelType;

export const VehicleFuelType: typeof $Enums.VehicleFuelType;

export type VehicleStatus = $Enums.VehicleStatus;

export const VehicleStatus: typeof $Enums.VehicleStatus;

export type PaymentStatus = $Enums.PaymentStatus;

export const PaymentStatus: typeof $Enums.PaymentStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preferences`: Exposes CRUD operations for the **Preferences** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Preferences
   * const preferences = await prisma.preferences.findMany()
   * ```
   */
  get preferences(): Prisma.PreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reservations
   * const reservations = await prisma.reservation.findMany()
   * ```
   */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.draftReservation`: Exposes CRUD operations for the **DraftReservation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DraftReservations
   * const draftReservations = await prisma.draftReservation.findMany()
   * ```
   */
  get draftReservation(): Prisma.DraftReservationDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.statusChange`: Exposes CRUD operations for the **StatusChange** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more StatusChanges
   * const statusChanges = await prisma.statusChange.findMany()
   * ```
   */
  get statusChange(): Prisma.StatusChangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerificationTokens
   * const verificationTokens = await prisma.verificationToken.findMany()
   * ```
   */
  get verificationToken(): Prisma.VerificationTokenDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Vehicles
   * const vehicles = await prisma.vehicle.findMany()
   * ```
   */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceBlock`: Exposes CRUD operations for the **MaintenanceBlock** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MaintenanceBlocks
   * const maintenanceBlocks = await prisma.maintenanceBlock.findMany()
   * ```
   */
  get maintenanceBlock(): Prisma.MaintenanceBlockDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payments
   * const payments = await prisma.payment.findMany()
   * ```
   */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Documents
   * const documents = await prisma.document.findMany()
   * ```
   */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Images
   * const images = await prisma.image.findMany()
   * ```
   */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PushSubscriptions
   * const pushSubscriptions = await prisma.pushSubscription.findMany()
   * ```
   */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.onboarding`: Exposes CRUD operations for the **Onboarding** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Onboardings
   * const onboardings = await prisma.onboarding.findMany()
   * ```
   */
  get onboarding(): Prisma.OnboardingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    Preferences: "Preferences";
    Account: "Account";
    Reservation: "Reservation";
    DraftReservation: "DraftReservation";
    StatusChange: "StatusChange";
    Session: "Session";
    VerificationToken: "VerificationToken";
    Vehicle: "Vehicle";
    MaintenanceBlock: "MaintenanceBlock";
    Payment: "Payment";
    Document: "Document";
    Image: "Image";
    PushSubscription: "PushSubscription";
    Onboarding: "Onboarding";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "preferences"
        | "account"
        | "reservation"
        | "draftReservation"
        | "statusChange"
        | "session"
        | "verificationToken"
        | "vehicle"
        | "maintenanceBlock"
        | "payment"
        | "document"
        | "image"
        | "pushSubscription"
        | "onboarding";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Preferences: {
        payload: Prisma.$PreferencesPayload<ExtArgs>;
        fields: Prisma.PreferencesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PreferencesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PreferencesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>;
          };
          findFirst: {
            args: Prisma.PreferencesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PreferencesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>;
          };
          findMany: {
            args: Prisma.PreferencesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>[];
          };
          create: {
            args: Prisma.PreferencesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>;
          };
          createMany: {
            args: Prisma.PreferencesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PreferencesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>[];
          };
          delete: {
            args: Prisma.PreferencesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>;
          };
          update: {
            args: Prisma.PreferencesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>;
          };
          deleteMany: {
            args: Prisma.PreferencesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PreferencesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PreferencesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>[];
          };
          upsert: {
            args: Prisma.PreferencesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PreferencesPayload>;
          };
          aggregate: {
            args: Prisma.PreferencesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePreferences>;
          };
          groupBy: {
            args: Prisma.PreferencesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PreferencesGroupByOutputType>[];
          };
          count: {
            args: Prisma.PreferencesCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PreferencesCountAggregateOutputType>
              | number;
          };
        };
      };
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>;
        fields: Prisma.ReservationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>;
          };
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>;
          };
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[];
          };
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>;
          };
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[];
          };
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>;
          };
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>;
          };
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[];
          };
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>;
          };
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReservation>;
          };
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReservationGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ReservationCountAggregateOutputType>
              | number;
          };
        };
      };
      DraftReservation: {
        payload: Prisma.$DraftReservationPayload<ExtArgs>;
        fields: Prisma.DraftReservationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DraftReservationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DraftReservationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>;
          };
          findFirst: {
            args: Prisma.DraftReservationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DraftReservationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>;
          };
          findMany: {
            args: Prisma.DraftReservationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>[];
          };
          create: {
            args: Prisma.DraftReservationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>;
          };
          createMany: {
            args: Prisma.DraftReservationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DraftReservationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>[];
          };
          delete: {
            args: Prisma.DraftReservationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>;
          };
          update: {
            args: Prisma.DraftReservationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>;
          };
          deleteMany: {
            args: Prisma.DraftReservationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DraftReservationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DraftReservationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>[];
          };
          upsert: {
            args: Prisma.DraftReservationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DraftReservationPayload>;
          };
          aggregate: {
            args: Prisma.DraftReservationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDraftReservation>;
          };
          groupBy: {
            args: Prisma.DraftReservationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DraftReservationGroupByOutputType>[];
          };
          count: {
            args: Prisma.DraftReservationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<DraftReservationCountAggregateOutputType>
              | number;
          };
        };
      };
      StatusChange: {
        payload: Prisma.$StatusChangePayload<ExtArgs>;
        fields: Prisma.StatusChangeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.StatusChangeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.StatusChangeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>;
          };
          findFirst: {
            args: Prisma.StatusChangeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.StatusChangeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>;
          };
          findMany: {
            args: Prisma.StatusChangeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>[];
          };
          create: {
            args: Prisma.StatusChangeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>;
          };
          createMany: {
            args: Prisma.StatusChangeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.StatusChangeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>[];
          };
          delete: {
            args: Prisma.StatusChangeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>;
          };
          update: {
            args: Prisma.StatusChangeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>;
          };
          deleteMany: {
            args: Prisma.StatusChangeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.StatusChangeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.StatusChangeUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>[];
          };
          upsert: {
            args: Prisma.StatusChangeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$StatusChangePayload>;
          };
          aggregate: {
            args: Prisma.StatusChangeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStatusChange>;
          };
          groupBy: {
            args: Prisma.StatusChangeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StatusChangeGroupByOutputType>[];
          };
          count: {
            args: Prisma.StatusChangeCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<StatusChangeCountAggregateOutputType>
              | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>;
        fields: Prisma.VerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerificationToken>;
          };
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<VerificationTokenCountAggregateOutputType>
              | number;
          };
        };
      };
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>;
        fields: Prisma.VehicleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>;
          };
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>;
          };
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[];
          };
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>;
          };
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[];
          };
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>;
          };
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>;
          };
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[];
          };
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>;
          };
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVehicle>;
          };
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VehicleGroupByOutputType>[];
          };
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>;
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number;
          };
        };
      };
      MaintenanceBlock: {
        payload: Prisma.$MaintenanceBlockPayload<ExtArgs>;
        fields: Prisma.MaintenanceBlockFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MaintenanceBlockFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MaintenanceBlockFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>;
          };
          findFirst: {
            args: Prisma.MaintenanceBlockFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MaintenanceBlockFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>;
          };
          findMany: {
            args: Prisma.MaintenanceBlockFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>[];
          };
          create: {
            args: Prisma.MaintenanceBlockCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>;
          };
          createMany: {
            args: Prisma.MaintenanceBlockCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MaintenanceBlockCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>[];
          };
          delete: {
            args: Prisma.MaintenanceBlockDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>;
          };
          update: {
            args: Prisma.MaintenanceBlockUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>;
          };
          deleteMany: {
            args: Prisma.MaintenanceBlockDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MaintenanceBlockUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MaintenanceBlockUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>[];
          };
          upsert: {
            args: Prisma.MaintenanceBlockUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MaintenanceBlockPayload>;
          };
          aggregate: {
            args: Prisma.MaintenanceBlockAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMaintenanceBlock>;
          };
          groupBy: {
            args: Prisma.MaintenanceBlockGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MaintenanceBlockGroupByOutputType>[];
          };
          count: {
            args: Prisma.MaintenanceBlockCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<MaintenanceBlockCountAggregateOutputType>
              | number;
          };
        };
      };
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>;
        fields: Prisma.PaymentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment>;
          };
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaymentGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>;
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number;
          };
        };
      };
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>;
        fields: Prisma.DocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDocument>;
          };
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>;
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number;
          };
        };
      };
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>;
        fields: Prisma.ImageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>;
          };
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>;
          };
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[];
          };
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>;
          };
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[];
          };
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>;
          };
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>;
          };
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ImageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[];
          };
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>;
          };
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateImage>;
          };
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ImageGroupByOutputType>[];
          };
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>;
            result: $Utils.Optional<ImageCountAggregateOutputType> | number;
          };
        };
      };
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>;
        fields: Prisma.PushSubscriptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[];
          };
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[];
          };
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[];
          };
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePushSubscription>;
          };
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[];
          };
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PushSubscriptionCountAggregateOutputType>
              | number;
          };
        };
      };
      Onboarding: {
        payload: Prisma.$OnboardingPayload<ExtArgs>;
        fields: Prisma.OnboardingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OnboardingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OnboardingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>;
          };
          findFirst: {
            args: Prisma.OnboardingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OnboardingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>;
          };
          findMany: {
            args: Prisma.OnboardingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>[];
          };
          create: {
            args: Prisma.OnboardingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>;
          };
          createMany: {
            args: Prisma.OnboardingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OnboardingCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>[];
          };
          delete: {
            args: Prisma.OnboardingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>;
          };
          update: {
            args: Prisma.OnboardingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>;
          };
          deleteMany: {
            args: Prisma.OnboardingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OnboardingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OnboardingUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>[];
          };
          upsert: {
            args: Prisma.OnboardingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OnboardingPayload>;
          };
          aggregate: {
            args: Prisma.OnboardingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOnboarding>;
          };
          groupBy: {
            args: Prisma.OnboardingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OnboardingGroupByOutputType>[];
          };
          count: {
            args: Prisma.OnboardingCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<OnboardingCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    preferences?: PreferencesOmit;
    account?: AccountOmit;
    reservation?: ReservationOmit;
    draftReservation?: DraftReservationOmit;
    statusChange?: StatusChangeOmit;
    session?: SessionOmit;
    verificationToken?: VerificationTokenOmit;
    vehicle?: VehicleOmit;
    maintenanceBlock?: MaintenanceBlockOmit;
    payment?: PaymentOmit;
    document?: DocumentOmit;
    image?: ImageOmit;
    pushSubscription?: PushSubscriptionOmit;
    onboarding?: OnboardingOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T["emit"] extends "event"
        ? T["level"]
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Account: number;
    documents: number;
    Onboarding: number;
    PushSubscription: number;
    Reservation: number;
    Session: number;
    StatusChange: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    Account?: boolean | UserCountOutputTypeCountAccountArgs;
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs;
    Onboarding?: boolean | UserCountOutputTypeCountOnboardingArgs;
    PushSubscription?: boolean | UserCountOutputTypeCountPushSubscriptionArgs;
    Reservation?: boolean | UserCountOutputTypeCountReservationArgs;
    Session?: boolean | UserCountOutputTypeCountSessionArgs;
    StatusChange?: boolean | UserCountOutputTypeCountStatusChangeArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOnboardingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OnboardingWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PushSubscriptionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReservationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReservationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusChangeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StatusChangeWhereInput;
  };

  /**
   * Count Type ReservationCountOutputType
   */

  export type ReservationCountOutputType = {
    contracts: number;
    payments: number;
    statusHistory: number;
  };

  export type ReservationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    contracts?: boolean | ReservationCountOutputTypeCountContractsArgs;
    payments?: boolean | ReservationCountOutputTypeCountPaymentsArgs;
    statusHistory?: boolean | ReservationCountOutputTypeCountStatusHistoryArgs;
  };

  // Custom InputTypes
  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     */
    select?: ReservationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountContractsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
  };

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaymentWhereInput;
  };

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountStatusHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StatusChangeWhereInput;
  };

  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    images: number;
    maintenanceBlocks: number;
    reservations: number;
  };

  export type VehicleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    images?: boolean | VehicleCountOutputTypeCountImagesArgs;
    maintenanceBlocks?:
      | boolean
      | VehicleCountOutputTypeCountMaintenanceBlocksArgs;
    reservations?: boolean | VehicleCountOutputTypeCountReservationsArgs;
  };

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountImagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ImageWhereInput;
  };

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountMaintenanceBlocksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MaintenanceBlockWhereInput;
  };

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountReservationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReservationWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    phone: string | null;
    isAdmin: boolean | null;
    isVerified: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    phone: string | null;
    isAdmin: boolean | null;
    isVerified: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    emailVerified: number;
    image: number;
    phone: number;
    isAdmin: number;
    isVerified: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    phone?: true;
    isAdmin?: true;
    isVerified?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    phone?: true;
    isAdmin?: true;
    isVerified?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    phone?: true;
    isAdmin?: true;
    isVerified?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    name: string | null;
    email: string;
    emailVerified: Date | null;
    image: string | null;
    phone: string | null;
    isAdmin: boolean;
    isVerified: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      phone?: boolean;
      isAdmin?: boolean;
      isVerified?: boolean;
      Account?: boolean | User$AccountArgs<ExtArgs>;
      documents?: boolean | User$documentsArgs<ExtArgs>;
      Onboarding?: boolean | User$OnboardingArgs<ExtArgs>;
      notificationsPreferences?:
        | boolean
        | User$notificationsPreferencesArgs<ExtArgs>;
      PushSubscription?: boolean | User$PushSubscriptionArgs<ExtArgs>;
      Reservation?: boolean | User$ReservationArgs<ExtArgs>;
      Session?: boolean | User$SessionArgs<ExtArgs>;
      StatusChange?: boolean | User$StatusChangeArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      phone?: boolean;
      isAdmin?: boolean;
      isVerified?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      phone?: boolean;
      isAdmin?: boolean;
      isVerified?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    image?: boolean;
    phone?: boolean;
    isAdmin?: boolean;
    isVerified?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "email"
    | "emailVerified"
    | "image"
    | "phone"
    | "isAdmin"
    | "isVerified",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    Account?: boolean | User$AccountArgs<ExtArgs>;
    documents?: boolean | User$documentsArgs<ExtArgs>;
    Onboarding?: boolean | User$OnboardingArgs<ExtArgs>;
    notificationsPreferences?:
      | boolean
      | User$notificationsPreferencesArgs<ExtArgs>;
    PushSubscription?: boolean | User$PushSubscriptionArgs<ExtArgs>;
    Reservation?: boolean | User$ReservationArgs<ExtArgs>;
    Session?: boolean | User$SessionArgs<ExtArgs>;
    StatusChange?: boolean | User$StatusChangeArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "User";
    objects: {
      Account: Prisma.$AccountPayload<ExtArgs>[];
      documents: Prisma.$DocumentPayload<ExtArgs>[];
      Onboarding: Prisma.$OnboardingPayload<ExtArgs>[];
      notificationsPreferences: Prisma.$PreferencesPayload<ExtArgs> | null;
      PushSubscription: Prisma.$PushSubscriptionPayload<ExtArgs>[];
      Reservation: Prisma.$ReservationPayload<ExtArgs>[];
      Session: Prisma.$SessionPayload<ExtArgs>[];
      StatusChange: Prisma.$StatusChangePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string | null;
        email: string;
        emailVerified: Date | null;
        image: string | null;
        phone: string | null;
        isAdmin: boolean;
        isVerified: boolean;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["User"];
      meta: { name: "User" };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Account<T extends User$AccountArgs<ExtArgs> = {}>(
      args?: Subset<T, User$AccountArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AccountPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    documents<T extends User$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$DocumentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    Onboarding<T extends User$OnboardingArgs<ExtArgs> = {}>(
      args?: Subset<T, User$OnboardingArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OnboardingPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    notificationsPreferences<
      T extends User$notificationsPreferencesArgs<ExtArgs> = {},
    >(
      args?: Subset<T, User$notificationsPreferencesArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    PushSubscription<T extends User$PushSubscriptionArgs<ExtArgs> = {}>(
      args?: Subset<T, User$PushSubscriptionArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PushSubscriptionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    Reservation<T extends User$ReservationArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ReservationArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReservationPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    Session<T extends User$SessionArgs<ExtArgs> = {}>(
      args?: Subset<T, User$SessionArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SessionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    StatusChange<T extends User$StatusChangeArgs<ExtArgs> = {}>(
      args?: Subset<T, User$StatusChangeArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$StatusChangePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly name: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly emailVerified: FieldRef<"User", "DateTime">;
    readonly image: FieldRef<"User", "String">;
    readonly phone: FieldRef<"User", "String">;
    readonly isAdmin: FieldRef<"User", "Boolean">;
    readonly isVerified: FieldRef<"User", "Boolean">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.Account
   */
  export type User$AccountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.documents
   */
  export type User$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    where?: DocumentWhereInput;
    orderBy?:
      | DocumentOrderByWithRelationInput
      | DocumentOrderByWithRelationInput[];
    cursor?: DocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * User.Onboarding
   */
  export type User$OnboardingArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    where?: OnboardingWhereInput;
    orderBy?:
      | OnboardingOrderByWithRelationInput
      | OnboardingOrderByWithRelationInput[];
    cursor?: OnboardingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OnboardingScalarFieldEnum | OnboardingScalarFieldEnum[];
  };

  /**
   * User.notificationsPreferences
   */
  export type User$notificationsPreferencesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    where?: PreferencesWhereInput;
  };

  /**
   * User.PushSubscription
   */
  export type User$PushSubscriptionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    where?: PushSubscriptionWhereInput;
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    cursor?: PushSubscriptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * User.Reservation
   */
  export type User$ReservationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    where?: ReservationWhereInput;
    orderBy?:
      | ReservationOrderByWithRelationInput
      | ReservationOrderByWithRelationInput[];
    cursor?: ReservationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[];
  };

  /**
   * User.Session
   */
  export type User$SessionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.StatusChange
   */
  export type User$StatusChangeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    where?: StatusChangeWhereInput;
    orderBy?:
      | StatusChangeOrderByWithRelationInput
      | StatusChangeOrderByWithRelationInput[];
    cursor?: StatusChangeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Preferences
   */

  export type AggregatePreferences = {
    _count: PreferencesCountAggregateOutputType | null;
    _min: PreferencesMinAggregateOutputType | null;
    _max: PreferencesMaxAggregateOutputType | null;
  };

  export type PreferencesMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    UserNotifications: boolean | null;
    ReservationNotifications: boolean | null;
    LeadNotifications: boolean | null;
    ContactNotifications: boolean | null;
    PaymentNotifications: boolean | null;
    ReviewNotifications: boolean | null;
  };

  export type PreferencesMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    UserNotifications: boolean | null;
    ReservationNotifications: boolean | null;
    LeadNotifications: boolean | null;
    ContactNotifications: boolean | null;
    PaymentNotifications: boolean | null;
    ReviewNotifications: boolean | null;
  };

  export type PreferencesCountAggregateOutputType = {
    id: number;
    userId: number;
    UserNotifications: number;
    ReservationNotifications: number;
    LeadNotifications: number;
    ContactNotifications: number;
    PaymentNotifications: number;
    ReviewNotifications: number;
    _all: number;
  };

  export type PreferencesMinAggregateInputType = {
    id?: true;
    userId?: true;
    UserNotifications?: true;
    ReservationNotifications?: true;
    LeadNotifications?: true;
    ContactNotifications?: true;
    PaymentNotifications?: true;
    ReviewNotifications?: true;
  };

  export type PreferencesMaxAggregateInputType = {
    id?: true;
    userId?: true;
    UserNotifications?: true;
    ReservationNotifications?: true;
    LeadNotifications?: true;
    ContactNotifications?: true;
    PaymentNotifications?: true;
    ReviewNotifications?: true;
  };

  export type PreferencesCountAggregateInputType = {
    id?: true;
    userId?: true;
    UserNotifications?: true;
    ReservationNotifications?: true;
    LeadNotifications?: true;
    ContactNotifications?: true;
    PaymentNotifications?: true;
    ReviewNotifications?: true;
    _all?: true;
  };

  export type PreferencesAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Preferences to aggregate.
     */
    where?: PreferencesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Preferences to fetch.
     */
    orderBy?:
      | PreferencesOrderByWithRelationInput
      | PreferencesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PreferencesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Preferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Preferences
     **/
    _count?: true | PreferencesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PreferencesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PreferencesMaxAggregateInputType;
  };

  export type GetPreferencesAggregateType<T extends PreferencesAggregateArgs> =
    {
      [P in keyof T & keyof AggregatePreferences]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregatePreferences[P]>
        : GetScalarType<T[P], AggregatePreferences[P]>;
    };

  export type PreferencesGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PreferencesWhereInput;
    orderBy?:
      | PreferencesOrderByWithAggregationInput
      | PreferencesOrderByWithAggregationInput[];
    by: PreferencesScalarFieldEnum[] | PreferencesScalarFieldEnum;
    having?: PreferencesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PreferencesCountAggregateInputType | true;
    _min?: PreferencesMinAggregateInputType;
    _max?: PreferencesMaxAggregateInputType;
  };

  export type PreferencesGroupByOutputType = {
    id: string;
    userId: string;
    UserNotifications: boolean;
    ReservationNotifications: boolean;
    LeadNotifications: boolean;
    ContactNotifications: boolean;
    PaymentNotifications: boolean;
    ReviewNotifications: boolean;
    _count: PreferencesCountAggregateOutputType | null;
    _min: PreferencesMinAggregateOutputType | null;
    _max: PreferencesMaxAggregateOutputType | null;
  };

  type GetPreferencesGroupByPayload<T extends PreferencesGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PreferencesGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof PreferencesGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], PreferencesGroupByOutputType[P]>;
        }
      >
    >;

  export type PreferencesSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      UserNotifications?: boolean;
      ReservationNotifications?: boolean;
      LeadNotifications?: boolean;
      ContactNotifications?: boolean;
      PaymentNotifications?: boolean;
      ReviewNotifications?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["preferences"]
  >;

  export type PreferencesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      UserNotifications?: boolean;
      ReservationNotifications?: boolean;
      LeadNotifications?: boolean;
      ContactNotifications?: boolean;
      PaymentNotifications?: boolean;
      ReviewNotifications?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["preferences"]
  >;

  export type PreferencesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      UserNotifications?: boolean;
      ReservationNotifications?: boolean;
      LeadNotifications?: boolean;
      ContactNotifications?: boolean;
      PaymentNotifications?: boolean;
      ReviewNotifications?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["preferences"]
  >;

  export type PreferencesSelectScalar = {
    id?: boolean;
    userId?: boolean;
    UserNotifications?: boolean;
    ReservationNotifications?: boolean;
    LeadNotifications?: boolean;
    ContactNotifications?: boolean;
    PaymentNotifications?: boolean;
    ReviewNotifications?: boolean;
  };

  export type PreferencesOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "UserNotifications"
    | "ReservationNotifications"
    | "LeadNotifications"
    | "ContactNotifications"
    | "PaymentNotifications"
    | "ReviewNotifications",
    ExtArgs["result"]["preferences"]
  >;
  export type PreferencesInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type PreferencesIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type PreferencesIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PreferencesPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Preferences";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        UserNotifications: boolean;
        ReservationNotifications: boolean;
        LeadNotifications: boolean;
        ContactNotifications: boolean;
        PaymentNotifications: boolean;
        ReviewNotifications: boolean;
      },
      ExtArgs["result"]["preferences"]
    >;
    composites: {};
  };

  type PreferencesGetPayload<
    S extends boolean | null | undefined | PreferencesDefaultArgs,
  > = $Result.GetResult<Prisma.$PreferencesPayload, S>;

  type PreferencesCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PreferencesFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: PreferencesCountAggregateInputType | true;
  };

  export interface PreferencesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Preferences"];
      meta: { name: "Preferences" };
    };
    /**
     * Find zero or one Preferences that matches the filter.
     * @param {PreferencesFindUniqueArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreferencesFindUniqueArgs>(
      args: SelectSubset<T, PreferencesFindUniqueArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Preferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreferencesFindUniqueOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreferencesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PreferencesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreferencesFindFirstArgs>(
      args?: SelectSubset<T, PreferencesFindFirstArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Preferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreferencesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PreferencesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preferences
     * const preferences = await prisma.preferences.findMany()
     *
     * // Get first 10 Preferences
     * const preferences = await prisma.preferences.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const preferencesWithIdOnly = await prisma.preferences.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PreferencesFindManyArgs>(
      args?: SelectSubset<T, PreferencesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Preferences.
     * @param {PreferencesCreateArgs} args - Arguments to create a Preferences.
     * @example
     * // Create one Preferences
     * const Preferences = await prisma.preferences.create({
     *   data: {
     *     // ... data to create a Preferences
     *   }
     * })
     *
     */
    create<T extends PreferencesCreateArgs>(
      args: SelectSubset<T, PreferencesCreateArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Preferences.
     * @param {PreferencesCreateManyArgs} args - Arguments to create many Preferences.
     * @example
     * // Create many Preferences
     * const preferences = await prisma.preferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PreferencesCreateManyArgs>(
      args?: SelectSubset<T, PreferencesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Preferences and returns the data saved in the database.
     * @param {PreferencesCreateManyAndReturnArgs} args - Arguments to create many Preferences.
     * @example
     * // Create many Preferences
     * const preferences = await prisma.preferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Preferences and only return the `id`
     * const preferencesWithIdOnly = await prisma.preferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PreferencesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PreferencesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Preferences.
     * @param {PreferencesDeleteArgs} args - Arguments to delete one Preferences.
     * @example
     * // Delete one Preferences
     * const Preferences = await prisma.preferences.delete({
     *   where: {
     *     // ... filter to delete one Preferences
     *   }
     * })
     *
     */
    delete<T extends PreferencesDeleteArgs>(
      args: SelectSubset<T, PreferencesDeleteArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Preferences.
     * @param {PreferencesUpdateArgs} args - Arguments to update one Preferences.
     * @example
     * // Update one Preferences
     * const preferences = await prisma.preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PreferencesUpdateArgs>(
      args: SelectSubset<T, PreferencesUpdateArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Preferences.
     * @param {PreferencesDeleteManyArgs} args - Arguments to filter Preferences to delete.
     * @example
     * // Delete a few Preferences
     * const { count } = await prisma.preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PreferencesDeleteManyArgs>(
      args?: SelectSubset<T, PreferencesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preferences
     * const preferences = await prisma.preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PreferencesUpdateManyArgs>(
      args: SelectSubset<T, PreferencesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Preferences and returns the data updated in the database.
     * @param {PreferencesUpdateManyAndReturnArgs} args - Arguments to update many Preferences.
     * @example
     * // Update many Preferences
     * const preferences = await prisma.preferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Preferences and only return the `id`
     * const preferencesWithIdOnly = await prisma.preferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PreferencesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PreferencesUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Preferences.
     * @param {PreferencesUpsertArgs} args - Arguments to update or create a Preferences.
     * @example
     * // Update or create a Preferences
     * const preferences = await prisma.preferences.upsert({
     *   create: {
     *     // ... data to create a Preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preferences we want to update
     *   }
     * })
     */
    upsert<T extends PreferencesUpsertArgs>(
      args: SelectSubset<T, PreferencesUpsertArgs<ExtArgs>>
    ): Prisma__PreferencesClient<
      $Result.GetResult<
        Prisma.$PreferencesPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesCountArgs} args - Arguments to filter Preferences to count.
     * @example
     * // Count the number of Preferences
     * const count = await prisma.preferences.count({
     *   where: {
     *     // ... the filter for the Preferences we want to count
     *   }
     * })
     **/
    count<T extends PreferencesCountArgs>(
      args?: Subset<T, PreferencesCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PreferencesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PreferencesAggregateArgs>(
      args: Subset<T, PreferencesAggregateArgs>
    ): Prisma.PrismaPromise<GetPreferencesAggregateType<T>>;

    /**
     * Group by Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferencesGroupByArgs["orderBy"] }
        : { orderBy?: PreferencesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PreferencesGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPreferencesGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Preferences model
     */
    readonly fields: PreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferencesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Preferences model
   */
  interface PreferencesFieldRefs {
    readonly id: FieldRef<"Preferences", "String">;
    readonly userId: FieldRef<"Preferences", "String">;
    readonly UserNotifications: FieldRef<"Preferences", "Boolean">;
    readonly ReservationNotifications: FieldRef<"Preferences", "Boolean">;
    readonly LeadNotifications: FieldRef<"Preferences", "Boolean">;
    readonly ContactNotifications: FieldRef<"Preferences", "Boolean">;
    readonly PaymentNotifications: FieldRef<"Preferences", "Boolean">;
    readonly ReviewNotifications: FieldRef<"Preferences", "Boolean">;
  }

  // Custom InputTypes
  /**
   * Preferences findUnique
   */
  export type PreferencesFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * Filter, which Preferences to fetch.
     */
    where: PreferencesWhereUniqueInput;
  };

  /**
   * Preferences findUniqueOrThrow
   */
  export type PreferencesFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * Filter, which Preferences to fetch.
     */
    where: PreferencesWhereUniqueInput;
  };

  /**
   * Preferences findFirst
   */
  export type PreferencesFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Preferences to fetch.
     */
    orderBy?:
      | PreferencesOrderByWithRelationInput
      | PreferencesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferencesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Preferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[];
  };

  /**
   * Preferences findFirstOrThrow
   */
  export type PreferencesFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Preferences to fetch.
     */
    orderBy?:
      | PreferencesOrderByWithRelationInput
      | PreferencesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Preferences.
     */
    cursor?: PreferencesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Preferences.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Preferences.
     */
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[];
  };

  /**
   * Preferences findMany
   */
  export type PreferencesFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * Filter, which Preferences to fetch.
     */
    where?: PreferencesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Preferences to fetch.
     */
    orderBy?:
      | PreferencesOrderByWithRelationInput
      | PreferencesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Preferences.
     */
    cursor?: PreferencesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Preferences from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Preferences.
     */
    skip?: number;
    distinct?: PreferencesScalarFieldEnum | PreferencesScalarFieldEnum[];
  };

  /**
   * Preferences create
   */
  export type PreferencesCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * The data needed to create a Preferences.
     */
    data: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>;
  };

  /**
   * Preferences createMany
   */
  export type PreferencesCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Preferences.
     */
    data: PreferencesCreateManyInput | PreferencesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Preferences createManyAndReturn
   */
  export type PreferencesCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * The data used to create many Preferences.
     */
    data: PreferencesCreateManyInput | PreferencesCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Preferences update
   */
  export type PreferencesUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * The data needed to update a Preferences.
     */
    data: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>;
    /**
     * Choose, which Preferences to update.
     */
    where: PreferencesWhereUniqueInput;
  };

  /**
   * Preferences updateMany
   */
  export type PreferencesUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Preferences.
     */
    data: XOR<
      PreferencesUpdateManyMutationInput,
      PreferencesUncheckedUpdateManyInput
    >;
    /**
     * Filter which Preferences to update
     */
    where?: PreferencesWhereInput;
    /**
     * Limit how many Preferences to update.
     */
    limit?: number;
  };

  /**
   * Preferences updateManyAndReturn
   */
  export type PreferencesUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * The data used to update Preferences.
     */
    data: XOR<
      PreferencesUpdateManyMutationInput,
      PreferencesUncheckedUpdateManyInput
    >;
    /**
     * Filter which Preferences to update
     */
    where?: PreferencesWhereInput;
    /**
     * Limit how many Preferences to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Preferences upsert
   */
  export type PreferencesUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * The filter to search for the Preferences to update in case it exists.
     */
    where: PreferencesWhereUniqueInput;
    /**
     * In case the Preferences found by the `where` argument doesn't exist, create a new Preferences with this data.
     */
    create: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>;
    /**
     * In case the Preferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>;
  };

  /**
   * Preferences delete
   */
  export type PreferencesDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
    /**
     * Filter which Preferences to delete.
     */
    where: PreferencesWhereUniqueInput;
  };

  /**
   * Preferences deleteMany
   */
  export type PreferencesDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Preferences to delete
     */
    where?: PreferencesWhereInput;
    /**
     * Limit how many Preferences to delete.
     */
    limit?: number;
  };

  /**
   * Preferences without action
   */
  export type PreferencesDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Preferences
     */
    select?: PreferencesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Preferences
     */
    omit?: PreferencesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferencesInclude<ExtArgs> | null;
  };

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    id: number | null;
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    id: number | null;
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    id: number | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    providerAccountId: string | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: number | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    providerAccountId: string | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    provider: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    providerAccountId: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    id?: true;
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    id?: true;
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    providerAccountId?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    providerAccountId?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    providerAccountId?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithAggregationInput
      | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: number;
    userId: string;
    type: string;
    provider: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    providerAccountId: string;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AccountGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AccountGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>;
        }
      >
    >;

  export type AccountSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      providerAccountId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      providerAccountId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      providerAccountId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
    providerAccountId?: boolean;
  };

  export type AccountOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "type"
    | "provider"
    | "refresh_token"
    | "access_token"
    | "expires_at"
    | "token_type"
    | "scope"
    | "id_token"
    | "session_state"
    | "providerAccountId",
    ExtArgs["result"]["account"]
  >;
  export type AccountInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Account";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        userId: string;
        type: string;
        provider: string;
        refresh_token: string | null;
        access_token: string | null;
        expires_at: number | null;
        token_type: string | null;
        scope: string | null;
        id_token: string | null;
        session_state: string | null;
        providerAccountId: string;
      },
      ExtArgs["result"]["account"]
    >;
    composites: {};
  };

  type AccountGetPayload<
    S extends boolean | null | undefined | AccountDefaultArgs,
  > = $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AccountFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Account"];
      meta: { name: "Account" };
    };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs["orderBy"] }
        : { orderBy?: AccountGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAccountGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", "Int">;
    readonly userId: FieldRef<"Account", "String">;
    readonly type: FieldRef<"Account", "String">;
    readonly provider: FieldRef<"Account", "String">;
    readonly refresh_token: FieldRef<"Account", "String">;
    readonly access_token: FieldRef<"Account", "String">;
    readonly expires_at: FieldRef<"Account", "Int">;
    readonly token_type: FieldRef<"Account", "String">;
    readonly scope: FieldRef<"Account", "String">;
    readonly id_token: FieldRef<"Account", "String">;
    readonly session_state: FieldRef<"Account", "String">;
    readonly providerAccountId: FieldRef<"Account", "String">;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
  };

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null;
    _avg: ReservationAvgAggregateOutputType | null;
    _sum: ReservationSumAggregateOutputType | null;
    _min: ReservationMinAggregateOutputType | null;
    _max: ReservationMaxAggregateOutputType | null;
  };

  export type ReservationAvgAggregateOutputType = {
    dailyRate: Decimal | null;
    totalDays: Decimal | null;
    subtotal: Decimal | null;
    tax: Decimal | null;
    totalAmount: Decimal | null;
    amountPaid: Decimal | null;
    vehicleId: number | null;
  };

  export type ReservationSumAggregateOutputType = {
    dailyRate: Decimal | null;
    totalDays: Decimal | null;
    subtotal: Decimal | null;
    tax: Decimal | null;
    totalAmount: Decimal | null;
    amountPaid: Decimal | null;
    vehicleId: number | null;
  };

  export type ReservationMinAggregateOutputType = {
    id: string | null;
    pickupDate: Date | null;
    dropoffDate: Date | null;
    pickupLocation: string | null;
    dropoffLocation: string | null;
    pickupHour: string | null;
    dropoffHour: string | null;
    dailyRate: Decimal | null;
    totalDays: Decimal | null;
    subtotal: Decimal | null;
    tax: Decimal | null;
    totalAmount: Decimal | null;
    amountPaid: Decimal | null;
    status: $Enums.ReservationStatus | null;
    paymentStatus: $Enums.PaymentStatus | null;
    notes: string | null;
    specialRequests: string | null;
    vehicleId: number | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ReservationMaxAggregateOutputType = {
    id: string | null;
    pickupDate: Date | null;
    dropoffDate: Date | null;
    pickupLocation: string | null;
    dropoffLocation: string | null;
    pickupHour: string | null;
    dropoffHour: string | null;
    dailyRate: Decimal | null;
    totalDays: Decimal | null;
    subtotal: Decimal | null;
    tax: Decimal | null;
    totalAmount: Decimal | null;
    amountPaid: Decimal | null;
    status: $Enums.ReservationStatus | null;
    paymentStatus: $Enums.PaymentStatus | null;
    notes: string | null;
    specialRequests: string | null;
    vehicleId: number | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ReservationCountAggregateOutputType = {
    id: number;
    pickupDate: number;
    dropoffDate: number;
    pickupLocation: number;
    dropoffLocation: number;
    pickupHour: number;
    dropoffHour: number;
    dailyRate: number;
    totalDays: number;
    subtotal: number;
    tax: number;
    totalAmount: number;
    amountPaid: number;
    status: number;
    paymentStatus: number;
    notes: number;
    specialRequests: number;
    vehicleId: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ReservationAvgAggregateInputType = {
    dailyRate?: true;
    totalDays?: true;
    subtotal?: true;
    tax?: true;
    totalAmount?: true;
    amountPaid?: true;
    vehicleId?: true;
  };

  export type ReservationSumAggregateInputType = {
    dailyRate?: true;
    totalDays?: true;
    subtotal?: true;
    tax?: true;
    totalAmount?: true;
    amountPaid?: true;
    vehicleId?: true;
  };

  export type ReservationMinAggregateInputType = {
    id?: true;
    pickupDate?: true;
    dropoffDate?: true;
    pickupLocation?: true;
    dropoffLocation?: true;
    pickupHour?: true;
    dropoffHour?: true;
    dailyRate?: true;
    totalDays?: true;
    subtotal?: true;
    tax?: true;
    totalAmount?: true;
    amountPaid?: true;
    status?: true;
    paymentStatus?: true;
    notes?: true;
    specialRequests?: true;
    vehicleId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ReservationMaxAggregateInputType = {
    id?: true;
    pickupDate?: true;
    dropoffDate?: true;
    pickupLocation?: true;
    dropoffLocation?: true;
    pickupHour?: true;
    dropoffHour?: true;
    dailyRate?: true;
    totalDays?: true;
    subtotal?: true;
    tax?: true;
    totalAmount?: true;
    amountPaid?: true;
    status?: true;
    paymentStatus?: true;
    notes?: true;
    specialRequests?: true;
    vehicleId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ReservationCountAggregateInputType = {
    id?: true;
    pickupDate?: true;
    dropoffDate?: true;
    pickupLocation?: true;
    dropoffLocation?: true;
    pickupHour?: true;
    dropoffHour?: true;
    dailyRate?: true;
    totalDays?: true;
    subtotal?: true;
    tax?: true;
    totalAmount?: true;
    amountPaid?: true;
    status?: true;
    paymentStatus?: true;
    notes?: true;
    specialRequests?: true;
    vehicleId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ReservationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reservations to fetch.
     */
    orderBy?:
      | ReservationOrderByWithRelationInput
      | ReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reservations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reservations
     **/
    _count?: true | ReservationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ReservationAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ReservationSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReservationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReservationMaxAggregateInputType;
  };

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> =
    {
      [P in keyof T & keyof AggregateReservation]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateReservation[P]>
        : GetScalarType<T[P], AggregateReservation[P]>;
    };

  export type ReservationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReservationWhereInput;
    orderBy?:
      | ReservationOrderByWithAggregationInput
      | ReservationOrderByWithAggregationInput[];
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum;
    having?: ReservationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReservationCountAggregateInputType | true;
    _avg?: ReservationAvgAggregateInputType;
    _sum?: ReservationSumAggregateInputType;
    _min?: ReservationMinAggregateInputType;
    _max?: ReservationMaxAggregateInputType;
  };

  export type ReservationGroupByOutputType = {
    id: string;
    pickupDate: Date;
    dropoffDate: Date;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal;
    totalDays: Decimal;
    subtotal: Decimal;
    tax: Decimal;
    totalAmount: Decimal;
    amountPaid: Decimal;
    status: $Enums.ReservationStatus;
    paymentStatus: $Enums.PaymentStatus;
    notes: string | null;
    specialRequests: string | null;
    vehicleId: number | null;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ReservationCountAggregateOutputType | null;
    _avg: ReservationAvgAggregateOutputType | null;
    _sum: ReservationSumAggregateOutputType | null;
    _min: ReservationMinAggregateOutputType | null;
    _max: ReservationMaxAggregateOutputType | null;
  };

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ReservationGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ReservationGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>;
        }
      >
    >;

  export type ReservationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      pickupDate?: boolean;
      dropoffDate?: boolean;
      pickupLocation?: boolean;
      dropoffLocation?: boolean;
      pickupHour?: boolean;
      dropoffHour?: boolean;
      dailyRate?: boolean;
      totalDays?: boolean;
      subtotal?: boolean;
      tax?: boolean;
      totalAmount?: boolean;
      amountPaid?: boolean;
      status?: boolean;
      paymentStatus?: boolean;
      notes?: boolean;
      specialRequests?: boolean;
      vehicleId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      contracts?: boolean | Reservation$contractsArgs<ExtArgs>;
      payments?: boolean | Reservation$paymentsArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      vehicle?: boolean | Reservation$vehicleArgs<ExtArgs>;
      statusHistory?: boolean | Reservation$statusHistoryArgs<ExtArgs>;
      _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["reservation"]
  >;

  export type ReservationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      pickupDate?: boolean;
      dropoffDate?: boolean;
      pickupLocation?: boolean;
      dropoffLocation?: boolean;
      pickupHour?: boolean;
      dropoffHour?: boolean;
      dailyRate?: boolean;
      totalDays?: boolean;
      subtotal?: boolean;
      tax?: boolean;
      totalAmount?: boolean;
      amountPaid?: boolean;
      status?: boolean;
      paymentStatus?: boolean;
      notes?: boolean;
      specialRequests?: boolean;
      vehicleId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      vehicle?: boolean | Reservation$vehicleArgs<ExtArgs>;
    },
    ExtArgs["result"]["reservation"]
  >;

  export type ReservationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      pickupDate?: boolean;
      dropoffDate?: boolean;
      pickupLocation?: boolean;
      dropoffLocation?: boolean;
      pickupHour?: boolean;
      dropoffHour?: boolean;
      dailyRate?: boolean;
      totalDays?: boolean;
      subtotal?: boolean;
      tax?: boolean;
      totalAmount?: boolean;
      amountPaid?: boolean;
      status?: boolean;
      paymentStatus?: boolean;
      notes?: boolean;
      specialRequests?: boolean;
      vehicleId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      vehicle?: boolean | Reservation$vehicleArgs<ExtArgs>;
    },
    ExtArgs["result"]["reservation"]
  >;

  export type ReservationSelectScalar = {
    id?: boolean;
    pickupDate?: boolean;
    dropoffDate?: boolean;
    pickupLocation?: boolean;
    dropoffLocation?: boolean;
    pickupHour?: boolean;
    dropoffHour?: boolean;
    dailyRate?: boolean;
    totalDays?: boolean;
    subtotal?: boolean;
    tax?: boolean;
    totalAmount?: boolean;
    amountPaid?: boolean;
    status?: boolean;
    paymentStatus?: boolean;
    notes?: boolean;
    specialRequests?: boolean;
    vehicleId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ReservationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "pickupDate"
    | "dropoffDate"
    | "pickupLocation"
    | "dropoffLocation"
    | "pickupHour"
    | "dropoffHour"
    | "dailyRate"
    | "totalDays"
    | "subtotal"
    | "tax"
    | "totalAmount"
    | "amountPaid"
    | "status"
    | "paymentStatus"
    | "notes"
    | "specialRequests"
    | "vehicleId"
    | "userId"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["reservation"]
  >;
  export type ReservationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    contracts?: boolean | Reservation$contractsArgs<ExtArgs>;
    payments?: boolean | Reservation$paymentsArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    vehicle?: boolean | Reservation$vehicleArgs<ExtArgs>;
    statusHistory?: boolean | Reservation$statusHistoryArgs<ExtArgs>;
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ReservationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    vehicle?: boolean | Reservation$vehicleArgs<ExtArgs>;
  };
  export type ReservationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    vehicle?: boolean | Reservation$vehicleArgs<ExtArgs>;
  };

  export type $ReservationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Reservation";
    objects: {
      contracts: Prisma.$DocumentPayload<ExtArgs>[];
      payments: Prisma.$PaymentPayload<ExtArgs>[];
      user: Prisma.$UserPayload<ExtArgs>;
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null;
      statusHistory: Prisma.$StatusChangePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        pickupDate: Date;
        dropoffDate: Date;
        pickupLocation: string;
        dropoffLocation: string;
        pickupHour: string;
        dropoffHour: string;
        dailyRate: Prisma.Decimal;
        totalDays: Prisma.Decimal;
        subtotal: Prisma.Decimal;
        tax: Prisma.Decimal;
        totalAmount: Prisma.Decimal;
        amountPaid: Prisma.Decimal;
        status: $Enums.ReservationStatus;
        paymentStatus: $Enums.PaymentStatus;
        notes: string | null;
        specialRequests: string | null;
        vehicleId: number | null;
        userId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["reservation"]
    >;
    composites: {};
  };

  type ReservationGetPayload<
    S extends boolean | null | undefined | ReservationDefaultArgs,
  > = $Result.GetResult<Prisma.$ReservationPayload, S>;

  type ReservationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ReservationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ReservationCountAggregateInputType | true;
  };

  export interface ReservationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Reservation"];
      meta: { name: "Reservation" };
    };
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(
      args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(
      args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     *
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReservationFindManyArgs>(
      args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     *
     */
    create<T extends ReservationCreateArgs>(
      args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReservationCreateManyArgs>(
      args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     *
     */
    delete<T extends ReservationDeleteArgs>(
      args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReservationUpdateArgs>(
      args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReservationDeleteManyArgs>(
      args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReservationUpdateManyArgs>(
      args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(
      args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
     **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ReservationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReservationAggregateArgs>(
      args: Subset<T, ReservationAggregateArgs>
    ): Prisma.PrismaPromise<GetReservationAggregateType<T>>;

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs["orderBy"] }
        : { orderBy?: ReservationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetReservationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Reservation model
     */
    readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    contracts<T extends Reservation$contractsArgs<ExtArgs> = {}>(
      args?: Subset<T, Reservation$contractsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$DocumentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    payments<T extends Reservation$paymentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Reservation$paymentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaymentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    vehicle<T extends Reservation$vehicleArgs<ExtArgs> = {}>(
      args?: Subset<T, Reservation$vehicleArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    statusHistory<T extends Reservation$statusHistoryArgs<ExtArgs> = {}>(
      args?: Subset<T, Reservation$statusHistoryArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$StatusChangePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", "String">;
    readonly pickupDate: FieldRef<"Reservation", "DateTime">;
    readonly dropoffDate: FieldRef<"Reservation", "DateTime">;
    readonly pickupLocation: FieldRef<"Reservation", "String">;
    readonly dropoffLocation: FieldRef<"Reservation", "String">;
    readonly pickupHour: FieldRef<"Reservation", "String">;
    readonly dropoffHour: FieldRef<"Reservation", "String">;
    readonly dailyRate: FieldRef<"Reservation", "Decimal">;
    readonly totalDays: FieldRef<"Reservation", "Decimal">;
    readonly subtotal: FieldRef<"Reservation", "Decimal">;
    readonly tax: FieldRef<"Reservation", "Decimal">;
    readonly totalAmount: FieldRef<"Reservation", "Decimal">;
    readonly amountPaid: FieldRef<"Reservation", "Decimal">;
    readonly status: FieldRef<"Reservation", "ReservationStatus">;
    readonly paymentStatus: FieldRef<"Reservation", "PaymentStatus">;
    readonly notes: FieldRef<"Reservation", "String">;
    readonly specialRequests: FieldRef<"Reservation", "String">;
    readonly vehicleId: FieldRef<"Reservation", "Int">;
    readonly userId: FieldRef<"Reservation", "String">;
    readonly createdAt: FieldRef<"Reservation", "DateTime">;
    readonly updatedAt: FieldRef<"Reservation", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput;
  };

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput;
  };

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reservations to fetch.
     */
    orderBy?:
      | ReservationOrderByWithRelationInput
      | ReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reservations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[];
  };

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reservations to fetch.
     */
    orderBy?:
      | ReservationOrderByWithRelationInput
      | ReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reservations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[];
  };

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reservations to fetch.
     */
    orderBy?:
      | ReservationOrderByWithRelationInput
      | ReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reservations.
     */
    skip?: number;
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[];
  };

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>;
  };

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>;
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput;
  };

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<
      ReservationUpdateManyMutationInput,
      ReservationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput;
    /**
     * Limit how many Reservations to update.
     */
    limit?: number;
  };

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * The data used to update Reservations.
     */
    data: XOR<
      ReservationUpdateManyMutationInput,
      ReservationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput;
    /**
     * Limit how many Reservations to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput;
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>;
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>;
  };

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput;
  };

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput;
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number;
  };

  /**
   * Reservation.contracts
   */
  export type Reservation$contractsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    where?: DocumentWhereInput;
    orderBy?:
      | DocumentOrderByWithRelationInput
      | DocumentOrderByWithRelationInput[];
    cursor?: DocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Reservation.payments
   */
  export type Reservation$paymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    where?: PaymentWhereInput;
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    cursor?: PaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Reservation.vehicle
   */
  export type Reservation$vehicleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    where?: VehicleWhereInput;
  };

  /**
   * Reservation.statusHistory
   */
  export type Reservation$statusHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    where?: StatusChangeWhereInput;
    orderBy?:
      | StatusChangeOrderByWithRelationInput
      | StatusChangeOrderByWithRelationInput[];
    cursor?: StatusChangeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[];
  };

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
  };

  /**
   * Model DraftReservation
   */

  export type AggregateDraftReservation = {
    _count: DraftReservationCountAggregateOutputType | null;
    _avg: DraftReservationAvgAggregateOutputType | null;
    _sum: DraftReservationSumAggregateOutputType | null;
    _min: DraftReservationMinAggregateOutputType | null;
    _max: DraftReservationMaxAggregateOutputType | null;
  };

  export type DraftReservationAvgAggregateOutputType = {
    vehicleId: number | null;
  };

  export type DraftReservationSumAggregateOutputType = {
    vehicleId: number | null;
  };

  export type DraftReservationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    phone: string | null;
    vehicleId: number | null;
    message: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    dropoffDate: string | null;
    dropoffHour: string | null;
    dropoffLocation: string | null;
    pickupDate: string | null;
    pickupHour: string | null;
    pickupLocation: string | null;
  };

  export type DraftReservationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    phone: string | null;
    vehicleId: number | null;
    message: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    dropoffDate: string | null;
    dropoffHour: string | null;
    dropoffLocation: string | null;
    pickupDate: string | null;
    pickupHour: string | null;
    pickupLocation: string | null;
  };

  export type DraftReservationCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    phone: number;
    vehicleId: number;
    message: number;
    createdAt: number;
    updatedAt: number;
    dropoffDate: number;
    dropoffHour: number;
    dropoffLocation: number;
    pickupDate: number;
    pickupHour: number;
    pickupLocation: number;
    _all: number;
  };

  export type DraftReservationAvgAggregateInputType = {
    vehicleId?: true;
  };

  export type DraftReservationSumAggregateInputType = {
    vehicleId?: true;
  };

  export type DraftReservationMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    phone?: true;
    vehicleId?: true;
    message?: true;
    createdAt?: true;
    updatedAt?: true;
    dropoffDate?: true;
    dropoffHour?: true;
    dropoffLocation?: true;
    pickupDate?: true;
    pickupHour?: true;
    pickupLocation?: true;
  };

  export type DraftReservationMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    phone?: true;
    vehicleId?: true;
    message?: true;
    createdAt?: true;
    updatedAt?: true;
    dropoffDate?: true;
    dropoffHour?: true;
    dropoffLocation?: true;
    pickupDate?: true;
    pickupHour?: true;
    pickupLocation?: true;
  };

  export type DraftReservationCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    phone?: true;
    vehicleId?: true;
    message?: true;
    createdAt?: true;
    updatedAt?: true;
    dropoffDate?: true;
    dropoffHour?: true;
    dropoffLocation?: true;
    pickupDate?: true;
    pickupHour?: true;
    pickupLocation?: true;
    _all?: true;
  };

  export type DraftReservationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DraftReservation to aggregate.
     */
    where?: DraftReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DraftReservations to fetch.
     */
    orderBy?:
      | DraftReservationOrderByWithRelationInput
      | DraftReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DraftReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DraftReservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DraftReservations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DraftReservations
     **/
    _count?: true | DraftReservationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DraftReservationAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DraftReservationSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DraftReservationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DraftReservationMaxAggregateInputType;
  };

  export type GetDraftReservationAggregateType<
    T extends DraftReservationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateDraftReservation]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDraftReservation[P]>
      : GetScalarType<T[P], AggregateDraftReservation[P]>;
  };

  export type DraftReservationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DraftReservationWhereInput;
    orderBy?:
      | DraftReservationOrderByWithAggregationInput
      | DraftReservationOrderByWithAggregationInput[];
    by: DraftReservationScalarFieldEnum[] | DraftReservationScalarFieldEnum;
    having?: DraftReservationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DraftReservationCountAggregateInputType | true;
    _avg?: DraftReservationAvgAggregateInputType;
    _sum?: DraftReservationSumAggregateInputType;
    _min?: DraftReservationMinAggregateInputType;
    _max?: DraftReservationMaxAggregateInputType;
  };

  export type DraftReservationGroupByOutputType = {
    id: string;
    name: string;
    email: string;
    phone: string;
    vehicleId: number | null;
    message: string | null;
    createdAt: Date;
    updatedAt: Date;
    dropoffDate: string;
    dropoffHour: string;
    dropoffLocation: string;
    pickupDate: string;
    pickupHour: string;
    pickupLocation: string;
    _count: DraftReservationCountAggregateOutputType | null;
    _avg: DraftReservationAvgAggregateOutputType | null;
    _sum: DraftReservationSumAggregateOutputType | null;
    _min: DraftReservationMinAggregateOutputType | null;
    _max: DraftReservationMaxAggregateOutputType | null;
  };

  type GetDraftReservationGroupByPayload<
    T extends DraftReservationGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DraftReservationGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof DraftReservationGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DraftReservationGroupByOutputType[P]>
          : GetScalarType<T[P], DraftReservationGroupByOutputType[P]>;
      }
    >
  >;

  export type DraftReservationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      phone?: boolean;
      vehicleId?: boolean;
      message?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dropoffDate?: boolean;
      dropoffHour?: boolean;
      dropoffLocation?: boolean;
      pickupDate?: boolean;
      pickupHour?: boolean;
      pickupLocation?: boolean;
    },
    ExtArgs["result"]["draftReservation"]
  >;

  export type DraftReservationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      phone?: boolean;
      vehicleId?: boolean;
      message?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dropoffDate?: boolean;
      dropoffHour?: boolean;
      dropoffLocation?: boolean;
      pickupDate?: boolean;
      pickupHour?: boolean;
      pickupLocation?: boolean;
    },
    ExtArgs["result"]["draftReservation"]
  >;

  export type DraftReservationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      phone?: boolean;
      vehicleId?: boolean;
      message?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dropoffDate?: boolean;
      dropoffHour?: boolean;
      dropoffLocation?: boolean;
      pickupDate?: boolean;
      pickupHour?: boolean;
      pickupLocation?: boolean;
    },
    ExtArgs["result"]["draftReservation"]
  >;

  export type DraftReservationSelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    phone?: boolean;
    vehicleId?: boolean;
    message?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    dropoffDate?: boolean;
    dropoffHour?: boolean;
    dropoffLocation?: boolean;
    pickupDate?: boolean;
    pickupHour?: boolean;
    pickupLocation?: boolean;
  };

  export type DraftReservationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "email"
    | "phone"
    | "vehicleId"
    | "message"
    | "createdAt"
    | "updatedAt"
    | "dropoffDate"
    | "dropoffHour"
    | "dropoffLocation"
    | "pickupDate"
    | "pickupHour"
    | "pickupLocation",
    ExtArgs["result"]["draftReservation"]
  >;

  export type $DraftReservationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "DraftReservation";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        email: string;
        phone: string;
        vehicleId: number | null;
        message: string | null;
        createdAt: Date;
        updatedAt: Date;
        dropoffDate: string;
        dropoffHour: string;
        dropoffLocation: string;
        pickupDate: string;
        pickupHour: string;
        pickupLocation: string;
      },
      ExtArgs["result"]["draftReservation"]
    >;
    composites: {};
  };

  type DraftReservationGetPayload<
    S extends boolean | null | undefined | DraftReservationDefaultArgs,
  > = $Result.GetResult<Prisma.$DraftReservationPayload, S>;

  type DraftReservationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    DraftReservationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: DraftReservationCountAggregateInputType | true;
  };

  export interface DraftReservationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["DraftReservation"];
      meta: { name: "DraftReservation" };
    };
    /**
     * Find zero or one DraftReservation that matches the filter.
     * @param {DraftReservationFindUniqueArgs} args - Arguments to find a DraftReservation
     * @example
     * // Get one DraftReservation
     * const draftReservation = await prisma.draftReservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DraftReservationFindUniqueArgs>(
      args: SelectSubset<T, DraftReservationFindUniqueArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one DraftReservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DraftReservationFindUniqueOrThrowArgs} args - Arguments to find a DraftReservation
     * @example
     * // Get one DraftReservation
     * const draftReservation = await prisma.draftReservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DraftReservationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DraftReservationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DraftReservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftReservationFindFirstArgs} args - Arguments to find a DraftReservation
     * @example
     * // Get one DraftReservation
     * const draftReservation = await prisma.draftReservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DraftReservationFindFirstArgs>(
      args?: SelectSubset<T, DraftReservationFindFirstArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DraftReservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftReservationFindFirstOrThrowArgs} args - Arguments to find a DraftReservation
     * @example
     * // Get one DraftReservation
     * const draftReservation = await prisma.draftReservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DraftReservationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DraftReservationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more DraftReservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DraftReservations
     * const draftReservations = await prisma.draftReservation.findMany()
     *
     * // Get first 10 DraftReservations
     * const draftReservations = await prisma.draftReservation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const draftReservationWithIdOnly = await prisma.draftReservation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DraftReservationFindManyArgs>(
      args?: SelectSubset<T, DraftReservationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a DraftReservation.
     * @param {DraftReservationCreateArgs} args - Arguments to create a DraftReservation.
     * @example
     * // Create one DraftReservation
     * const DraftReservation = await prisma.draftReservation.create({
     *   data: {
     *     // ... data to create a DraftReservation
     *   }
     * })
     *
     */
    create<T extends DraftReservationCreateArgs>(
      args: SelectSubset<T, DraftReservationCreateArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many DraftReservations.
     * @param {DraftReservationCreateManyArgs} args - Arguments to create many DraftReservations.
     * @example
     * // Create many DraftReservations
     * const draftReservation = await prisma.draftReservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DraftReservationCreateManyArgs>(
      args?: SelectSubset<T, DraftReservationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many DraftReservations and returns the data saved in the database.
     * @param {DraftReservationCreateManyAndReturnArgs} args - Arguments to create many DraftReservations.
     * @example
     * // Create many DraftReservations
     * const draftReservation = await prisma.draftReservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DraftReservations and only return the `id`
     * const draftReservationWithIdOnly = await prisma.draftReservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DraftReservationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DraftReservationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a DraftReservation.
     * @param {DraftReservationDeleteArgs} args - Arguments to delete one DraftReservation.
     * @example
     * // Delete one DraftReservation
     * const DraftReservation = await prisma.draftReservation.delete({
     *   where: {
     *     // ... filter to delete one DraftReservation
     *   }
     * })
     *
     */
    delete<T extends DraftReservationDeleteArgs>(
      args: SelectSubset<T, DraftReservationDeleteArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one DraftReservation.
     * @param {DraftReservationUpdateArgs} args - Arguments to update one DraftReservation.
     * @example
     * // Update one DraftReservation
     * const draftReservation = await prisma.draftReservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DraftReservationUpdateArgs>(
      args: SelectSubset<T, DraftReservationUpdateArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more DraftReservations.
     * @param {DraftReservationDeleteManyArgs} args - Arguments to filter DraftReservations to delete.
     * @example
     * // Delete a few DraftReservations
     * const { count } = await prisma.draftReservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DraftReservationDeleteManyArgs>(
      args?: SelectSubset<T, DraftReservationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DraftReservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DraftReservations
     * const draftReservation = await prisma.draftReservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DraftReservationUpdateManyArgs>(
      args: SelectSubset<T, DraftReservationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DraftReservations and returns the data updated in the database.
     * @param {DraftReservationUpdateManyAndReturnArgs} args - Arguments to update many DraftReservations.
     * @example
     * // Update many DraftReservations
     * const draftReservation = await prisma.draftReservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DraftReservations and only return the `id`
     * const draftReservationWithIdOnly = await prisma.draftReservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DraftReservationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DraftReservationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one DraftReservation.
     * @param {DraftReservationUpsertArgs} args - Arguments to update or create a DraftReservation.
     * @example
     * // Update or create a DraftReservation
     * const draftReservation = await prisma.draftReservation.upsert({
     *   create: {
     *     // ... data to create a DraftReservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DraftReservation we want to update
     *   }
     * })
     */
    upsert<T extends DraftReservationUpsertArgs>(
      args: SelectSubset<T, DraftReservationUpsertArgs<ExtArgs>>
    ): Prisma__DraftReservationClient<
      $Result.GetResult<
        Prisma.$DraftReservationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of DraftReservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftReservationCountArgs} args - Arguments to filter DraftReservations to count.
     * @example
     * // Count the number of DraftReservations
     * const count = await prisma.draftReservation.count({
     *   where: {
     *     // ... the filter for the DraftReservations we want to count
     *   }
     * })
     **/
    count<T extends DraftReservationCountArgs>(
      args?: Subset<T, DraftReservationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], DraftReservationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a DraftReservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DraftReservationAggregateArgs>(
      args: Subset<T, DraftReservationAggregateArgs>
    ): Prisma.PrismaPromise<GetDraftReservationAggregateType<T>>;

    /**
     * Group by DraftReservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DraftReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DraftReservationGroupByArgs["orderBy"] }
        : { orderBy?: DraftReservationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DraftReservationGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetDraftReservationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the DraftReservation model
     */
    readonly fields: DraftReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DraftReservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DraftReservationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the DraftReservation model
   */
  interface DraftReservationFieldRefs {
    readonly id: FieldRef<"DraftReservation", "String">;
    readonly name: FieldRef<"DraftReservation", "String">;
    readonly email: FieldRef<"DraftReservation", "String">;
    readonly phone: FieldRef<"DraftReservation", "String">;
    readonly vehicleId: FieldRef<"DraftReservation", "Int">;
    readonly message: FieldRef<"DraftReservation", "String">;
    readonly createdAt: FieldRef<"DraftReservation", "DateTime">;
    readonly updatedAt: FieldRef<"DraftReservation", "DateTime">;
    readonly dropoffDate: FieldRef<"DraftReservation", "String">;
    readonly dropoffHour: FieldRef<"DraftReservation", "String">;
    readonly dropoffLocation: FieldRef<"DraftReservation", "String">;
    readonly pickupDate: FieldRef<"DraftReservation", "String">;
    readonly pickupHour: FieldRef<"DraftReservation", "String">;
    readonly pickupLocation: FieldRef<"DraftReservation", "String">;
  }

  // Custom InputTypes
  /**
   * DraftReservation findUnique
   */
  export type DraftReservationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * Filter, which DraftReservation to fetch.
     */
    where: DraftReservationWhereUniqueInput;
  };

  /**
   * DraftReservation findUniqueOrThrow
   */
  export type DraftReservationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * Filter, which DraftReservation to fetch.
     */
    where: DraftReservationWhereUniqueInput;
  };

  /**
   * DraftReservation findFirst
   */
  export type DraftReservationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * Filter, which DraftReservation to fetch.
     */
    where?: DraftReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DraftReservations to fetch.
     */
    orderBy?:
      | DraftReservationOrderByWithRelationInput
      | DraftReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DraftReservations.
     */
    cursor?: DraftReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DraftReservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DraftReservations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DraftReservations.
     */
    distinct?:
      | DraftReservationScalarFieldEnum
      | DraftReservationScalarFieldEnum[];
  };

  /**
   * DraftReservation findFirstOrThrow
   */
  export type DraftReservationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * Filter, which DraftReservation to fetch.
     */
    where?: DraftReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DraftReservations to fetch.
     */
    orderBy?:
      | DraftReservationOrderByWithRelationInput
      | DraftReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DraftReservations.
     */
    cursor?: DraftReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DraftReservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DraftReservations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DraftReservations.
     */
    distinct?:
      | DraftReservationScalarFieldEnum
      | DraftReservationScalarFieldEnum[];
  };

  /**
   * DraftReservation findMany
   */
  export type DraftReservationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * Filter, which DraftReservations to fetch.
     */
    where?: DraftReservationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DraftReservations to fetch.
     */
    orderBy?:
      | DraftReservationOrderByWithRelationInput
      | DraftReservationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DraftReservations.
     */
    cursor?: DraftReservationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DraftReservations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DraftReservations.
     */
    skip?: number;
    distinct?:
      | DraftReservationScalarFieldEnum
      | DraftReservationScalarFieldEnum[];
  };

  /**
   * DraftReservation create
   */
  export type DraftReservationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * The data needed to create a DraftReservation.
     */
    data: XOR<
      DraftReservationCreateInput,
      DraftReservationUncheckedCreateInput
    >;
  };

  /**
   * DraftReservation createMany
   */
  export type DraftReservationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DraftReservations.
     */
    data: DraftReservationCreateManyInput | DraftReservationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DraftReservation createManyAndReturn
   */
  export type DraftReservationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * The data used to create many DraftReservations.
     */
    data: DraftReservationCreateManyInput | DraftReservationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DraftReservation update
   */
  export type DraftReservationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * The data needed to update a DraftReservation.
     */
    data: XOR<
      DraftReservationUpdateInput,
      DraftReservationUncheckedUpdateInput
    >;
    /**
     * Choose, which DraftReservation to update.
     */
    where: DraftReservationWhereUniqueInput;
  };

  /**
   * DraftReservation updateMany
   */
  export type DraftReservationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DraftReservations.
     */
    data: XOR<
      DraftReservationUpdateManyMutationInput,
      DraftReservationUncheckedUpdateManyInput
    >;
    /**
     * Filter which DraftReservations to update
     */
    where?: DraftReservationWhereInput;
    /**
     * Limit how many DraftReservations to update.
     */
    limit?: number;
  };

  /**
   * DraftReservation updateManyAndReturn
   */
  export type DraftReservationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * The data used to update DraftReservations.
     */
    data: XOR<
      DraftReservationUpdateManyMutationInput,
      DraftReservationUncheckedUpdateManyInput
    >;
    /**
     * Filter which DraftReservations to update
     */
    where?: DraftReservationWhereInput;
    /**
     * Limit how many DraftReservations to update.
     */
    limit?: number;
  };

  /**
   * DraftReservation upsert
   */
  export type DraftReservationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * The filter to search for the DraftReservation to update in case it exists.
     */
    where: DraftReservationWhereUniqueInput;
    /**
     * In case the DraftReservation found by the `where` argument doesn't exist, create a new DraftReservation with this data.
     */
    create: XOR<
      DraftReservationCreateInput,
      DraftReservationUncheckedCreateInput
    >;
    /**
     * In case the DraftReservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      DraftReservationUpdateInput,
      DraftReservationUncheckedUpdateInput
    >;
  };

  /**
   * DraftReservation delete
   */
  export type DraftReservationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
    /**
     * Filter which DraftReservation to delete.
     */
    where: DraftReservationWhereUniqueInput;
  };

  /**
   * DraftReservation deleteMany
   */
  export type DraftReservationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DraftReservations to delete
     */
    where?: DraftReservationWhereInput;
    /**
     * Limit how many DraftReservations to delete.
     */
    limit?: number;
  };

  /**
   * DraftReservation without action
   */
  export type DraftReservationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DraftReservation
     */
    select?: DraftReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DraftReservation
     */
    omit?: DraftReservationOmit<ExtArgs> | null;
  };

  /**
   * Model StatusChange
   */

  export type AggregateStatusChange = {
    _count: StatusChangeCountAggregateOutputType | null;
    _min: StatusChangeMinAggregateOutputType | null;
    _max: StatusChangeMaxAggregateOutputType | null;
  };

  export type StatusChangeMinAggregateOutputType = {
    id: string | null;
    reservationId: string | null;
    fromStatus: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus | null;
    reason: string | null;
    changedBy: string | null;
    changeAt: Date | null;
  };

  export type StatusChangeMaxAggregateOutputType = {
    id: string | null;
    reservationId: string | null;
    fromStatus: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus | null;
    reason: string | null;
    changedBy: string | null;
    changeAt: Date | null;
  };

  export type StatusChangeCountAggregateOutputType = {
    id: number;
    reservationId: number;
    fromStatus: number;
    toStatus: number;
    reason: number;
    changedBy: number;
    changeAt: number;
    _all: number;
  };

  export type StatusChangeMinAggregateInputType = {
    id?: true;
    reservationId?: true;
    fromStatus?: true;
    toStatus?: true;
    reason?: true;
    changedBy?: true;
    changeAt?: true;
  };

  export type StatusChangeMaxAggregateInputType = {
    id?: true;
    reservationId?: true;
    fromStatus?: true;
    toStatus?: true;
    reason?: true;
    changedBy?: true;
    changeAt?: true;
  };

  export type StatusChangeCountAggregateInputType = {
    id?: true;
    reservationId?: true;
    fromStatus?: true;
    toStatus?: true;
    reason?: true;
    changedBy?: true;
    changeAt?: true;
    _all?: true;
  };

  export type StatusChangeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StatusChange to aggregate.
     */
    where?: StatusChangeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?:
      | StatusChangeOrderByWithRelationInput
      | StatusChangeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StatusChangeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StatusChanges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned StatusChanges
     **/
    _count?: true | StatusChangeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StatusChangeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StatusChangeMaxAggregateInputType;
  };

  export type GetStatusChangeAggregateType<
    T extends StatusChangeAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateStatusChange]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusChange[P]>
      : GetScalarType<T[P], AggregateStatusChange[P]>;
  };

  export type StatusChangeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StatusChangeWhereInput;
    orderBy?:
      | StatusChangeOrderByWithAggregationInput
      | StatusChangeOrderByWithAggregationInput[];
    by: StatusChangeScalarFieldEnum[] | StatusChangeScalarFieldEnum;
    having?: StatusChangeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StatusChangeCountAggregateInputType | true;
    _min?: StatusChangeMinAggregateInputType;
    _max?: StatusChangeMaxAggregateInputType;
  };

  export type StatusChangeGroupByOutputType = {
    id: string;
    reservationId: string;
    fromStatus: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason: string | null;
    changedBy: string | null;
    changeAt: Date;
    _count: StatusChangeCountAggregateOutputType | null;
    _min: StatusChangeMinAggregateOutputType | null;
    _max: StatusChangeMaxAggregateOutputType | null;
  };

  type GetStatusChangeGroupByPayload<T extends StatusChangeGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StatusChangeGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof StatusChangeGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusChangeGroupByOutputType[P]>
            : GetScalarType<T[P], StatusChangeGroupByOutputType[P]>;
        }
      >
    >;

  export type StatusChangeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      reservationId?: boolean;
      fromStatus?: boolean;
      toStatus?: boolean;
      reason?: boolean;
      changedBy?: boolean;
      changeAt?: boolean;
      user?: boolean | StatusChange$userArgs<ExtArgs>;
      reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["statusChange"]
  >;

  export type StatusChangeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      reservationId?: boolean;
      fromStatus?: boolean;
      toStatus?: boolean;
      reason?: boolean;
      changedBy?: boolean;
      changeAt?: boolean;
      user?: boolean | StatusChange$userArgs<ExtArgs>;
      reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["statusChange"]
  >;

  export type StatusChangeSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      reservationId?: boolean;
      fromStatus?: boolean;
      toStatus?: boolean;
      reason?: boolean;
      changedBy?: boolean;
      changeAt?: boolean;
      user?: boolean | StatusChange$userArgs<ExtArgs>;
      reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["statusChange"]
  >;

  export type StatusChangeSelectScalar = {
    id?: boolean;
    reservationId?: boolean;
    fromStatus?: boolean;
    toStatus?: boolean;
    reason?: boolean;
    changedBy?: boolean;
    changeAt?: boolean;
  };

  export type StatusChangeOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "reservationId"
    | "fromStatus"
    | "toStatus"
    | "reason"
    | "changedBy"
    | "changeAt",
    ExtArgs["result"]["statusChange"]
  >;
  export type StatusChangeInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | StatusChange$userArgs<ExtArgs>;
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
  };
  export type StatusChangeIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | StatusChange$userArgs<ExtArgs>;
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
  };
  export type StatusChangeIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | StatusChange$userArgs<ExtArgs>;
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
  };

  export type $StatusChangePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "StatusChange";
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      reservation: Prisma.$ReservationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        reservationId: string;
        fromStatus: $Enums.ReservationStatus | null;
        toStatus: $Enums.ReservationStatus;
        reason: string | null;
        changedBy: string | null;
        changeAt: Date;
      },
      ExtArgs["result"]["statusChange"]
    >;
    composites: {};
  };

  type StatusChangeGetPayload<
    S extends boolean | null | undefined | StatusChangeDefaultArgs,
  > = $Result.GetResult<Prisma.$StatusChangePayload, S>;

  type StatusChangeCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    StatusChangeFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: StatusChangeCountAggregateInputType | true;
  };

  export interface StatusChangeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["StatusChange"];
      meta: { name: "StatusChange" };
    };
    /**
     * Find zero or one StatusChange that matches the filter.
     * @param {StatusChangeFindUniqueArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusChangeFindUniqueArgs>(
      args: SelectSubset<T, StatusChangeFindUniqueArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one StatusChange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatusChangeFindUniqueOrThrowArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusChangeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StatusChangeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first StatusChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeFindFirstArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusChangeFindFirstArgs>(
      args?: SelectSubset<T, StatusChangeFindFirstArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first StatusChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeFindFirstOrThrowArgs} args - Arguments to find a StatusChange
     * @example
     * // Get one StatusChange
     * const statusChange = await prisma.statusChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusChangeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StatusChangeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more StatusChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusChanges
     * const statusChanges = await prisma.statusChange.findMany()
     *
     * // Get first 10 StatusChanges
     * const statusChanges = await prisma.statusChange.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const statusChangeWithIdOnly = await prisma.statusChange.findMany({ select: { id: true } })
     *
     */
    findMany<T extends StatusChangeFindManyArgs>(
      args?: SelectSubset<T, StatusChangeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a StatusChange.
     * @param {StatusChangeCreateArgs} args - Arguments to create a StatusChange.
     * @example
     * // Create one StatusChange
     * const StatusChange = await prisma.statusChange.create({
     *   data: {
     *     // ... data to create a StatusChange
     *   }
     * })
     *
     */
    create<T extends StatusChangeCreateArgs>(
      args: SelectSubset<T, StatusChangeCreateArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many StatusChanges.
     * @param {StatusChangeCreateManyArgs} args - Arguments to create many StatusChanges.
     * @example
     * // Create many StatusChanges
     * const statusChange = await prisma.statusChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StatusChangeCreateManyArgs>(
      args?: SelectSubset<T, StatusChangeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many StatusChanges and returns the data saved in the database.
     * @param {StatusChangeCreateManyAndReturnArgs} args - Arguments to create many StatusChanges.
     * @example
     * // Create many StatusChanges
     * const statusChange = await prisma.statusChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many StatusChanges and only return the `id`
     * const statusChangeWithIdOnly = await prisma.statusChange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends StatusChangeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, StatusChangeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a StatusChange.
     * @param {StatusChangeDeleteArgs} args - Arguments to delete one StatusChange.
     * @example
     * // Delete one StatusChange
     * const StatusChange = await prisma.statusChange.delete({
     *   where: {
     *     // ... filter to delete one StatusChange
     *   }
     * })
     *
     */
    delete<T extends StatusChangeDeleteArgs>(
      args: SelectSubset<T, StatusChangeDeleteArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one StatusChange.
     * @param {StatusChangeUpdateArgs} args - Arguments to update one StatusChange.
     * @example
     * // Update one StatusChange
     * const statusChange = await prisma.statusChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StatusChangeUpdateArgs>(
      args: SelectSubset<T, StatusChangeUpdateArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more StatusChanges.
     * @param {StatusChangeDeleteManyArgs} args - Arguments to filter StatusChanges to delete.
     * @example
     * // Delete a few StatusChanges
     * const { count } = await prisma.statusChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StatusChangeDeleteManyArgs>(
      args?: SelectSubset<T, StatusChangeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more StatusChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusChanges
     * const statusChange = await prisma.statusChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StatusChangeUpdateManyArgs>(
      args: SelectSubset<T, StatusChangeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more StatusChanges and returns the data updated in the database.
     * @param {StatusChangeUpdateManyAndReturnArgs} args - Arguments to update many StatusChanges.
     * @example
     * // Update many StatusChanges
     * const statusChange = await prisma.statusChange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more StatusChanges and only return the `id`
     * const statusChangeWithIdOnly = await prisma.statusChange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends StatusChangeUpdateManyAndReturnArgs>(
      args: SelectSubset<T, StatusChangeUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one StatusChange.
     * @param {StatusChangeUpsertArgs} args - Arguments to update or create a StatusChange.
     * @example
     * // Update or create a StatusChange
     * const statusChange = await prisma.statusChange.upsert({
     *   create: {
     *     // ... data to create a StatusChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusChange we want to update
     *   }
     * })
     */
    upsert<T extends StatusChangeUpsertArgs>(
      args: SelectSubset<T, StatusChangeUpsertArgs<ExtArgs>>
    ): Prisma__StatusChangeClient<
      $Result.GetResult<
        Prisma.$StatusChangePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of StatusChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeCountArgs} args - Arguments to filter StatusChanges to count.
     * @example
     * // Count the number of StatusChanges
     * const count = await prisma.statusChange.count({
     *   where: {
     *     // ... the filter for the StatusChanges we want to count
     *   }
     * })
     **/
    count<T extends StatusChangeCountArgs>(
      args?: Subset<T, StatusChangeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], StatusChangeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a StatusChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StatusChangeAggregateArgs>(
      args: Subset<T, StatusChangeAggregateArgs>
    ): Prisma.PrismaPromise<GetStatusChangeAggregateType<T>>;

    /**
     * Group by StatusChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StatusChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusChangeGroupByArgs["orderBy"] }
        : { orderBy?: StatusChangeGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, StatusChangeGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetStatusChangeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the StatusChange model
     */
    readonly fields: StatusChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusChangeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends StatusChange$userArgs<ExtArgs> = {}>(
      args?: Subset<T, StatusChange$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    reservation<T extends ReservationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ReservationDefaultArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      | $Result.GetResult<
          Prisma.$ReservationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the StatusChange model
   */
  interface StatusChangeFieldRefs {
    readonly id: FieldRef<"StatusChange", "String">;
    readonly reservationId: FieldRef<"StatusChange", "String">;
    readonly fromStatus: FieldRef<"StatusChange", "ReservationStatus">;
    readonly toStatus: FieldRef<"StatusChange", "ReservationStatus">;
    readonly reason: FieldRef<"StatusChange", "String">;
    readonly changedBy: FieldRef<"StatusChange", "String">;
    readonly changeAt: FieldRef<"StatusChange", "DateTime">;
  }

  // Custom InputTypes
  /**
   * StatusChange findUnique
   */
  export type StatusChangeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * Filter, which StatusChange to fetch.
     */
    where: StatusChangeWhereUniqueInput;
  };

  /**
   * StatusChange findUniqueOrThrow
   */
  export type StatusChangeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * Filter, which StatusChange to fetch.
     */
    where: StatusChangeWhereUniqueInput;
  };

  /**
   * StatusChange findFirst
   */
  export type StatusChangeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * Filter, which StatusChange to fetch.
     */
    where?: StatusChangeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?:
      | StatusChangeOrderByWithRelationInput
      | StatusChangeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StatusChanges.
     */
    cursor?: StatusChangeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StatusChanges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StatusChanges.
     */
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[];
  };

  /**
   * StatusChange findFirstOrThrow
   */
  export type StatusChangeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * Filter, which StatusChange to fetch.
     */
    where?: StatusChangeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?:
      | StatusChangeOrderByWithRelationInput
      | StatusChangeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StatusChanges.
     */
    cursor?: StatusChangeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StatusChanges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StatusChanges.
     */
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[];
  };

  /**
   * StatusChange findMany
   */
  export type StatusChangeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * Filter, which StatusChanges to fetch.
     */
    where?: StatusChangeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StatusChanges to fetch.
     */
    orderBy?:
      | StatusChangeOrderByWithRelationInput
      | StatusChangeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing StatusChanges.
     */
    cursor?: StatusChangeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StatusChanges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StatusChanges.
     */
    skip?: number;
    distinct?: StatusChangeScalarFieldEnum | StatusChangeScalarFieldEnum[];
  };

  /**
   * StatusChange create
   */
  export type StatusChangeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * The data needed to create a StatusChange.
     */
    data: XOR<StatusChangeCreateInput, StatusChangeUncheckedCreateInput>;
  };

  /**
   * StatusChange createMany
   */
  export type StatusChangeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many StatusChanges.
     */
    data: StatusChangeCreateManyInput | StatusChangeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * StatusChange createManyAndReturn
   */
  export type StatusChangeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * The data used to create many StatusChanges.
     */
    data: StatusChangeCreateManyInput | StatusChangeCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * StatusChange update
   */
  export type StatusChangeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * The data needed to update a StatusChange.
     */
    data: XOR<StatusChangeUpdateInput, StatusChangeUncheckedUpdateInput>;
    /**
     * Choose, which StatusChange to update.
     */
    where: StatusChangeWhereUniqueInput;
  };

  /**
   * StatusChange updateMany
   */
  export type StatusChangeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update StatusChanges.
     */
    data: XOR<
      StatusChangeUpdateManyMutationInput,
      StatusChangeUncheckedUpdateManyInput
    >;
    /**
     * Filter which StatusChanges to update
     */
    where?: StatusChangeWhereInput;
    /**
     * Limit how many StatusChanges to update.
     */
    limit?: number;
  };

  /**
   * StatusChange updateManyAndReturn
   */
  export type StatusChangeUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * The data used to update StatusChanges.
     */
    data: XOR<
      StatusChangeUpdateManyMutationInput,
      StatusChangeUncheckedUpdateManyInput
    >;
    /**
     * Filter which StatusChanges to update
     */
    where?: StatusChangeWhereInput;
    /**
     * Limit how many StatusChanges to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * StatusChange upsert
   */
  export type StatusChangeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * The filter to search for the StatusChange to update in case it exists.
     */
    where: StatusChangeWhereUniqueInput;
    /**
     * In case the StatusChange found by the `where` argument doesn't exist, create a new StatusChange with this data.
     */
    create: XOR<StatusChangeCreateInput, StatusChangeUncheckedCreateInput>;
    /**
     * In case the StatusChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusChangeUpdateInput, StatusChangeUncheckedUpdateInput>;
  };

  /**
   * StatusChange delete
   */
  export type StatusChangeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
    /**
     * Filter which StatusChange to delete.
     */
    where: StatusChangeWhereUniqueInput;
  };

  /**
   * StatusChange deleteMany
   */
  export type StatusChangeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StatusChanges to delete
     */
    where?: StatusChangeWhereInput;
    /**
     * Limit how many StatusChanges to delete.
     */
    limit?: number;
  };

  /**
   * StatusChange.user
   */
  export type StatusChange$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * StatusChange without action
   */
  export type StatusChangeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusChange
     */
    select?: StatusChangeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the StatusChange
     */
    omit?: StatusChangeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusChangeInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    expires: Date | null;
    sessionToken: string | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    expires: Date | null;
    sessionToken: string | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    userId: number;
    expires: number;
    sessionToken: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    userId?: true;
    expires?: true;
    sessionToken?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    userId?: true;
    expires?: true;
    sessionToken?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    userId?: true;
    expires?: true;
    sessionToken?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithAggregationInput
      | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    userId: string;
    expires: Date;
    sessionToken: string;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SessionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SessionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>;
        }
      >
    >;

  export type SessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expires?: boolean;
      sessionToken?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expires?: boolean;
      sessionToken?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      expires?: boolean;
      sessionToken?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    userId?: boolean;
    expires?: boolean;
    sessionToken?: boolean;
  };

  export type SessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "expires" | "sessionToken",
    ExtArgs["result"]["session"]
  >;
  export type SessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Session";
    objects: {
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        expires: Date;
        sessionToken: string;
      },
      ExtArgs["result"]["session"]
    >;
    composites: {};
  };

  type SessionGetPayload<
    S extends boolean | null | undefined | SessionDefaultArgs,
  > = $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SessionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Session"];
      meta: { name: "Session" };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs["orderBy"] }
        : { orderBy?: SessionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", "String">;
    readonly userId: FieldRef<"Session", "String">;
    readonly expires: FieldRef<"Session", "DateTime">;
    readonly sessionToken: FieldRef<"Session", "String">;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number;
    token: number;
    expires: number;
    _all: number;
  };

  export type VerificationTokenMinAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
    _all?: true;
  };

  export type VerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerificationTokens
     **/
    _count?: true | VerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type GetVerificationTokenAggregateType<
    T extends VerificationTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateVerificationToken]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>;
  };

  export type VerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationTokenWhereInput;
    orderBy?:
      | VerificationTokenOrderByWithAggregationInput
      | VerificationTokenOrderByWithAggregationInput[];
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum;
    having?: VerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationTokenCountAggregateInputType | true;
    _min?: VerificationTokenMinAggregateInputType;
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type VerificationTokenGroupByOutputType = {
    identifier: string;
    token: string;
    expires: Date;
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  type GetVerificationTokenGroupByPayload<
    T extends VerificationTokenGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof VerificationTokenGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
          : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>;
      }
    >
  >;

  export type VerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectScalar = {
    identifier?: boolean;
    token?: boolean;
    expires?: boolean;
  };

  export type VerificationTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "identifier" | "token" | "expires",
    ExtArgs["result"]["verificationToken"]
  >;

  export type $VerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "VerificationToken";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        identifier: string;
        token: string;
        expires: Date;
      },
      ExtArgs["result"]["verificationToken"]
    >;
    composites: {};
  };

  type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationTokenPayload, S>;

  type VerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    VerificationTokenFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: VerificationTokenCountAggregateInputType | true;
  };

  export interface VerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["VerificationToken"];
      meta: { name: "VerificationToken" };
    };
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     *
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     *
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     *
     */
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     *
     */
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     *
     */
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              VerificationTokenCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationTokenAggregateArgs>(
      args: Subset<T, VerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>;

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs["orderBy"] }
        : { orderBy?: VerificationTokenGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerificationToken model
     */
    readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", "String">;
    readonly token: FieldRef<"VerificationToken", "String">;
    readonly expires: FieldRef<"VerificationToken", "DateTime">;
  }

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<
      VerificationTokenCreateInput,
      VerificationTokenUncheckedCreateInput
    >;
  };

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<
      VerificationTokenUpdateInput,
      VerificationTokenUncheckedUpdateInput
    >;
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<
      VerificationTokenUpdateManyMutationInput,
      VerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<
      VerificationTokenUpdateManyMutationInput,
      VerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput;
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<
      VerificationTokenCreateInput,
      VerificationTokenUncheckedCreateInput
    >;
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      VerificationTokenUpdateInput,
      VerificationTokenUncheckedUpdateInput
    >;
  };

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number;
  };

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
  };

  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null;
    _avg: VehicleAvgAggregateOutputType | null;
    _sum: VehicleSumAggregateOutputType | null;
    _min: VehicleMinAggregateOutputType | null;
    _max: VehicleMaxAggregateOutputType | null;
  };

  export type VehicleAvgAggregateOutputType = {
    id: number | null;
    year: number | null;
    dailyRate: number | null;
  };

  export type VehicleSumAggregateOutputType = {
    id: number | null;
    year: number | null;
    dailyRate: number | null;
  };

  export type VehicleMinAggregateOutputType = {
    id: number | null;
    make: string | null;
    model: string | null;
    category: $Enums.VehicleCategory | null;
    year: number | null;
    color: string | null;
    transmission: $Enums.VehicleTransmission | null;
    fuel_type: $Enums.VehicleFuelType | null;
    licensePlate: string | null;
    status: $Enums.VehicleStatus | null;
    dailyRate: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VehicleMaxAggregateOutputType = {
    id: number | null;
    make: string | null;
    model: string | null;
    category: $Enums.VehicleCategory | null;
    year: number | null;
    color: string | null;
    transmission: $Enums.VehicleTransmission | null;
    fuel_type: $Enums.VehicleFuelType | null;
    licensePlate: string | null;
    status: $Enums.VehicleStatus | null;
    dailyRate: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VehicleCountAggregateOutputType = {
    id: number;
    make: number;
    model: number;
    category: number;
    year: number;
    color: number;
    transmission: number;
    fuel_type: number;
    licensePlate: number;
    status: number;
    features: number;
    dailyRate: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type VehicleAvgAggregateInputType = {
    id?: true;
    year?: true;
    dailyRate?: true;
  };

  export type VehicleSumAggregateInputType = {
    id?: true;
    year?: true;
    dailyRate?: true;
  };

  export type VehicleMinAggregateInputType = {
    id?: true;
    make?: true;
    model?: true;
    category?: true;
    year?: true;
    color?: true;
    transmission?: true;
    fuel_type?: true;
    licensePlate?: true;
    status?: true;
    dailyRate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VehicleMaxAggregateInputType = {
    id?: true;
    make?: true;
    model?: true;
    category?: true;
    year?: true;
    color?: true;
    transmission?: true;
    fuel_type?: true;
    licensePlate?: true;
    status?: true;
    dailyRate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VehicleCountAggregateInputType = {
    id?: true;
    make?: true;
    model?: true;
    category?: true;
    year?: true;
    color?: true;
    transmission?: true;
    fuel_type?: true;
    licensePlate?: true;
    status?: true;
    features?: true;
    dailyRate?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type VehicleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Vehicles to fetch.
     */
    orderBy?:
      | VehicleOrderByWithRelationInput
      | VehicleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Vehicles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Vehicles
     **/
    _count?: true | VehicleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: VehicleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: VehicleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VehicleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VehicleMaxAggregateInputType;
  };

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
    [P in keyof T & keyof AggregateVehicle]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>;
  };

  export type VehicleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VehicleWhereInput;
    orderBy?:
      | VehicleOrderByWithAggregationInput
      | VehicleOrderByWithAggregationInput[];
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum;
    having?: VehicleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VehicleCountAggregateInputType | true;
    _avg?: VehicleAvgAggregateInputType;
    _sum?: VehicleSumAggregateInputType;
    _min?: VehicleMinAggregateInputType;
    _max?: VehicleMaxAggregateInputType;
  };

  export type VehicleGroupByOutputType = {
    id: number;
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type: $Enums.VehicleFuelType;
    licensePlate: string;
    status: $Enums.VehicleStatus;
    features: string[];
    dailyRate: number;
    createdAt: Date;
    updatedAt: Date;
    _count: VehicleCountAggregateOutputType | null;
    _avg: VehicleAvgAggregateOutputType | null;
    _sum: VehicleSumAggregateOutputType | null;
    _min: VehicleMinAggregateOutputType | null;
    _max: VehicleMaxAggregateOutputType | null;
  };

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VehicleGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof VehicleGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>;
        }
      >
    >;

  export type VehicleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      make?: boolean;
      model?: boolean;
      category?: boolean;
      year?: boolean;
      color?: boolean;
      transmission?: boolean;
      fuel_type?: boolean;
      licensePlate?: boolean;
      status?: boolean;
      features?: boolean;
      dailyRate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      images?: boolean | Vehicle$imagesArgs<ExtArgs>;
      maintenanceBlocks?: boolean | Vehicle$maintenanceBlocksArgs<ExtArgs>;
      reservations?: boolean | Vehicle$reservationsArgs<ExtArgs>;
      _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["vehicle"]
  >;

  export type VehicleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      make?: boolean;
      model?: boolean;
      category?: boolean;
      year?: boolean;
      color?: boolean;
      transmission?: boolean;
      fuel_type?: boolean;
      licensePlate?: boolean;
      status?: boolean;
      features?: boolean;
      dailyRate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["vehicle"]
  >;

  export type VehicleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      make?: boolean;
      model?: boolean;
      category?: boolean;
      year?: boolean;
      color?: boolean;
      transmission?: boolean;
      fuel_type?: boolean;
      licensePlate?: boolean;
      status?: boolean;
      features?: boolean;
      dailyRate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["vehicle"]
  >;

  export type VehicleSelectScalar = {
    id?: boolean;
    make?: boolean;
    model?: boolean;
    category?: boolean;
    year?: boolean;
    color?: boolean;
    transmission?: boolean;
    fuel_type?: boolean;
    licensePlate?: boolean;
    status?: boolean;
    features?: boolean;
    dailyRate?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type VehicleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "make"
    | "model"
    | "category"
    | "year"
    | "color"
    | "transmission"
    | "fuel_type"
    | "licensePlate"
    | "status"
    | "features"
    | "dailyRate"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["vehicle"]
  >;
  export type VehicleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    images?: boolean | Vehicle$imagesArgs<ExtArgs>;
    maintenanceBlocks?: boolean | Vehicle$maintenanceBlocksArgs<ExtArgs>;
    reservations?: boolean | Vehicle$reservationsArgs<ExtArgs>;
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type VehicleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type VehicleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $VehiclePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Vehicle";
    objects: {
      images: Prisma.$ImagePayload<ExtArgs>[];
      maintenanceBlocks: Prisma.$MaintenanceBlockPayload<ExtArgs>[];
      reservations: Prisma.$ReservationPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: number;
        make: string;
        model: string;
        category: $Enums.VehicleCategory;
        year: number;
        color: string;
        transmission: $Enums.VehicleTransmission;
        fuel_type: $Enums.VehicleFuelType;
        licensePlate: string;
        status: $Enums.VehicleStatus;
        features: string[];
        dailyRate: number;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["vehicle"]
    >;
    composites: {};
  };

  type VehicleGetPayload<
    S extends boolean | null | undefined | VehicleDefaultArgs,
  > = $Result.GetResult<Prisma.$VehiclePayload, S>;

  type VehicleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<VehicleFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: VehicleCountAggregateInputType | true;
  };

  export interface VehicleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Vehicle"];
      meta: { name: "Vehicle" };
    };
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(
      args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(
      args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     *
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     *
     */
    findMany<T extends VehicleFindManyArgs>(
      args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     *
     */
    create<T extends VehicleCreateArgs>(
      args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VehicleCreateManyArgs>(
      args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     *
     */
    delete<T extends VehicleDeleteArgs>(
      args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VehicleUpdateArgs>(
      args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VehicleDeleteManyArgs>(
      args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VehicleUpdateManyArgs>(
      args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(
      args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
     **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], VehicleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VehicleAggregateArgs>(
      args: Subset<T, VehicleAggregateArgs>
    ): Prisma.PrismaPromise<GetVehicleAggregateType<T>>;

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs["orderBy"] }
        : { orderBy?: VehicleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetVehicleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Vehicle model
     */
    readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    images<T extends Vehicle$imagesArgs<ExtArgs> = {}>(
      args?: Subset<T, Vehicle$imagesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ImagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    maintenanceBlocks<T extends Vehicle$maintenanceBlocksArgs<ExtArgs> = {}>(
      args?: Subset<T, Vehicle$maintenanceBlocksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MaintenanceBlockPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    reservations<T extends Vehicle$reservationsArgs<ExtArgs> = {}>(
      args?: Subset<T, Vehicle$reservationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReservationPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", "Int">;
    readonly make: FieldRef<"Vehicle", "String">;
    readonly model: FieldRef<"Vehicle", "String">;
    readonly category: FieldRef<"Vehicle", "VehicleCategory">;
    readonly year: FieldRef<"Vehicle", "Int">;
    readonly color: FieldRef<"Vehicle", "String">;
    readonly transmission: FieldRef<"Vehicle", "VehicleTransmission">;
    readonly fuel_type: FieldRef<"Vehicle", "VehicleFuelType">;
    readonly licensePlate: FieldRef<"Vehicle", "String">;
    readonly status: FieldRef<"Vehicle", "VehicleStatus">;
    readonly features: FieldRef<"Vehicle", "String[]">;
    readonly dailyRate: FieldRef<"Vehicle", "Float">;
    readonly createdAt: FieldRef<"Vehicle", "DateTime">;
    readonly updatedAt: FieldRef<"Vehicle", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput;
  };

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput;
  };

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Vehicles to fetch.
     */
    orderBy?:
      | VehicleOrderByWithRelationInput
      | VehicleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Vehicles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[];
  };

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Vehicles to fetch.
     */
    orderBy?:
      | VehicleOrderByWithRelationInput
      | VehicleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Vehicles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[];
  };

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Vehicles to fetch.
     */
    orderBy?:
      | VehicleOrderByWithRelationInput
      | VehicleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Vehicles.
     */
    skip?: number;
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[];
  };

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>;
  };

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>;
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput;
  };

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>;
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput;
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number;
  };

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>;
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput;
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number;
  };

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput;
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>;
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>;
  };

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput;
  };

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput;
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number;
  };

  /**
   * Vehicle.images
   */
  export type Vehicle$imagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    where?: ImageWhereInput;
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[];
    cursor?: ImageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * Vehicle.maintenanceBlocks
   */
  export type Vehicle$maintenanceBlocksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    where?: MaintenanceBlockWhereInput;
    orderBy?:
      | MaintenanceBlockOrderByWithRelationInput
      | MaintenanceBlockOrderByWithRelationInput[];
    cursor?: MaintenanceBlockWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | MaintenanceBlockScalarFieldEnum
      | MaintenanceBlockScalarFieldEnum[];
  };

  /**
   * Vehicle.reservations
   */
  export type Vehicle$reservationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    where?: ReservationWhereInput;
    orderBy?:
      | ReservationOrderByWithRelationInput
      | ReservationOrderByWithRelationInput[];
    cursor?: ReservationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[];
  };

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
  };

  /**
   * Model MaintenanceBlock
   */

  export type AggregateMaintenanceBlock = {
    _count: MaintenanceBlockCountAggregateOutputType | null;
    _avg: MaintenanceBlockAvgAggregateOutputType | null;
    _sum: MaintenanceBlockSumAggregateOutputType | null;
    _min: MaintenanceBlockMinAggregateOutputType | null;
    _max: MaintenanceBlockMaxAggregateOutputType | null;
  };

  export type MaintenanceBlockAvgAggregateOutputType = {
    vehicleId: number | null;
  };

  export type MaintenanceBlockSumAggregateOutputType = {
    vehicleId: number | null;
  };

  export type MaintenanceBlockMinAggregateOutputType = {
    id: string | null;
    vehicleId: number | null;
    reason: string | null;
    startDate: Date | null;
    endDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MaintenanceBlockMaxAggregateOutputType = {
    id: string | null;
    vehicleId: number | null;
    reason: string | null;
    startDate: Date | null;
    endDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MaintenanceBlockCountAggregateOutputType = {
    id: number;
    vehicleId: number;
    reason: number;
    startDate: number;
    endDate: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type MaintenanceBlockAvgAggregateInputType = {
    vehicleId?: true;
  };

  export type MaintenanceBlockSumAggregateInputType = {
    vehicleId?: true;
  };

  export type MaintenanceBlockMinAggregateInputType = {
    id?: true;
    vehicleId?: true;
    reason?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MaintenanceBlockMaxAggregateInputType = {
    id?: true;
    vehicleId?: true;
    reason?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MaintenanceBlockCountAggregateInputType = {
    id?: true;
    vehicleId?: true;
    reason?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MaintenanceBlockAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MaintenanceBlock to aggregate.
     */
    where?: MaintenanceBlockWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MaintenanceBlocks to fetch.
     */
    orderBy?:
      | MaintenanceBlockOrderByWithRelationInput
      | MaintenanceBlockOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MaintenanceBlockWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MaintenanceBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MaintenanceBlocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MaintenanceBlocks
     **/
    _count?: true | MaintenanceBlockCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MaintenanceBlockAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MaintenanceBlockSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MaintenanceBlockMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MaintenanceBlockMaxAggregateInputType;
  };

  export type GetMaintenanceBlockAggregateType<
    T extends MaintenanceBlockAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateMaintenanceBlock]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceBlock[P]>
      : GetScalarType<T[P], AggregateMaintenanceBlock[P]>;
  };

  export type MaintenanceBlockGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MaintenanceBlockWhereInput;
    orderBy?:
      | MaintenanceBlockOrderByWithAggregationInput
      | MaintenanceBlockOrderByWithAggregationInput[];
    by: MaintenanceBlockScalarFieldEnum[] | MaintenanceBlockScalarFieldEnum;
    having?: MaintenanceBlockScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MaintenanceBlockCountAggregateInputType | true;
    _avg?: MaintenanceBlockAvgAggregateInputType;
    _sum?: MaintenanceBlockSumAggregateInputType;
    _min?: MaintenanceBlockMinAggregateInputType;
    _max?: MaintenanceBlockMaxAggregateInputType;
  };

  export type MaintenanceBlockGroupByOutputType = {
    id: string;
    vehicleId: number;
    reason: string;
    startDate: Date;
    endDate: Date;
    createdAt: Date;
    updatedAt: Date;
    _count: MaintenanceBlockCountAggregateOutputType | null;
    _avg: MaintenanceBlockAvgAggregateOutputType | null;
    _sum: MaintenanceBlockSumAggregateOutputType | null;
    _min: MaintenanceBlockMinAggregateOutputType | null;
    _max: MaintenanceBlockMaxAggregateOutputType | null;
  };

  type GetMaintenanceBlockGroupByPayload<
    T extends MaintenanceBlockGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceBlockGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof MaintenanceBlockGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], MaintenanceBlockGroupByOutputType[P]>
          : GetScalarType<T[P], MaintenanceBlockGroupByOutputType[P]>;
      }
    >
  >;

  export type MaintenanceBlockSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      vehicleId?: boolean;
      reason?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      vehicle?: boolean | VehicleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["maintenanceBlock"]
  >;

  export type MaintenanceBlockSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      vehicleId?: boolean;
      reason?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      vehicle?: boolean | VehicleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["maintenanceBlock"]
  >;

  export type MaintenanceBlockSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      vehicleId?: boolean;
      reason?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      vehicle?: boolean | VehicleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["maintenanceBlock"]
  >;

  export type MaintenanceBlockSelectScalar = {
    id?: boolean;
    vehicleId?: boolean;
    reason?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type MaintenanceBlockOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "vehicleId"
    | "reason"
    | "startDate"
    | "endDate"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["maintenanceBlock"]
  >;
  export type MaintenanceBlockInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>;
  };
  export type MaintenanceBlockIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>;
  };
  export type MaintenanceBlockIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>;
  };

  export type $MaintenanceBlockPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "MaintenanceBlock";
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        vehicleId: number;
        reason: string;
        startDate: Date;
        endDate: Date;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["maintenanceBlock"]
    >;
    composites: {};
  };

  type MaintenanceBlockGetPayload<
    S extends boolean | null | undefined | MaintenanceBlockDefaultArgs,
  > = $Result.GetResult<Prisma.$MaintenanceBlockPayload, S>;

  type MaintenanceBlockCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    MaintenanceBlockFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: MaintenanceBlockCountAggregateInputType | true;
  };

  export interface MaintenanceBlockDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["MaintenanceBlock"];
      meta: { name: "MaintenanceBlock" };
    };
    /**
     * Find zero or one MaintenanceBlock that matches the filter.
     * @param {MaintenanceBlockFindUniqueArgs} args - Arguments to find a MaintenanceBlock
     * @example
     * // Get one MaintenanceBlock
     * const maintenanceBlock = await prisma.maintenanceBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceBlockFindUniqueArgs>(
      args: SelectSubset<T, MaintenanceBlockFindUniqueArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one MaintenanceBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceBlockFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceBlock
     * @example
     * // Get one MaintenanceBlock
     * const maintenanceBlock = await prisma.maintenanceBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceBlockFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MaintenanceBlockFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MaintenanceBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceBlockFindFirstArgs} args - Arguments to find a MaintenanceBlock
     * @example
     * // Get one MaintenanceBlock
     * const maintenanceBlock = await prisma.maintenanceBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceBlockFindFirstArgs>(
      args?: SelectSubset<T, MaintenanceBlockFindFirstArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MaintenanceBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceBlockFindFirstOrThrowArgs} args - Arguments to find a MaintenanceBlock
     * @example
     * // Get one MaintenanceBlock
     * const maintenanceBlock = await prisma.maintenanceBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceBlockFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MaintenanceBlockFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more MaintenanceBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceBlocks
     * const maintenanceBlocks = await prisma.maintenanceBlock.findMany()
     *
     * // Get first 10 MaintenanceBlocks
     * const maintenanceBlocks = await prisma.maintenanceBlock.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const maintenanceBlockWithIdOnly = await prisma.maintenanceBlock.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MaintenanceBlockFindManyArgs>(
      args?: SelectSubset<T, MaintenanceBlockFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a MaintenanceBlock.
     * @param {MaintenanceBlockCreateArgs} args - Arguments to create a MaintenanceBlock.
     * @example
     * // Create one MaintenanceBlock
     * const MaintenanceBlock = await prisma.maintenanceBlock.create({
     *   data: {
     *     // ... data to create a MaintenanceBlock
     *   }
     * })
     *
     */
    create<T extends MaintenanceBlockCreateArgs>(
      args: SelectSubset<T, MaintenanceBlockCreateArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many MaintenanceBlocks.
     * @param {MaintenanceBlockCreateManyArgs} args - Arguments to create many MaintenanceBlocks.
     * @example
     * // Create many MaintenanceBlocks
     * const maintenanceBlock = await prisma.maintenanceBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MaintenanceBlockCreateManyArgs>(
      args?: SelectSubset<T, MaintenanceBlockCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MaintenanceBlocks and returns the data saved in the database.
     * @param {MaintenanceBlockCreateManyAndReturnArgs} args - Arguments to create many MaintenanceBlocks.
     * @example
     * // Create many MaintenanceBlocks
     * const maintenanceBlock = await prisma.maintenanceBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MaintenanceBlocks and only return the `id`
     * const maintenanceBlockWithIdOnly = await prisma.maintenanceBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MaintenanceBlockCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MaintenanceBlockCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a MaintenanceBlock.
     * @param {MaintenanceBlockDeleteArgs} args - Arguments to delete one MaintenanceBlock.
     * @example
     * // Delete one MaintenanceBlock
     * const MaintenanceBlock = await prisma.maintenanceBlock.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceBlock
     *   }
     * })
     *
     */
    delete<T extends MaintenanceBlockDeleteArgs>(
      args: SelectSubset<T, MaintenanceBlockDeleteArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one MaintenanceBlock.
     * @param {MaintenanceBlockUpdateArgs} args - Arguments to update one MaintenanceBlock.
     * @example
     * // Update one MaintenanceBlock
     * const maintenanceBlock = await prisma.maintenanceBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MaintenanceBlockUpdateArgs>(
      args: SelectSubset<T, MaintenanceBlockUpdateArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more MaintenanceBlocks.
     * @param {MaintenanceBlockDeleteManyArgs} args - Arguments to filter MaintenanceBlocks to delete.
     * @example
     * // Delete a few MaintenanceBlocks
     * const { count } = await prisma.maintenanceBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MaintenanceBlockDeleteManyArgs>(
      args?: SelectSubset<T, MaintenanceBlockDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MaintenanceBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceBlocks
     * const maintenanceBlock = await prisma.maintenanceBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MaintenanceBlockUpdateManyArgs>(
      args: SelectSubset<T, MaintenanceBlockUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MaintenanceBlocks and returns the data updated in the database.
     * @param {MaintenanceBlockUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceBlocks.
     * @example
     * // Update many MaintenanceBlocks
     * const maintenanceBlock = await prisma.maintenanceBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more MaintenanceBlocks and only return the `id`
     * const maintenanceBlockWithIdOnly = await prisma.maintenanceBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MaintenanceBlockUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MaintenanceBlockUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one MaintenanceBlock.
     * @param {MaintenanceBlockUpsertArgs} args - Arguments to update or create a MaintenanceBlock.
     * @example
     * // Update or create a MaintenanceBlock
     * const maintenanceBlock = await prisma.maintenanceBlock.upsert({
     *   create: {
     *     // ... data to create a MaintenanceBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceBlock we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceBlockUpsertArgs>(
      args: SelectSubset<T, MaintenanceBlockUpsertArgs<ExtArgs>>
    ): Prisma__MaintenanceBlockClient<
      $Result.GetResult<
        Prisma.$MaintenanceBlockPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of MaintenanceBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceBlockCountArgs} args - Arguments to filter MaintenanceBlocks to count.
     * @example
     * // Count the number of MaintenanceBlocks
     * const count = await prisma.maintenanceBlock.count({
     *   where: {
     *     // ... the filter for the MaintenanceBlocks we want to count
     *   }
     * })
     **/
    count<T extends MaintenanceBlockCountArgs>(
      args?: Subset<T, MaintenanceBlockCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], MaintenanceBlockCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MaintenanceBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MaintenanceBlockAggregateArgs>(
      args: Subset<T, MaintenanceBlockAggregateArgs>
    ): Prisma.PrismaPromise<GetMaintenanceBlockAggregateType<T>>;

    /**
     * Group by MaintenanceBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MaintenanceBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceBlockGroupByArgs["orderBy"] }
        : { orderBy?: MaintenanceBlockGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MaintenanceBlockGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetMaintenanceBlockGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MaintenanceBlock model
     */
    readonly fields: MaintenanceBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceBlockClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, VehicleDefaultArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      | $Result.GetResult<
          Prisma.$VehiclePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MaintenanceBlock model
   */
  interface MaintenanceBlockFieldRefs {
    readonly id: FieldRef<"MaintenanceBlock", "String">;
    readonly vehicleId: FieldRef<"MaintenanceBlock", "Int">;
    readonly reason: FieldRef<"MaintenanceBlock", "String">;
    readonly startDate: FieldRef<"MaintenanceBlock", "DateTime">;
    readonly endDate: FieldRef<"MaintenanceBlock", "DateTime">;
    readonly createdAt: FieldRef<"MaintenanceBlock", "DateTime">;
    readonly updatedAt: FieldRef<"MaintenanceBlock", "DateTime">;
  }

  // Custom InputTypes
  /**
   * MaintenanceBlock findUnique
   */
  export type MaintenanceBlockFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * Filter, which MaintenanceBlock to fetch.
     */
    where: MaintenanceBlockWhereUniqueInput;
  };

  /**
   * MaintenanceBlock findUniqueOrThrow
   */
  export type MaintenanceBlockFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * Filter, which MaintenanceBlock to fetch.
     */
    where: MaintenanceBlockWhereUniqueInput;
  };

  /**
   * MaintenanceBlock findFirst
   */
  export type MaintenanceBlockFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * Filter, which MaintenanceBlock to fetch.
     */
    where?: MaintenanceBlockWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MaintenanceBlocks to fetch.
     */
    orderBy?:
      | MaintenanceBlockOrderByWithRelationInput
      | MaintenanceBlockOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MaintenanceBlocks.
     */
    cursor?: MaintenanceBlockWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MaintenanceBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MaintenanceBlocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MaintenanceBlocks.
     */
    distinct?:
      | MaintenanceBlockScalarFieldEnum
      | MaintenanceBlockScalarFieldEnum[];
  };

  /**
   * MaintenanceBlock findFirstOrThrow
   */
  export type MaintenanceBlockFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * Filter, which MaintenanceBlock to fetch.
     */
    where?: MaintenanceBlockWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MaintenanceBlocks to fetch.
     */
    orderBy?:
      | MaintenanceBlockOrderByWithRelationInput
      | MaintenanceBlockOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MaintenanceBlocks.
     */
    cursor?: MaintenanceBlockWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MaintenanceBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MaintenanceBlocks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MaintenanceBlocks.
     */
    distinct?:
      | MaintenanceBlockScalarFieldEnum
      | MaintenanceBlockScalarFieldEnum[];
  };

  /**
   * MaintenanceBlock findMany
   */
  export type MaintenanceBlockFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * Filter, which MaintenanceBlocks to fetch.
     */
    where?: MaintenanceBlockWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MaintenanceBlocks to fetch.
     */
    orderBy?:
      | MaintenanceBlockOrderByWithRelationInput
      | MaintenanceBlockOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MaintenanceBlocks.
     */
    cursor?: MaintenanceBlockWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MaintenanceBlocks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MaintenanceBlocks.
     */
    skip?: number;
    distinct?:
      | MaintenanceBlockScalarFieldEnum
      | MaintenanceBlockScalarFieldEnum[];
  };

  /**
   * MaintenanceBlock create
   */
  export type MaintenanceBlockCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * The data needed to create a MaintenanceBlock.
     */
    data: XOR<
      MaintenanceBlockCreateInput,
      MaintenanceBlockUncheckedCreateInput
    >;
  };

  /**
   * MaintenanceBlock createMany
   */
  export type MaintenanceBlockCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MaintenanceBlocks.
     */
    data: MaintenanceBlockCreateManyInput | MaintenanceBlockCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MaintenanceBlock createManyAndReturn
   */
  export type MaintenanceBlockCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * The data used to create many MaintenanceBlocks.
     */
    data: MaintenanceBlockCreateManyInput | MaintenanceBlockCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MaintenanceBlock update
   */
  export type MaintenanceBlockUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * The data needed to update a MaintenanceBlock.
     */
    data: XOR<
      MaintenanceBlockUpdateInput,
      MaintenanceBlockUncheckedUpdateInput
    >;
    /**
     * Choose, which MaintenanceBlock to update.
     */
    where: MaintenanceBlockWhereUniqueInput;
  };

  /**
   * MaintenanceBlock updateMany
   */
  export type MaintenanceBlockUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MaintenanceBlocks.
     */
    data: XOR<
      MaintenanceBlockUpdateManyMutationInput,
      MaintenanceBlockUncheckedUpdateManyInput
    >;
    /**
     * Filter which MaintenanceBlocks to update
     */
    where?: MaintenanceBlockWhereInput;
    /**
     * Limit how many MaintenanceBlocks to update.
     */
    limit?: number;
  };

  /**
   * MaintenanceBlock updateManyAndReturn
   */
  export type MaintenanceBlockUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * The data used to update MaintenanceBlocks.
     */
    data: XOR<
      MaintenanceBlockUpdateManyMutationInput,
      MaintenanceBlockUncheckedUpdateManyInput
    >;
    /**
     * Filter which MaintenanceBlocks to update
     */
    where?: MaintenanceBlockWhereInput;
    /**
     * Limit how many MaintenanceBlocks to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MaintenanceBlock upsert
   */
  export type MaintenanceBlockUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * The filter to search for the MaintenanceBlock to update in case it exists.
     */
    where: MaintenanceBlockWhereUniqueInput;
    /**
     * In case the MaintenanceBlock found by the `where` argument doesn't exist, create a new MaintenanceBlock with this data.
     */
    create: XOR<
      MaintenanceBlockCreateInput,
      MaintenanceBlockUncheckedCreateInput
    >;
    /**
     * In case the MaintenanceBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      MaintenanceBlockUpdateInput,
      MaintenanceBlockUncheckedUpdateInput
    >;
  };

  /**
   * MaintenanceBlock delete
   */
  export type MaintenanceBlockDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
    /**
     * Filter which MaintenanceBlock to delete.
     */
    where: MaintenanceBlockWhereUniqueInput;
  };

  /**
   * MaintenanceBlock deleteMany
   */
  export type MaintenanceBlockDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MaintenanceBlocks to delete
     */
    where?: MaintenanceBlockWhereInput;
    /**
     * Limit how many MaintenanceBlocks to delete.
     */
    limit?: number;
  };

  /**
   * MaintenanceBlock without action
   */
  export type MaintenanceBlockDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MaintenanceBlock
     */
    select?: MaintenanceBlockSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MaintenanceBlock
     */
    omit?: MaintenanceBlockOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceBlockInclude<ExtArgs> | null;
  };

  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null;
  };

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null;
  };

  export type PaymentMinAggregateOutputType = {
    id: string | null;
    stripeSession: string | null;
    amount: Decimal | null;
    status: $Enums.PaymentStatus | null;
    intent_id: string | null;
    reservationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentMaxAggregateOutputType = {
    id: string | null;
    stripeSession: string | null;
    amount: Decimal | null;
    status: $Enums.PaymentStatus | null;
    intent_id: string | null;
    reservationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentCountAggregateOutputType = {
    id: number;
    stripeSession: number;
    amount: number;
    status: number;
    intent_id: number;
    reservationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PaymentAvgAggregateInputType = {
    amount?: true;
  };

  export type PaymentSumAggregateInputType = {
    amount?: true;
  };

  export type PaymentMinAggregateInputType = {
    id?: true;
    stripeSession?: true;
    amount?: true;
    status?: true;
    intent_id?: true;
    reservationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentMaxAggregateInputType = {
    id?: true;
    stripeSession?: true;
    amount?: true;
    status?: true;
    intent_id?: true;
    reservationId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentCountAggregateInputType = {
    id?: true;
    stripeSession?: true;
    amount?: true;
    status?: true;
    intent_id?: true;
    reservationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Payments
     **/
    _count?: true | PaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaymentMaxAggregateInputType;
  };

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>;
  };

  export type PaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaymentWhereInput;
    orderBy?:
      | PaymentOrderByWithAggregationInput
      | PaymentOrderByWithAggregationInput[];
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum;
    having?: PaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentCountAggregateInputType | true;
    _avg?: PaymentAvgAggregateInputType;
    _sum?: PaymentSumAggregateInputType;
    _min?: PaymentMinAggregateInputType;
    _max?: PaymentMaxAggregateInputType;
  };

  export type PaymentGroupByOutputType = {
    id: string;
    stripeSession: string;
    amount: Decimal;
    status: $Enums.PaymentStatus;
    intent_id: string | null;
    reservationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PaymentGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof PaymentGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>;
        }
      >
    >;

  export type PaymentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      stripeSession?: boolean;
      amount?: boolean;
      status?: boolean;
      intent_id?: boolean;
      reservationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["payment"]
  >;

  export type PaymentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      stripeSession?: boolean;
      amount?: boolean;
      status?: boolean;
      intent_id?: boolean;
      reservationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["payment"]
  >;

  export type PaymentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      stripeSession?: boolean;
      amount?: boolean;
      status?: boolean;
      intent_id?: boolean;
      reservationId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["payment"]
  >;

  export type PaymentSelectScalar = {
    id?: boolean;
    stripeSession?: boolean;
    amount?: boolean;
    status?: boolean;
    intent_id?: boolean;
    reservationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PaymentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "stripeSession"
    | "amount"
    | "status"
    | "intent_id"
    | "reservationId"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["payment"]
  >;
  export type PaymentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
  };
  export type PaymentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
  };
  export type PaymentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>;
  };

  export type $PaymentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Payment";
    objects: {
      reservation: Prisma.$ReservationPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        stripeSession: string;
        amount: Prisma.Decimal;
        status: $Enums.PaymentStatus;
        intent_id: string | null;
        reservationId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["payment"]
    >;
    composites: {};
  };

  type PaymentGetPayload<
    S extends boolean | null | undefined | PaymentDefaultArgs,
  > = $Result.GetResult<Prisma.$PaymentPayload, S>;

  type PaymentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PaymentFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: PaymentCountAggregateInputType | true;
  };

  export interface PaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Payment"];
      meta: { name: "Payment" };
    };
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     *
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     *
     */
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     *
     */
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
     **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PaymentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaymentAggregateArgs>(
      args: Subset<T, PaymentAggregateArgs>
    ): Prisma.PrismaPromise<GetPaymentAggregateType<T>>;

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs["orderBy"] }
        : { orderBy?: PaymentGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPaymentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Payment model
     */
    readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    reservation<T extends ReservationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ReservationDefaultArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      | $Result.GetResult<
          Prisma.$ReservationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", "String">;
    readonly stripeSession: FieldRef<"Payment", "String">;
    readonly amount: FieldRef<"Payment", "Decimal">;
    readonly status: FieldRef<"Payment", "PaymentStatus">;
    readonly intent_id: FieldRef<"Payment", "String">;
    readonly reservationId: FieldRef<"Payment", "String">;
    readonly createdAt: FieldRef<"Payment", "DateTime">;
    readonly updatedAt: FieldRef<"Payment", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment create
   */
  export type PaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
  };

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
  };

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput;
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
  };

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to delete.
     */
    limit?: number;
  };

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
  };

  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  export type DocumentMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: string | null;
    url: string | null;
    uploadedAt: Date | null;
    userId: string | null;
    reservationId: string | null;
  };

  export type DocumentMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    type: string | null;
    url: string | null;
    uploadedAt: Date | null;
    userId: string | null;
    reservationId: string | null;
  };

  export type DocumentCountAggregateOutputType = {
    id: number;
    name: number;
    type: number;
    url: number;
    uploadedAt: number;
    userId: number;
    reservationId: number;
    _all: number;
  };

  export type DocumentMinAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    url?: true;
    uploadedAt?: true;
    userId?: true;
    reservationId?: true;
  };

  export type DocumentMaxAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    url?: true;
    uploadedAt?: true;
    userId?: true;
    reservationId?: true;
  };

  export type DocumentCountAggregateInputType = {
    id?: true;
    name?: true;
    type?: true;
    url?: true;
    uploadedAt?: true;
    userId?: true;
    reservationId?: true;
    _all?: true;
  };

  export type DocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?:
      | DocumentOrderByWithRelationInput
      | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Documents
     **/
    _count?: true | DocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DocumentMaxAggregateInputType;
  };

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
    [P in keyof T & keyof AggregateDocument]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>;
  };

  export type DocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
    orderBy?:
      | DocumentOrderByWithAggregationInput
      | DocumentOrderByWithAggregationInput[];
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum;
    having?: DocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DocumentCountAggregateInputType | true;
    _min?: DocumentMinAggregateInputType;
    _max?: DocumentMaxAggregateInputType;
  };

  export type DocumentGroupByOutputType = {
    id: string;
    name: string;
    type: string;
    url: string;
    uploadedAt: Date;
    userId: string;
    reservationId: string | null;
    _count: DocumentCountAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DocumentGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof DocumentGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>;
        }
      >
    >;

  export type DocumentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      url?: boolean;
      uploadedAt?: boolean;
      userId?: boolean;
      reservationId?: boolean;
      Reservation?: boolean | Document$ReservationArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["document"]
  >;

  export type DocumentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      url?: boolean;
      uploadedAt?: boolean;
      userId?: boolean;
      reservationId?: boolean;
      Reservation?: boolean | Document$ReservationArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["document"]
  >;

  export type DocumentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      type?: boolean;
      url?: boolean;
      uploadedAt?: boolean;
      userId?: boolean;
      reservationId?: boolean;
      Reservation?: boolean | Document$ReservationArgs<ExtArgs>;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["document"]
  >;

  export type DocumentSelectScalar = {
    id?: boolean;
    name?: boolean;
    type?: boolean;
    url?: boolean;
    uploadedAt?: boolean;
    userId?: boolean;
    reservationId?: boolean;
  };

  export type DocumentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "name" | "type" | "url" | "uploadedAt" | "userId" | "reservationId",
    ExtArgs["result"]["document"]
  >;
  export type DocumentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    Reservation?: boolean | Document$ReservationArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type DocumentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    Reservation?: boolean | Document$ReservationArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type DocumentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    Reservation?: boolean | Document$ReservationArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $DocumentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Document";
    objects: {
      Reservation: Prisma.$ReservationPayload<ExtArgs> | null;
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        type: string;
        url: string;
        uploadedAt: Date;
        userId: string;
        reservationId: string | null;
      },
      ExtArgs["result"]["document"]
    >;
    composites: {};
  };

  type DocumentGetPayload<
    S extends boolean | null | undefined | DocumentDefaultArgs,
  > = $Result.GetResult<Prisma.$DocumentPayload, S>;

  type DocumentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<DocumentFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: DocumentCountAggregateInputType | true;
  };

  export interface DocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Document"];
      meta: { name: "Document" };
    };
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     *
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DocumentFindManyArgs>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     *
     */
    create<T extends DocumentCreateArgs>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DocumentCreateManyArgs>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     *
     */
    delete<T extends DocumentDeleteArgs>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DocumentUpdateArgs>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DocumentDeleteManyArgs>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DocumentUpdateManyArgs>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<
        Prisma.$DocumentPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
     **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], DocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DocumentAggregateArgs>(
      args: Subset<T, DocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetDocumentAggregateType<T>>;

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs["orderBy"] }
        : { orderBy?: DocumentGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetDocumentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Document model
     */
    readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Reservation<T extends Document$ReservationArgs<ExtArgs> = {}>(
      args?: Subset<T, Document$ReservationArgs<ExtArgs>>
    ): Prisma__ReservationClient<
      $Result.GetResult<
        Prisma.$ReservationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", "String">;
    readonly name: FieldRef<"Document", "String">;
    readonly type: FieldRef<"Document", "String">;
    readonly url: FieldRef<"Document", "String">;
    readonly uploadedAt: FieldRef<"Document", "DateTime">;
    readonly userId: FieldRef<"Document", "String">;
    readonly reservationId: FieldRef<"Document", "String">;
  }

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?:
      | DocumentOrderByWithRelationInput
      | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?:
      | DocumentOrderByWithRelationInput
      | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?:
      | DocumentOrderByWithRelationInput
      | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document create
   */
  export type DocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
  };

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Document update
   */
  export type DocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Documents.
     */
    data: XOR<
      DocumentUpdateManyMutationInput,
      DocumentUncheckedUpdateManyInput
    >;
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to update.
     */
    limit?: number;
  };

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * The data used to update Documents.
     */
    data: XOR<
      DocumentUpdateManyMutationInput,
      DocumentUncheckedUpdateManyInput
    >;
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput;
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
  };

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput;
    /**
     * Limit how many Documents to delete.
     */
    limit?: number;
  };

  /**
   * Document.Reservation
   */
  export type Document$ReservationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null;
    where?: ReservationWhereInput;
  };

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
  };

  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null;
    _avg: ImageAvgAggregateOutputType | null;
    _sum: ImageSumAggregateOutputType | null;
    _min: ImageMinAggregateOutputType | null;
    _max: ImageMaxAggregateOutputType | null;
  };

  export type ImageAvgAggregateOutputType = {
    position: number | null;
    vehicleId: number | null;
  };

  export type ImageSumAggregateOutputType = {
    position: number | null;
    vehicleId: number | null;
  };

  export type ImageMinAggregateOutputType = {
    id: string | null;
    url: string | null;
    uploadedAt: Date | null;
    position: number | null;
    vehicleId: number | null;
  };

  export type ImageMaxAggregateOutputType = {
    id: string | null;
    url: string | null;
    uploadedAt: Date | null;
    position: number | null;
    vehicleId: number | null;
  };

  export type ImageCountAggregateOutputType = {
    id: number;
    url: number;
    uploadedAt: number;
    position: number;
    vehicleId: number;
    _all: number;
  };

  export type ImageAvgAggregateInputType = {
    position?: true;
    vehicleId?: true;
  };

  export type ImageSumAggregateInputType = {
    position?: true;
    vehicleId?: true;
  };

  export type ImageMinAggregateInputType = {
    id?: true;
    url?: true;
    uploadedAt?: true;
    position?: true;
    vehicleId?: true;
  };

  export type ImageMaxAggregateInputType = {
    id?: true;
    url?: true;
    uploadedAt?: true;
    position?: true;
    vehicleId?: true;
  };

  export type ImageCountAggregateInputType = {
    id?: true;
    url?: true;
    uploadedAt?: true;
    position?: true;
    vehicleId?: true;
    _all?: true;
  };

  export type ImageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Images.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Images
     **/
    _count?: true | ImageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ImageAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ImageSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ImageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ImageMaxAggregateInputType;
  };

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
    [P in keyof T & keyof AggregateImage]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>;
  };

  export type ImageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ImageWhereInput;
    orderBy?:
      | ImageOrderByWithAggregationInput
      | ImageOrderByWithAggregationInput[];
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum;
    having?: ImageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ImageCountAggregateInputType | true;
    _avg?: ImageAvgAggregateInputType;
    _sum?: ImageSumAggregateInputType;
    _min?: ImageMinAggregateInputType;
    _max?: ImageMaxAggregateInputType;
  };

  export type ImageGroupByOutputType = {
    id: string;
    url: string;
    uploadedAt: Date;
    position: number;
    vehicleId: number | null;
    _count: ImageCountAggregateOutputType | null;
    _avg: ImageAvgAggregateOutputType | null;
    _sum: ImageSumAggregateOutputType | null;
    _min: ImageMinAggregateOutputType | null;
    _max: ImageMaxAggregateOutputType | null;
  };

  type GetImageGroupByPayload<T extends ImageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ImageGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ImageGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>;
        }
      >
    >;

  export type ImageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      url?: boolean;
      uploadedAt?: boolean;
      position?: boolean;
      vehicleId?: boolean;
      vehicle?: boolean | Image$vehicleArgs<ExtArgs>;
    },
    ExtArgs["result"]["image"]
  >;

  export type ImageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      url?: boolean;
      uploadedAt?: boolean;
      position?: boolean;
      vehicleId?: boolean;
      vehicle?: boolean | Image$vehicleArgs<ExtArgs>;
    },
    ExtArgs["result"]["image"]
  >;

  export type ImageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      url?: boolean;
      uploadedAt?: boolean;
      position?: boolean;
      vehicleId?: boolean;
      vehicle?: boolean | Image$vehicleArgs<ExtArgs>;
    },
    ExtArgs["result"]["image"]
  >;

  export type ImageSelectScalar = {
    id?: boolean;
    url?: boolean;
    uploadedAt?: boolean;
    position?: boolean;
    vehicleId?: boolean;
  };

  export type ImageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "url" | "uploadedAt" | "position" | "vehicleId",
    ExtArgs["result"]["image"]
  >;
  export type ImageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    vehicle?: boolean | Image$vehicleArgs<ExtArgs>;
  };
  export type ImageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    vehicle?: boolean | Image$vehicleArgs<ExtArgs>;
  };
  export type ImageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    vehicle?: boolean | Image$vehicleArgs<ExtArgs>;
  };

  export type $ImagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Image";
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        url: string;
        uploadedAt: Date;
        position: number;
        vehicleId: number | null;
      },
      ExtArgs["result"]["image"]
    >;
    composites: {};
  };

  type ImageGetPayload<
    S extends boolean | null | undefined | ImageDefaultArgs,
  > = $Result.GetResult<Prisma.$ImagePayload, S>;

  type ImageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ImageFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ImageCountAggregateInputType | true;
  };

  export interface ImageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Image"];
      meta: { name: "Image" };
    };
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(
      args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(
      args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     *
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ImageFindManyArgs>(
      args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     *
     */
    create<T extends ImageCreateArgs>(
      args: SelectSubset<T, ImageCreateArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ImageCreateManyArgs>(
      args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     *
     */
    delete<T extends ImageDeleteArgs>(
      args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ImageUpdateArgs>(
      args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ImageDeleteManyArgs>(
      args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ImageUpdateManyArgs>(
      args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ImageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ImageUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(
      args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>
    ): Prisma__ImageClient<
      $Result.GetResult<
        Prisma.$ImagePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
     **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ImageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ImageAggregateArgs>(
      args: Subset<T, ImageAggregateArgs>
    ): Prisma.PrismaPromise<GetImageAggregateType<T>>;

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs["orderBy"] }
        : { orderBy?: ImageGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetImageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Image model
     */
    readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    vehicle<T extends Image$vehicleArgs<ExtArgs> = {}>(
      args?: Subset<T, Image$vehicleArgs<ExtArgs>>
    ): Prisma__VehicleClient<
      $Result.GetResult<
        Prisma.$VehiclePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", "String">;
    readonly url: FieldRef<"Image", "String">;
    readonly uploadedAt: FieldRef<"Image", "DateTime">;
    readonly position: FieldRef<"Image", "Int">;
    readonly vehicleId: FieldRef<"Image", "Int">;
  }

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput;
  };

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput;
  };

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Images.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Images.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Images.
     */
    skip?: number;
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * Image create
   */
  export type ImageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>;
  };

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Image update
   */
  export type ImageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>;
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput;
  };

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>;
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput;
    /**
     * Limit how many Images to update.
     */
    limit?: number;
  };

  /**
   * Image updateManyAndReturn
   */
  export type ImageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>;
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput;
    /**
     * Limit how many Images to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput;
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>;
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>;
  };

  /**
   * Image delete
   */
  export type ImageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput;
  };

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput;
    /**
     * Limit how many Images to delete.
     */
    limit?: number;
  };

  /**
   * Image.vehicle
   */
  export type Image$vehicleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null;
    where?: VehicleWhereInput;
  };

  /**
   * Image without action
   */
  export type ImageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null;
  };

  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null;
    _min: PushSubscriptionMinAggregateOutputType | null;
    _max: PushSubscriptionMaxAggregateOutputType | null;
  };

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null;
    endpoint: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    userId: string | null;
  };

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null;
    endpoint: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    userId: string | null;
  };

  export type PushSubscriptionCountAggregateOutputType = {
    id: number;
    endpoint: number;
    keys: number;
    createdAt: number;
    updatedAt: number;
    userId: number;
    _all: number;
  };

  export type PushSubscriptionMinAggregateInputType = {
    id?: true;
    endpoint?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
  };

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true;
    endpoint?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
  };

  export type PushSubscriptionCountAggregateInputType = {
    id?: true;
    endpoint?: true;
    keys?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
    _all?: true;
  };

  export type PushSubscriptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PushSubscriptions
     **/
    _count?: true | PushSubscriptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PushSubscriptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PushSubscriptionMaxAggregateInputType;
  };

  export type GetPushSubscriptionAggregateType<
    T extends PushSubscriptionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregatePushSubscription]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>;
  };

  export type PushSubscriptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PushSubscriptionWhereInput;
    orderBy?:
      | PushSubscriptionOrderByWithAggregationInput
      | PushSubscriptionOrderByWithAggregationInput[];
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum;
    having?: PushSubscriptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PushSubscriptionCountAggregateInputType | true;
    _min?: PushSubscriptionMinAggregateInputType;
    _max?: PushSubscriptionMaxAggregateInputType;
  };

  export type PushSubscriptionGroupByOutputType = {
    id: string;
    endpoint: string;
    keys: JsonValue;
    createdAt: Date;
    updatedAt: Date;
    userId: string;
    _count: PushSubscriptionCountAggregateOutputType | null;
    _min: PushSubscriptionMinAggregateOutputType | null;
    _max: PushSubscriptionMaxAggregateOutputType | null;
  };

  type GetPushSubscriptionGroupByPayload<
    T extends PushSubscriptionGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof PushSubscriptionGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
          : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>;
      }
    >
  >;

  export type PushSubscriptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      keys?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      userId?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["pushSubscription"]
  >;

  export type PushSubscriptionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      keys?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      userId?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["pushSubscription"]
  >;

  export type PushSubscriptionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      endpoint?: boolean;
      keys?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      userId?: boolean;
      User?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["pushSubscription"]
  >;

  export type PushSubscriptionSelectScalar = {
    id?: boolean;
    endpoint?: boolean;
    keys?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    userId?: boolean;
  };

  export type PushSubscriptionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "endpoint" | "keys" | "createdAt" | "updatedAt" | "userId",
    ExtArgs["result"]["pushSubscription"]
  >;
  export type PushSubscriptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type PushSubscriptionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type PushSubscriptionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PushSubscriptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "PushSubscription";
    objects: {
      User: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        endpoint: string;
        keys: Prisma.JsonValue;
        createdAt: Date;
        updatedAt: Date;
        userId: string;
      },
      ExtArgs["result"]["pushSubscription"]
    >;
    composites: {};
  };

  type PushSubscriptionGetPayload<
    S extends boolean | null | undefined | PushSubscriptionDefaultArgs,
  > = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>;

  type PushSubscriptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PushSubscriptionFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: PushSubscriptionCountAggregateInputType | true;
  };

  export interface PushSubscriptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["PushSubscription"];
      meta: { name: "PushSubscription" };
    };
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(
      args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(
      args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     *
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PushSubscriptionFindManyArgs>(
      args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     *
     */
    create<T extends PushSubscriptionCreateArgs>(
      args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(
      args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     *
     */
    delete<T extends PushSubscriptionDeleteArgs>(
      args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PushSubscriptionUpdateArgs>(
      args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(
      args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PushSubscriptions and returns the data updated in the database.
     * @param {PushSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PushSubscriptions.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PushSubscriptionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(
      args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
     **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PushSubscriptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PushSubscriptionAggregateArgs>(
      args: Subset<T, PushSubscriptionAggregateArgs>
    ): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>;

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs["orderBy"] }
        : { orderBy?: PushSubscriptionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPushSubscriptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PushSubscription model
     */
    readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", "String">;
    readonly endpoint: FieldRef<"PushSubscription", "String">;
    readonly keys: FieldRef<"PushSubscription", "Json">;
    readonly createdAt: FieldRef<"PushSubscription", "DateTime">;
    readonly updatedAt: FieldRef<"PushSubscription", "DateTime">;
    readonly userId: FieldRef<"PushSubscription", "String">;
  }

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<
      PushSubscriptionCreateInput,
      PushSubscriptionUncheckedCreateInput
    >;
  };

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<
      PushSubscriptionUpdateInput,
      PushSubscriptionUncheckedUpdateInput
    >;
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<
      PushSubscriptionUpdateManyMutationInput,
      PushSubscriptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput;
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number;
  };

  /**
   * PushSubscription updateManyAndReturn
   */
  export type PushSubscriptionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<
      PushSubscriptionUpdateManyMutationInput,
      PushSubscriptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput;
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput;
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<
      PushSubscriptionCreateInput,
      PushSubscriptionUncheckedCreateInput
    >;
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      PushSubscriptionUpdateInput,
      PushSubscriptionUncheckedUpdateInput
    >;
  };

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput;
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number;
  };

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
  };

  /**
   * Model Onboarding
   */

  export type AggregateOnboarding = {
    _count: OnboardingCountAggregateOutputType | null;
    _min: OnboardingMinAggregateOutputType | null;
    _max: OnboardingMaxAggregateOutputType | null;
  };

  export type OnboardingMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    tour: string | null;
    completed: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OnboardingMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    tour: string | null;
    completed: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OnboardingCountAggregateOutputType = {
    id: number;
    userId: number;
    tour: number;
    completed: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type OnboardingMinAggregateInputType = {
    id?: true;
    userId?: true;
    tour?: true;
    completed?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OnboardingMaxAggregateInputType = {
    id?: true;
    userId?: true;
    tour?: true;
    completed?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OnboardingCountAggregateInputType = {
    id?: true;
    userId?: true;
    tour?: true;
    completed?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type OnboardingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Onboarding to aggregate.
     */
    where?: OnboardingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Onboardings to fetch.
     */
    orderBy?:
      | OnboardingOrderByWithRelationInput
      | OnboardingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OnboardingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Onboardings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Onboardings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Onboardings
     **/
    _count?: true | OnboardingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OnboardingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OnboardingMaxAggregateInputType;
  };

  export type GetOnboardingAggregateType<T extends OnboardingAggregateArgs> = {
    [P in keyof T & keyof AggregateOnboarding]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboarding[P]>
      : GetScalarType<T[P], AggregateOnboarding[P]>;
  };

  export type OnboardingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OnboardingWhereInput;
    orderBy?:
      | OnboardingOrderByWithAggregationInput
      | OnboardingOrderByWithAggregationInput[];
    by: OnboardingScalarFieldEnum[] | OnboardingScalarFieldEnum;
    having?: OnboardingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OnboardingCountAggregateInputType | true;
    _min?: OnboardingMinAggregateInputType;
    _max?: OnboardingMaxAggregateInputType;
  };

  export type OnboardingGroupByOutputType = {
    id: string;
    userId: string;
    tour: string;
    completed: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: OnboardingCountAggregateOutputType | null;
    _min: OnboardingMinAggregateOutputType | null;
    _max: OnboardingMaxAggregateOutputType | null;
  };

  type GetOnboardingGroupByPayload<T extends OnboardingGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OnboardingGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OnboardingGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingGroupByOutputType[P]>;
        }
      >
    >;

  export type OnboardingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      tour?: boolean;
      completed?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["onboarding"]
  >;

  export type OnboardingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      tour?: boolean;
      completed?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["onboarding"]
  >;

  export type OnboardingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      tour?: boolean;
      completed?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["onboarding"]
  >;

  export type OnboardingSelectScalar = {
    id?: boolean;
    userId?: boolean;
    tour?: boolean;
    completed?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type OnboardingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "tour" | "completed" | "createdAt" | "updatedAt",
    ExtArgs["result"]["onboarding"]
  >;
  export type OnboardingInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type OnboardingIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type OnboardingIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $OnboardingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Onboarding";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        tour: string;
        completed: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["onboarding"]
    >;
    composites: {};
  };

  type OnboardingGetPayload<
    S extends boolean | null | undefined | OnboardingDefaultArgs,
  > = $Result.GetResult<Prisma.$OnboardingPayload, S>;

  type OnboardingCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OnboardingFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OnboardingCountAggregateInputType | true;
  };

  export interface OnboardingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Onboarding"];
      meta: { name: "Onboarding" };
    };
    /**
     * Find zero or one Onboarding that matches the filter.
     * @param {OnboardingFindUniqueArgs} args - Arguments to find a Onboarding
     * @example
     * // Get one Onboarding
     * const onboarding = await prisma.onboarding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingFindUniqueArgs>(
      args: SelectSubset<T, OnboardingFindUniqueArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Onboarding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OnboardingFindUniqueOrThrowArgs} args - Arguments to find a Onboarding
     * @example
     * // Get one Onboarding
     * const onboarding = await prisma.onboarding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OnboardingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Onboarding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingFindFirstArgs} args - Arguments to find a Onboarding
     * @example
     * // Get one Onboarding
     * const onboarding = await prisma.onboarding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingFindFirstArgs>(
      args?: SelectSubset<T, OnboardingFindFirstArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Onboarding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingFindFirstOrThrowArgs} args - Arguments to find a Onboarding
     * @example
     * // Get one Onboarding
     * const onboarding = await prisma.onboarding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OnboardingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Onboardings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Onboardings
     * const onboardings = await prisma.onboarding.findMany()
     *
     * // Get first 10 Onboardings
     * const onboardings = await prisma.onboarding.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const onboardingWithIdOnly = await prisma.onboarding.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OnboardingFindManyArgs>(
      args?: SelectSubset<T, OnboardingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Onboarding.
     * @param {OnboardingCreateArgs} args - Arguments to create a Onboarding.
     * @example
     * // Create one Onboarding
     * const Onboarding = await prisma.onboarding.create({
     *   data: {
     *     // ... data to create a Onboarding
     *   }
     * })
     *
     */
    create<T extends OnboardingCreateArgs>(
      args: SelectSubset<T, OnboardingCreateArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Onboardings.
     * @param {OnboardingCreateManyArgs} args - Arguments to create many Onboardings.
     * @example
     * // Create many Onboardings
     * const onboarding = await prisma.onboarding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OnboardingCreateManyArgs>(
      args?: SelectSubset<T, OnboardingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Onboardings and returns the data saved in the database.
     * @param {OnboardingCreateManyAndReturnArgs} args - Arguments to create many Onboardings.
     * @example
     * // Create many Onboardings
     * const onboarding = await prisma.onboarding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Onboardings and only return the `id`
     * const onboardingWithIdOnly = await prisma.onboarding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OnboardingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OnboardingCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Onboarding.
     * @param {OnboardingDeleteArgs} args - Arguments to delete one Onboarding.
     * @example
     * // Delete one Onboarding
     * const Onboarding = await prisma.onboarding.delete({
     *   where: {
     *     // ... filter to delete one Onboarding
     *   }
     * })
     *
     */
    delete<T extends OnboardingDeleteArgs>(
      args: SelectSubset<T, OnboardingDeleteArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Onboarding.
     * @param {OnboardingUpdateArgs} args - Arguments to update one Onboarding.
     * @example
     * // Update one Onboarding
     * const onboarding = await prisma.onboarding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OnboardingUpdateArgs>(
      args: SelectSubset<T, OnboardingUpdateArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Onboardings.
     * @param {OnboardingDeleteManyArgs} args - Arguments to filter Onboardings to delete.
     * @example
     * // Delete a few Onboardings
     * const { count } = await prisma.onboarding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OnboardingDeleteManyArgs>(
      args?: SelectSubset<T, OnboardingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Onboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Onboardings
     * const onboarding = await prisma.onboarding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OnboardingUpdateManyArgs>(
      args: SelectSubset<T, OnboardingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Onboardings and returns the data updated in the database.
     * @param {OnboardingUpdateManyAndReturnArgs} args - Arguments to update many Onboardings.
     * @example
     * // Update many Onboardings
     * const onboarding = await prisma.onboarding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Onboardings and only return the `id`
     * const onboardingWithIdOnly = await prisma.onboarding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OnboardingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OnboardingUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Onboarding.
     * @param {OnboardingUpsertArgs} args - Arguments to update or create a Onboarding.
     * @example
     * // Update or create a Onboarding
     * const onboarding = await prisma.onboarding.upsert({
     *   create: {
     *     // ... data to create a Onboarding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Onboarding we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingUpsertArgs>(
      args: SelectSubset<T, OnboardingUpsertArgs<ExtArgs>>
    ): Prisma__OnboardingClient<
      $Result.GetResult<
        Prisma.$OnboardingPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Onboardings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingCountArgs} args - Arguments to filter Onboardings to count.
     * @example
     * // Count the number of Onboardings
     * const count = await prisma.onboarding.count({
     *   where: {
     *     // ... the filter for the Onboardings we want to count
     *   }
     * })
     **/
    count<T extends OnboardingCountArgs>(
      args?: Subset<T, OnboardingCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OnboardingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Onboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OnboardingAggregateArgs>(
      args: Subset<T, OnboardingAggregateArgs>
    ): Prisma.PrismaPromise<GetOnboardingAggregateType<T>>;

    /**
     * Group by Onboarding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OnboardingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingGroupByArgs["orderBy"] }
        : { orderBy?: OnboardingGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OnboardingGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetOnboardingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Onboarding model
     */
    readonly fields: OnboardingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Onboarding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Onboarding model
   */
  interface OnboardingFieldRefs {
    readonly id: FieldRef<"Onboarding", "String">;
    readonly userId: FieldRef<"Onboarding", "String">;
    readonly tour: FieldRef<"Onboarding", "String">;
    readonly completed: FieldRef<"Onboarding", "Boolean">;
    readonly createdAt: FieldRef<"Onboarding", "DateTime">;
    readonly updatedAt: FieldRef<"Onboarding", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Onboarding findUnique
   */
  export type OnboardingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * Filter, which Onboarding to fetch.
     */
    where: OnboardingWhereUniqueInput;
  };

  /**
   * Onboarding findUniqueOrThrow
   */
  export type OnboardingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * Filter, which Onboarding to fetch.
     */
    where: OnboardingWhereUniqueInput;
  };

  /**
   * Onboarding findFirst
   */
  export type OnboardingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * Filter, which Onboarding to fetch.
     */
    where?: OnboardingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Onboardings to fetch.
     */
    orderBy?:
      | OnboardingOrderByWithRelationInput
      | OnboardingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Onboardings.
     */
    cursor?: OnboardingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Onboardings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Onboardings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Onboardings.
     */
    distinct?: OnboardingScalarFieldEnum | OnboardingScalarFieldEnum[];
  };

  /**
   * Onboarding findFirstOrThrow
   */
  export type OnboardingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * Filter, which Onboarding to fetch.
     */
    where?: OnboardingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Onboardings to fetch.
     */
    orderBy?:
      | OnboardingOrderByWithRelationInput
      | OnboardingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Onboardings.
     */
    cursor?: OnboardingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Onboardings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Onboardings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Onboardings.
     */
    distinct?: OnboardingScalarFieldEnum | OnboardingScalarFieldEnum[];
  };

  /**
   * Onboarding findMany
   */
  export type OnboardingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * Filter, which Onboardings to fetch.
     */
    where?: OnboardingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Onboardings to fetch.
     */
    orderBy?:
      | OnboardingOrderByWithRelationInput
      | OnboardingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Onboardings.
     */
    cursor?: OnboardingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Onboardings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Onboardings.
     */
    skip?: number;
    distinct?: OnboardingScalarFieldEnum | OnboardingScalarFieldEnum[];
  };

  /**
   * Onboarding create
   */
  export type OnboardingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * The data needed to create a Onboarding.
     */
    data: XOR<OnboardingCreateInput, OnboardingUncheckedCreateInput>;
  };

  /**
   * Onboarding createMany
   */
  export type OnboardingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Onboardings.
     */
    data: OnboardingCreateManyInput | OnboardingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Onboarding createManyAndReturn
   */
  export type OnboardingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * The data used to create many Onboardings.
     */
    data: OnboardingCreateManyInput | OnboardingCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Onboarding update
   */
  export type OnboardingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * The data needed to update a Onboarding.
     */
    data: XOR<OnboardingUpdateInput, OnboardingUncheckedUpdateInput>;
    /**
     * Choose, which Onboarding to update.
     */
    where: OnboardingWhereUniqueInput;
  };

  /**
   * Onboarding updateMany
   */
  export type OnboardingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Onboardings.
     */
    data: XOR<
      OnboardingUpdateManyMutationInput,
      OnboardingUncheckedUpdateManyInput
    >;
    /**
     * Filter which Onboardings to update
     */
    where?: OnboardingWhereInput;
    /**
     * Limit how many Onboardings to update.
     */
    limit?: number;
  };

  /**
   * Onboarding updateManyAndReturn
   */
  export type OnboardingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * The data used to update Onboardings.
     */
    data: XOR<
      OnboardingUpdateManyMutationInput,
      OnboardingUncheckedUpdateManyInput
    >;
    /**
     * Filter which Onboardings to update
     */
    where?: OnboardingWhereInput;
    /**
     * Limit how many Onboardings to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Onboarding upsert
   */
  export type OnboardingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * The filter to search for the Onboarding to update in case it exists.
     */
    where: OnboardingWhereUniqueInput;
    /**
     * In case the Onboarding found by the `where` argument doesn't exist, create a new Onboarding with this data.
     */
    create: XOR<OnboardingCreateInput, OnboardingUncheckedCreateInput>;
    /**
     * In case the Onboarding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingUpdateInput, OnboardingUncheckedUpdateInput>;
  };

  /**
   * Onboarding delete
   */
  export type OnboardingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
    /**
     * Filter which Onboarding to delete.
     */
    where: OnboardingWhereUniqueInput;
  };

  /**
   * Onboarding deleteMany
   */
  export type OnboardingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Onboardings to delete
     */
    where?: OnboardingWhereInput;
    /**
     * Limit how many Onboardings to delete.
     */
    limit?: number;
  };

  /**
   * Onboarding without action
   */
  export type OnboardingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Onboarding
     */
    select?: OnboardingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Onboarding
     */
    omit?: OnboardingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    name: "name";
    email: "email";
    emailVerified: "emailVerified";
    image: "image";
    phone: "phone";
    isAdmin: "isAdmin";
    isVerified: "isVerified";
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const PreferencesScalarFieldEnum: {
    id: "id";
    userId: "userId";
    UserNotifications: "UserNotifications";
    ReservationNotifications: "ReservationNotifications";
    LeadNotifications: "LeadNotifications";
    ContactNotifications: "ContactNotifications";
    PaymentNotifications: "PaymentNotifications";
    ReviewNotifications: "ReviewNotifications";
  };

  export type PreferencesScalarFieldEnum =
    (typeof PreferencesScalarFieldEnum)[keyof typeof PreferencesScalarFieldEnum];

  export const AccountScalarFieldEnum: {
    id: "id";
    userId: "userId";
    type: "type";
    provider: "provider";
    refresh_token: "refresh_token";
    access_token: "access_token";
    expires_at: "expires_at";
    token_type: "token_type";
    scope: "scope";
    id_token: "id_token";
    session_state: "session_state";
    providerAccountId: "providerAccountId";
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const ReservationScalarFieldEnum: {
    id: "id";
    pickupDate: "pickupDate";
    dropoffDate: "dropoffDate";
    pickupLocation: "pickupLocation";
    dropoffLocation: "dropoffLocation";
    pickupHour: "pickupHour";
    dropoffHour: "dropoffHour";
    dailyRate: "dailyRate";
    totalDays: "totalDays";
    subtotal: "subtotal";
    tax: "tax";
    totalAmount: "totalAmount";
    amountPaid: "amountPaid";
    status: "status";
    paymentStatus: "paymentStatus";
    notes: "notes";
    specialRequests: "specialRequests";
    vehicleId: "vehicleId";
    userId: "userId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ReservationScalarFieldEnum =
    (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum];

  export const DraftReservationScalarFieldEnum: {
    id: "id";
    name: "name";
    email: "email";
    phone: "phone";
    vehicleId: "vehicleId";
    message: "message";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    dropoffDate: "dropoffDate";
    dropoffHour: "dropoffHour";
    dropoffLocation: "dropoffLocation";
    pickupDate: "pickupDate";
    pickupHour: "pickupHour";
    pickupLocation: "pickupLocation";
  };

  export type DraftReservationScalarFieldEnum =
    (typeof DraftReservationScalarFieldEnum)[keyof typeof DraftReservationScalarFieldEnum];

  export const StatusChangeScalarFieldEnum: {
    id: "id";
    reservationId: "reservationId";
    fromStatus: "fromStatus";
    toStatus: "toStatus";
    reason: "reason";
    changedBy: "changedBy";
    changeAt: "changeAt";
  };

  export type StatusChangeScalarFieldEnum =
    (typeof StatusChangeScalarFieldEnum)[keyof typeof StatusChangeScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: "id";
    userId: "userId";
    expires: "expires";
    sessionToken: "sessionToken";
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const VerificationTokenScalarFieldEnum: {
    identifier: "identifier";
    token: "token";
    expires: "expires";
  };

  export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

  export const VehicleScalarFieldEnum: {
    id: "id";
    make: "make";
    model: "model";
    category: "category";
    year: "year";
    color: "color";
    transmission: "transmission";
    fuel_type: "fuel_type";
    licensePlate: "licensePlate";
    status: "status";
    features: "features";
    dailyRate: "dailyRate";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type VehicleScalarFieldEnum =
    (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum];

  export const MaintenanceBlockScalarFieldEnum: {
    id: "id";
    vehicleId: "vehicleId";
    reason: "reason";
    startDate: "startDate";
    endDate: "endDate";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type MaintenanceBlockScalarFieldEnum =
    (typeof MaintenanceBlockScalarFieldEnum)[keyof typeof MaintenanceBlockScalarFieldEnum];

  export const PaymentScalarFieldEnum: {
    id: "id";
    stripeSession: "stripeSession";
    amount: "amount";
    status: "status";
    intent_id: "intent_id";
    reservationId: "reservationId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type PaymentScalarFieldEnum =
    (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum];

  export const DocumentScalarFieldEnum: {
    id: "id";
    name: "name";
    type: "type";
    url: "url";
    uploadedAt: "uploadedAt";
    userId: "userId";
    reservationId: "reservationId";
  };

  export type DocumentScalarFieldEnum =
    (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum];

  export const ImageScalarFieldEnum: {
    id: "id";
    url: "url";
    uploadedAt: "uploadedAt";
    position: "position";
    vehicleId: "vehicleId";
  };

  export type ImageScalarFieldEnum =
    (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum];

  export const PushSubscriptionScalarFieldEnum: {
    id: "id";
    endpoint: "endpoint";
    keys: "keys";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    userId: "userId";
  };

  export type PushSubscriptionScalarFieldEnum =
    (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum];

  export const OnboardingScalarFieldEnum: {
    id: "id";
    userId: "userId";
    tour: "tour";
    completed: "completed";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type OnboardingScalarFieldEnum =
    (typeof OnboardingScalarFieldEnum)[keyof typeof OnboardingScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Decimal"
  >;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Decimal[]"
  >;

  /**
   * Reference to a field of type 'ReservationStatus'
   */
  export type EnumReservationStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ReservationStatus">;

  /**
   * Reference to a field of type 'ReservationStatus[]'
   */
  export type ListEnumReservationStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ReservationStatus[]">;

  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "PaymentStatus"
  >;

  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "PaymentStatus[]">;

  /**
   * Reference to a field of type 'VehicleCategory'
   */
  export type EnumVehicleCategoryFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "VehicleCategory">;

  /**
   * Reference to a field of type 'VehicleCategory[]'
   */
  export type ListEnumVehicleCategoryFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "VehicleCategory[]">;

  /**
   * Reference to a field of type 'VehicleTransmission'
   */
  export type EnumVehicleTransmissionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "VehicleTransmission">;

  /**
   * Reference to a field of type 'VehicleTransmission[]'
   */
  export type ListEnumVehicleTransmissionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "VehicleTransmission[]">;

  /**
   * Reference to a field of type 'VehicleFuelType'
   */
  export type EnumVehicleFuelTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "VehicleFuelType">;

  /**
   * Reference to a field of type 'VehicleFuelType[]'
   */
  export type ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "VehicleFuelType[]">;

  /**
   * Reference to a field of type 'VehicleStatus'
   */
  export type EnumVehicleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "VehicleStatus"
  >;

  /**
   * Reference to a field of type 'VehicleStatus[]'
   */
  export type ListEnumVehicleStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "VehicleStatus[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Json"
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "QueryMode"
  >;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    name?: StringNullableFilter<"User"> | string | null;
    email?: StringFilter<"User"> | string;
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null;
    image?: StringNullableFilter<"User"> | string | null;
    phone?: StringNullableFilter<"User"> | string | null;
    isAdmin?: BoolFilter<"User"> | boolean;
    isVerified?: BoolFilter<"User"> | boolean;
    Account?: AccountListRelationFilter;
    documents?: DocumentListRelationFilter;
    Onboarding?: OnboardingListRelationFilter;
    notificationsPreferences?: XOR<
      PreferencesNullableScalarRelationFilter,
      PreferencesWhereInput
    > | null;
    PushSubscription?: PushSubscriptionListRelationFilter;
    Reservation?: ReservationListRelationFilter;
    Session?: SessionListRelationFilter;
    StatusChange?: StatusChangeListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    isAdmin?: SortOrder;
    isVerified?: SortOrder;
    Account?: AccountOrderByRelationAggregateInput;
    documents?: DocumentOrderByRelationAggregateInput;
    Onboarding?: OnboardingOrderByRelationAggregateInput;
    notificationsPreferences?: PreferencesOrderByWithRelationInput;
    PushSubscription?: PushSubscriptionOrderByRelationAggregateInput;
    Reservation?: ReservationOrderByRelationAggregateInput;
    Session?: SessionOrderByRelationAggregateInput;
    StatusChange?: StatusChangeOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<"User"> | string | null;
      emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null;
      image?: StringNullableFilter<"User"> | string | null;
      phone?: StringNullableFilter<"User"> | string | null;
      isAdmin?: BoolFilter<"User"> | boolean;
      isVerified?: BoolFilter<"User"> | boolean;
      Account?: AccountListRelationFilter;
      documents?: DocumentListRelationFilter;
      Onboarding?: OnboardingListRelationFilter;
      notificationsPreferences?: XOR<
        PreferencesNullableScalarRelationFilter,
        PreferencesWhereInput
      > | null;
      PushSubscription?: PushSubscriptionListRelationFilter;
      Reservation?: ReservationListRelationFilter;
      Session?: SessionListRelationFilter;
      StatusChange?: StatusChangeListRelationFilter;
    },
    "id" | "email"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    isAdmin?: SortOrder;
    isVerified?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    name?: StringNullableWithAggregatesFilter<"User"> | string | null;
    email?: StringWithAggregatesFilter<"User"> | string;
    emailVerified?:
      | DateTimeNullableWithAggregatesFilter<"User">
      | Date
      | string
      | null;
    image?: StringNullableWithAggregatesFilter<"User"> | string | null;
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null;
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean;
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean;
  };

  export type PreferencesWhereInput = {
    AND?: PreferencesWhereInput | PreferencesWhereInput[];
    OR?: PreferencesWhereInput[];
    NOT?: PreferencesWhereInput | PreferencesWhereInput[];
    id?: StringFilter<"Preferences"> | string;
    userId?: StringFilter<"Preferences"> | string;
    UserNotifications?: BoolFilter<"Preferences"> | boolean;
    ReservationNotifications?: BoolFilter<"Preferences"> | boolean;
    LeadNotifications?: BoolFilter<"Preferences"> | boolean;
    ContactNotifications?: BoolFilter<"Preferences"> | boolean;
    PaymentNotifications?: BoolFilter<"Preferences"> | boolean;
    ReviewNotifications?: BoolFilter<"Preferences"> | boolean;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type PreferencesOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    UserNotifications?: SortOrder;
    ReservationNotifications?: SortOrder;
    LeadNotifications?: SortOrder;
    ContactNotifications?: SortOrder;
    PaymentNotifications?: SortOrder;
    ReviewNotifications?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type PreferencesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: PreferencesWhereInput | PreferencesWhereInput[];
      OR?: PreferencesWhereInput[];
      NOT?: PreferencesWhereInput | PreferencesWhereInput[];
      UserNotifications?: BoolFilter<"Preferences"> | boolean;
      ReservationNotifications?: BoolFilter<"Preferences"> | boolean;
      LeadNotifications?: BoolFilter<"Preferences"> | boolean;
      ContactNotifications?: BoolFilter<"Preferences"> | boolean;
      PaymentNotifications?: BoolFilter<"Preferences"> | boolean;
      ReviewNotifications?: BoolFilter<"Preferences"> | boolean;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId"
  >;

  export type PreferencesOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    UserNotifications?: SortOrder;
    ReservationNotifications?: SortOrder;
    LeadNotifications?: SortOrder;
    ContactNotifications?: SortOrder;
    PaymentNotifications?: SortOrder;
    ReviewNotifications?: SortOrder;
    _count?: PreferencesCountOrderByAggregateInput;
    _max?: PreferencesMaxOrderByAggregateInput;
    _min?: PreferencesMinOrderByAggregateInput;
  };

  export type PreferencesScalarWhereWithAggregatesInput = {
    AND?:
      | PreferencesScalarWhereWithAggregatesInput
      | PreferencesScalarWhereWithAggregatesInput[];
    OR?: PreferencesScalarWhereWithAggregatesInput[];
    NOT?:
      | PreferencesScalarWhereWithAggregatesInput
      | PreferencesScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Preferences"> | string;
    userId?: StringWithAggregatesFilter<"Preferences"> | string;
    UserNotifications?: BoolWithAggregatesFilter<"Preferences"> | boolean;
    ReservationNotifications?:
      | BoolWithAggregatesFilter<"Preferences">
      | boolean;
    LeadNotifications?: BoolWithAggregatesFilter<"Preferences"> | boolean;
    ContactNotifications?: BoolWithAggregatesFilter<"Preferences"> | boolean;
    PaymentNotifications?: BoolWithAggregatesFilter<"Preferences"> | boolean;
    ReviewNotifications?: BoolWithAggregatesFilter<"Preferences"> | boolean;
  };

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: IntFilter<"Account"> | number;
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
    providerAccountId?: StringFilter<"Account"> | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    providerAccountId?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<"Account"> | string;
      type?: StringFilter<"Account"> | string;
      provider?: StringFilter<"Account"> | string;
      refresh_token?: StringNullableFilter<"Account"> | string | null;
      access_token?: StringNullableFilter<"Account"> | string | null;
      expires_at?: IntNullableFilter<"Account"> | number | null;
      token_type?: StringNullableFilter<"Account"> | string | null;
      scope?: StringNullableFilter<"Account"> | string | null;
      id_token?: StringNullableFilter<"Account"> | string | null;
      session_state?: StringNullableFilter<"Account"> | string | null;
      providerAccountId?: StringFilter<"Account"> | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "provider_providerAccountId"
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    providerAccountId?: SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Account"> | number;
    userId?: StringWithAggregatesFilter<"Account"> | string;
    type?: StringWithAggregatesFilter<"Account"> | string;
    provider?: StringWithAggregatesFilter<"Account"> | string;
    refresh_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    access_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null;
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    session_state?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string;
  };

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[];
    OR?: ReservationWhereInput[];
    NOT?: ReservationWhereInput | ReservationWhereInput[];
    id?: StringFilter<"Reservation"> | string;
    pickupDate?: DateTimeFilter<"Reservation"> | Date | string;
    dropoffDate?: DateTimeFilter<"Reservation"> | Date | string;
    pickupLocation?: StringFilter<"Reservation"> | string;
    dropoffLocation?: StringFilter<"Reservation"> | string;
    pickupHour?: StringFilter<"Reservation"> | string;
    dropoffHour?: StringFilter<"Reservation"> | string;
    dailyRate?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFilter<"Reservation">
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFilter<"Reservation">
      | $Enums.PaymentStatus;
    notes?: StringNullableFilter<"Reservation"> | string | null;
    specialRequests?: StringNullableFilter<"Reservation"> | string | null;
    vehicleId?: IntNullableFilter<"Reservation"> | number | null;
    userId?: StringFilter<"Reservation"> | string;
    createdAt?: DateTimeFilter<"Reservation"> | Date | string;
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string;
    contracts?: DocumentListRelationFilter;
    payments?: PaymentListRelationFilter;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    vehicle?: XOR<
      VehicleNullableScalarRelationFilter,
      VehicleWhereInput
    > | null;
    statusHistory?: StatusChangeListRelationFilter;
  };

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder;
    pickupDate?: SortOrder;
    dropoffDate?: SortOrder;
    pickupLocation?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupHour?: SortOrder;
    dropoffHour?: SortOrder;
    dailyRate?: SortOrder;
    totalDays?: SortOrder;
    subtotal?: SortOrder;
    tax?: SortOrder;
    totalAmount?: SortOrder;
    amountPaid?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    specialRequests?: SortOrderInput | SortOrder;
    vehicleId?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    contracts?: DocumentOrderByRelationAggregateInput;
    payments?: PaymentOrderByRelationAggregateInput;
    user?: UserOrderByWithRelationInput;
    vehicle?: VehicleOrderByWithRelationInput;
    statusHistory?: StatusChangeOrderByRelationAggregateInput;
  };

  export type ReservationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ReservationWhereInput | ReservationWhereInput[];
      OR?: ReservationWhereInput[];
      NOT?: ReservationWhereInput | ReservationWhereInput[];
      pickupDate?: DateTimeFilter<"Reservation"> | Date | string;
      dropoffDate?: DateTimeFilter<"Reservation"> | Date | string;
      pickupLocation?: StringFilter<"Reservation"> | string;
      dropoffLocation?: StringFilter<"Reservation"> | string;
      pickupHour?: StringFilter<"Reservation"> | string;
      dropoffHour?: StringFilter<"Reservation"> | string;
      dailyRate?:
        | DecimalFilter<"Reservation">
        | Decimal
        | DecimalJsLike
        | number
        | string;
      totalDays?:
        | DecimalFilter<"Reservation">
        | Decimal
        | DecimalJsLike
        | number
        | string;
      subtotal?:
        | DecimalFilter<"Reservation">
        | Decimal
        | DecimalJsLike
        | number
        | string;
      tax?:
        | DecimalFilter<"Reservation">
        | Decimal
        | DecimalJsLike
        | number
        | string;
      totalAmount?:
        | DecimalFilter<"Reservation">
        | Decimal
        | DecimalJsLike
        | number
        | string;
      amountPaid?:
        | DecimalFilter<"Reservation">
        | Decimal
        | DecimalJsLike
        | number
        | string;
      status?:
        | EnumReservationStatusFilter<"Reservation">
        | $Enums.ReservationStatus;
      paymentStatus?:
        | EnumPaymentStatusFilter<"Reservation">
        | $Enums.PaymentStatus;
      notes?: StringNullableFilter<"Reservation"> | string | null;
      specialRequests?: StringNullableFilter<"Reservation"> | string | null;
      vehicleId?: IntNullableFilter<"Reservation"> | number | null;
      userId?: StringFilter<"Reservation"> | string;
      createdAt?: DateTimeFilter<"Reservation"> | Date | string;
      updatedAt?: DateTimeFilter<"Reservation"> | Date | string;
      contracts?: DocumentListRelationFilter;
      payments?: PaymentListRelationFilter;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      vehicle?: XOR<
        VehicleNullableScalarRelationFilter,
        VehicleWhereInput
      > | null;
      statusHistory?: StatusChangeListRelationFilter;
    },
    "id"
  >;

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder;
    pickupDate?: SortOrder;
    dropoffDate?: SortOrder;
    pickupLocation?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupHour?: SortOrder;
    dropoffHour?: SortOrder;
    dailyRate?: SortOrder;
    totalDays?: SortOrder;
    subtotal?: SortOrder;
    tax?: SortOrder;
    totalAmount?: SortOrder;
    amountPaid?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    specialRequests?: SortOrderInput | SortOrder;
    vehicleId?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ReservationCountOrderByAggregateInput;
    _avg?: ReservationAvgOrderByAggregateInput;
    _max?: ReservationMaxOrderByAggregateInput;
    _min?: ReservationMinOrderByAggregateInput;
    _sum?: ReservationSumOrderByAggregateInput;
  };

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?:
      | ReservationScalarWhereWithAggregatesInput
      | ReservationScalarWhereWithAggregatesInput[];
    OR?: ReservationScalarWhereWithAggregatesInput[];
    NOT?:
      | ReservationScalarWhereWithAggregatesInput
      | ReservationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Reservation"> | string;
    pickupDate?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string;
    dropoffDate?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string;
    pickupLocation?: StringWithAggregatesFilter<"Reservation"> | string;
    dropoffLocation?: StringWithAggregatesFilter<"Reservation"> | string;
    pickupHour?: StringWithAggregatesFilter<"Reservation"> | string;
    dropoffHour?: StringWithAggregatesFilter<"Reservation"> | string;
    dailyRate?:
      | DecimalWithAggregatesFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalWithAggregatesFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalWithAggregatesFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalWithAggregatesFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalWithAggregatesFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalWithAggregatesFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusWithAggregatesFilter<"Reservation">
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusWithAggregatesFilter<"Reservation">
      | $Enums.PaymentStatus;
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null;
    specialRequests?:
      | StringNullableWithAggregatesFilter<"Reservation">
      | string
      | null;
    vehicleId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null;
    userId?: StringWithAggregatesFilter<"Reservation"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string;
  };

  export type DraftReservationWhereInput = {
    AND?: DraftReservationWhereInput | DraftReservationWhereInput[];
    OR?: DraftReservationWhereInput[];
    NOT?: DraftReservationWhereInput | DraftReservationWhereInput[];
    id?: StringFilter<"DraftReservation"> | string;
    name?: StringFilter<"DraftReservation"> | string;
    email?: StringFilter<"DraftReservation"> | string;
    phone?: StringFilter<"DraftReservation"> | string;
    vehicleId?: IntNullableFilter<"DraftReservation"> | number | null;
    message?: StringNullableFilter<"DraftReservation"> | string | null;
    createdAt?: DateTimeFilter<"DraftReservation"> | Date | string;
    updatedAt?: DateTimeFilter<"DraftReservation"> | Date | string;
    dropoffDate?: StringFilter<"DraftReservation"> | string;
    dropoffHour?: StringFilter<"DraftReservation"> | string;
    dropoffLocation?: StringFilter<"DraftReservation"> | string;
    pickupDate?: StringFilter<"DraftReservation"> | string;
    pickupHour?: StringFilter<"DraftReservation"> | string;
    pickupLocation?: StringFilter<"DraftReservation"> | string;
  };

  export type DraftReservationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    vehicleId?: SortOrderInput | SortOrder;
    message?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dropoffDate?: SortOrder;
    dropoffHour?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupDate?: SortOrder;
    pickupHour?: SortOrder;
    pickupLocation?: SortOrder;
  };

  export type DraftReservationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DraftReservationWhereInput | DraftReservationWhereInput[];
      OR?: DraftReservationWhereInput[];
      NOT?: DraftReservationWhereInput | DraftReservationWhereInput[];
      name?: StringFilter<"DraftReservation"> | string;
      email?: StringFilter<"DraftReservation"> | string;
      phone?: StringFilter<"DraftReservation"> | string;
      vehicleId?: IntNullableFilter<"DraftReservation"> | number | null;
      message?: StringNullableFilter<"DraftReservation"> | string | null;
      createdAt?: DateTimeFilter<"DraftReservation"> | Date | string;
      updatedAt?: DateTimeFilter<"DraftReservation"> | Date | string;
      dropoffDate?: StringFilter<"DraftReservation"> | string;
      dropoffHour?: StringFilter<"DraftReservation"> | string;
      dropoffLocation?: StringFilter<"DraftReservation"> | string;
      pickupDate?: StringFilter<"DraftReservation"> | string;
      pickupHour?: StringFilter<"DraftReservation"> | string;
      pickupLocation?: StringFilter<"DraftReservation"> | string;
    },
    "id"
  >;

  export type DraftReservationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    vehicleId?: SortOrderInput | SortOrder;
    message?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dropoffDate?: SortOrder;
    dropoffHour?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupDate?: SortOrder;
    pickupHour?: SortOrder;
    pickupLocation?: SortOrder;
    _count?: DraftReservationCountOrderByAggregateInput;
    _avg?: DraftReservationAvgOrderByAggregateInput;
    _max?: DraftReservationMaxOrderByAggregateInput;
    _min?: DraftReservationMinOrderByAggregateInput;
    _sum?: DraftReservationSumOrderByAggregateInput;
  };

  export type DraftReservationScalarWhereWithAggregatesInput = {
    AND?:
      | DraftReservationScalarWhereWithAggregatesInput
      | DraftReservationScalarWhereWithAggregatesInput[];
    OR?: DraftReservationScalarWhereWithAggregatesInput[];
    NOT?:
      | DraftReservationScalarWhereWithAggregatesInput
      | DraftReservationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"DraftReservation"> | string;
    name?: StringWithAggregatesFilter<"DraftReservation"> | string;
    email?: StringWithAggregatesFilter<"DraftReservation"> | string;
    phone?: StringWithAggregatesFilter<"DraftReservation"> | string;
    vehicleId?:
      | IntNullableWithAggregatesFilter<"DraftReservation">
      | number
      | null;
    message?:
      | StringNullableWithAggregatesFilter<"DraftReservation">
      | string
      | null;
    createdAt?:
      | DateTimeWithAggregatesFilter<"DraftReservation">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"DraftReservation">
      | Date
      | string;
    dropoffDate?: StringWithAggregatesFilter<"DraftReservation"> | string;
    dropoffHour?: StringWithAggregatesFilter<"DraftReservation"> | string;
    dropoffLocation?: StringWithAggregatesFilter<"DraftReservation"> | string;
    pickupDate?: StringWithAggregatesFilter<"DraftReservation"> | string;
    pickupHour?: StringWithAggregatesFilter<"DraftReservation"> | string;
    pickupLocation?: StringWithAggregatesFilter<"DraftReservation"> | string;
  };

  export type StatusChangeWhereInput = {
    AND?: StatusChangeWhereInput | StatusChangeWhereInput[];
    OR?: StatusChangeWhereInput[];
    NOT?: StatusChangeWhereInput | StatusChangeWhereInput[];
    id?: StringFilter<"StatusChange"> | string;
    reservationId?: StringFilter<"StatusChange"> | string;
    fromStatus?:
      | EnumReservationStatusNullableFilter<"StatusChange">
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFilter<"StatusChange">
      | $Enums.ReservationStatus;
    reason?: StringNullableFilter<"StatusChange"> | string | null;
    changedBy?: StringNullableFilter<"StatusChange"> | string | null;
    changeAt?: DateTimeFilter<"StatusChange"> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    reservation?: XOR<ReservationScalarRelationFilter, ReservationWhereInput>;
  };

  export type StatusChangeOrderByWithRelationInput = {
    id?: SortOrder;
    reservationId?: SortOrder;
    fromStatus?: SortOrderInput | SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrderInput | SortOrder;
    changedBy?: SortOrderInput | SortOrder;
    changeAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    reservation?: ReservationOrderByWithRelationInput;
  };

  export type StatusChangeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: StatusChangeWhereInput | StatusChangeWhereInput[];
      OR?: StatusChangeWhereInput[];
      NOT?: StatusChangeWhereInput | StatusChangeWhereInput[];
      reservationId?: StringFilter<"StatusChange"> | string;
      fromStatus?:
        | EnumReservationStatusNullableFilter<"StatusChange">
        | $Enums.ReservationStatus
        | null;
      toStatus?:
        | EnumReservationStatusFilter<"StatusChange">
        | $Enums.ReservationStatus;
      reason?: StringNullableFilter<"StatusChange"> | string | null;
      changedBy?: StringNullableFilter<"StatusChange"> | string | null;
      changeAt?: DateTimeFilter<"StatusChange"> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      reservation?: XOR<ReservationScalarRelationFilter, ReservationWhereInput>;
    },
    "id"
  >;

  export type StatusChangeOrderByWithAggregationInput = {
    id?: SortOrder;
    reservationId?: SortOrder;
    fromStatus?: SortOrderInput | SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrderInput | SortOrder;
    changedBy?: SortOrderInput | SortOrder;
    changeAt?: SortOrder;
    _count?: StatusChangeCountOrderByAggregateInput;
    _max?: StatusChangeMaxOrderByAggregateInput;
    _min?: StatusChangeMinOrderByAggregateInput;
  };

  export type StatusChangeScalarWhereWithAggregatesInput = {
    AND?:
      | StatusChangeScalarWhereWithAggregatesInput
      | StatusChangeScalarWhereWithAggregatesInput[];
    OR?: StatusChangeScalarWhereWithAggregatesInput[];
    NOT?:
      | StatusChangeScalarWhereWithAggregatesInput
      | StatusChangeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"StatusChange"> | string;
    reservationId?: StringWithAggregatesFilter<"StatusChange"> | string;
    fromStatus?:
      | EnumReservationStatusNullableWithAggregatesFilter<"StatusChange">
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusWithAggregatesFilter<"StatusChange">
      | $Enums.ReservationStatus;
    reason?: StringNullableWithAggregatesFilter<"StatusChange"> | string | null;
    changedBy?:
      | StringNullableWithAggregatesFilter<"StatusChange">
      | string
      | null;
    changeAt?: DateTimeWithAggregatesFilter<"StatusChange"> | Date | string;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
    sessionToken?: StringFilter<"Session"> | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    sessionToken?: SortOrder;
    User?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<"Session"> | string;
      expires?: DateTimeFilter<"Session"> | Date | string;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "sessionToken"
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    sessionToken?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Session"> | string;
    userId?: StringWithAggregatesFilter<"Session"> | string;
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
    sessionToken?: StringWithAggregatesFilter<"Session"> | string;
  };

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    OR?: VerificationTokenWhereInput[];
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    identifier?: StringFilter<"VerificationToken"> | string;
    token?: StringFilter<"VerificationToken"> | string;
    expires?: DateTimeFilter<"VerificationToken"> | Date | string;
  };

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      token?: string;
      identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput;
      AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      OR?: VerificationTokenWhereInput[];
      NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      identifier?: StringFilter<"VerificationToken"> | string;
      expires?: DateTimeFilter<"VerificationToken"> | Date | string;
    },
    "token" | "identifier_token"
  >;

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _count?: VerificationTokenCountOrderByAggregateInput;
    _max?: VerificationTokenMaxOrderByAggregateInput;
    _min?: VerificationTokenMinOrderByAggregateInput;
  };

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    OR?: VerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string;
    token?: StringWithAggregatesFilter<"VerificationToken"> | string;
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string;
  };

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[];
    OR?: VehicleWhereInput[];
    NOT?: VehicleWhereInput | VehicleWhereInput[];
    id?: IntFilter<"Vehicle"> | number;
    make?: StringFilter<"Vehicle"> | string;
    model?: StringFilter<"Vehicle"> | string;
    category?: EnumVehicleCategoryFilter<"Vehicle"> | $Enums.VehicleCategory;
    year?: IntFilter<"Vehicle"> | number;
    color?: StringFilter<"Vehicle"> | string;
    transmission?:
      | EnumVehicleTransmissionFilter<"Vehicle">
      | $Enums.VehicleTransmission;
    fuel_type?: EnumVehicleFuelTypeFilter<"Vehicle"> | $Enums.VehicleFuelType;
    licensePlate?: StringFilter<"Vehicle"> | string;
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus;
    features?: StringNullableListFilter<"Vehicle">;
    dailyRate?: FloatFilter<"Vehicle"> | number;
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string;
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string;
    images?: ImageListRelationFilter;
    maintenanceBlocks?: MaintenanceBlockListRelationFilter;
    reservations?: ReservationListRelationFilter;
  };

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder;
    make?: SortOrder;
    model?: SortOrder;
    category?: SortOrder;
    year?: SortOrder;
    color?: SortOrder;
    transmission?: SortOrder;
    fuel_type?: SortOrder;
    licensePlate?: SortOrder;
    status?: SortOrder;
    features?: SortOrder;
    dailyRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    images?: ImageOrderByRelationAggregateInput;
    maintenanceBlocks?: MaintenanceBlockOrderByRelationAggregateInput;
    reservations?: ReservationOrderByRelationAggregateInput;
  };

  export type VehicleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number;
      licensePlate?: string;
      AND?: VehicleWhereInput | VehicleWhereInput[];
      OR?: VehicleWhereInput[];
      NOT?: VehicleWhereInput | VehicleWhereInput[];
      make?: StringFilter<"Vehicle"> | string;
      model?: StringFilter<"Vehicle"> | string;
      category?: EnumVehicleCategoryFilter<"Vehicle"> | $Enums.VehicleCategory;
      year?: IntFilter<"Vehicle"> | number;
      color?: StringFilter<"Vehicle"> | string;
      transmission?:
        | EnumVehicleTransmissionFilter<"Vehicle">
        | $Enums.VehicleTransmission;
      fuel_type?: EnumVehicleFuelTypeFilter<"Vehicle"> | $Enums.VehicleFuelType;
      status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus;
      features?: StringNullableListFilter<"Vehicle">;
      dailyRate?: FloatFilter<"Vehicle"> | number;
      createdAt?: DateTimeFilter<"Vehicle"> | Date | string;
      updatedAt?: DateTimeFilter<"Vehicle"> | Date | string;
      images?: ImageListRelationFilter;
      maintenanceBlocks?: MaintenanceBlockListRelationFilter;
      reservations?: ReservationListRelationFilter;
    },
    "id" | "licensePlate"
  >;

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder;
    make?: SortOrder;
    model?: SortOrder;
    category?: SortOrder;
    year?: SortOrder;
    color?: SortOrder;
    transmission?: SortOrder;
    fuel_type?: SortOrder;
    licensePlate?: SortOrder;
    status?: SortOrder;
    features?: SortOrder;
    dailyRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: VehicleCountOrderByAggregateInput;
    _avg?: VehicleAvgOrderByAggregateInput;
    _max?: VehicleMaxOrderByAggregateInput;
    _min?: VehicleMinOrderByAggregateInput;
    _sum?: VehicleSumOrderByAggregateInput;
  };

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?:
      | VehicleScalarWhereWithAggregatesInput
      | VehicleScalarWhereWithAggregatesInput[];
    OR?: VehicleScalarWhereWithAggregatesInput[];
    NOT?:
      | VehicleScalarWhereWithAggregatesInput
      | VehicleScalarWhereWithAggregatesInput[];
    id?: IntWithAggregatesFilter<"Vehicle"> | number;
    make?: StringWithAggregatesFilter<"Vehicle"> | string;
    model?: StringWithAggregatesFilter<"Vehicle"> | string;
    category?:
      | EnumVehicleCategoryWithAggregatesFilter<"Vehicle">
      | $Enums.VehicleCategory;
    year?: IntWithAggregatesFilter<"Vehicle"> | number;
    color?: StringWithAggregatesFilter<"Vehicle"> | string;
    transmission?:
      | EnumVehicleTransmissionWithAggregatesFilter<"Vehicle">
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeWithAggregatesFilter<"Vehicle">
      | $Enums.VehicleFuelType;
    licensePlate?: StringWithAggregatesFilter<"Vehicle"> | string;
    status?:
      | EnumVehicleStatusWithAggregatesFilter<"Vehicle">
      | $Enums.VehicleStatus;
    features?: StringNullableListFilter<"Vehicle">;
    dailyRate?: FloatWithAggregatesFilter<"Vehicle"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string;
  };

  export type MaintenanceBlockWhereInput = {
    AND?: MaintenanceBlockWhereInput | MaintenanceBlockWhereInput[];
    OR?: MaintenanceBlockWhereInput[];
    NOT?: MaintenanceBlockWhereInput | MaintenanceBlockWhereInput[];
    id?: StringFilter<"MaintenanceBlock"> | string;
    vehicleId?: IntFilter<"MaintenanceBlock"> | number;
    reason?: StringFilter<"MaintenanceBlock"> | string;
    startDate?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
    endDate?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
    createdAt?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
    updatedAt?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>;
  };

  export type MaintenanceBlockOrderByWithRelationInput = {
    id?: SortOrder;
    vehicleId?: SortOrder;
    reason?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    vehicle?: VehicleOrderByWithRelationInput;
  };

  export type MaintenanceBlockWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MaintenanceBlockWhereInput | MaintenanceBlockWhereInput[];
      OR?: MaintenanceBlockWhereInput[];
      NOT?: MaintenanceBlockWhereInput | MaintenanceBlockWhereInput[];
      vehicleId?: IntFilter<"MaintenanceBlock"> | number;
      reason?: StringFilter<"MaintenanceBlock"> | string;
      startDate?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
      endDate?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
      createdAt?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
      updatedAt?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
      vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>;
    },
    "id"
  >;

  export type MaintenanceBlockOrderByWithAggregationInput = {
    id?: SortOrder;
    vehicleId?: SortOrder;
    reason?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MaintenanceBlockCountOrderByAggregateInput;
    _avg?: MaintenanceBlockAvgOrderByAggregateInput;
    _max?: MaintenanceBlockMaxOrderByAggregateInput;
    _min?: MaintenanceBlockMinOrderByAggregateInput;
    _sum?: MaintenanceBlockSumOrderByAggregateInput;
  };

  export type MaintenanceBlockScalarWhereWithAggregatesInput = {
    AND?:
      | MaintenanceBlockScalarWhereWithAggregatesInput
      | MaintenanceBlockScalarWhereWithAggregatesInput[];
    OR?: MaintenanceBlockScalarWhereWithAggregatesInput[];
    NOT?:
      | MaintenanceBlockScalarWhereWithAggregatesInput
      | MaintenanceBlockScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"MaintenanceBlock"> | string;
    vehicleId?: IntWithAggregatesFilter<"MaintenanceBlock"> | number;
    reason?: StringWithAggregatesFilter<"MaintenanceBlock"> | string;
    startDate?:
      | DateTimeWithAggregatesFilter<"MaintenanceBlock">
      | Date
      | string;
    endDate?: DateTimeWithAggregatesFilter<"MaintenanceBlock"> | Date | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<"MaintenanceBlock">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"MaintenanceBlock">
      | Date
      | string;
  };

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[];
    OR?: PaymentWhereInput[];
    NOT?: PaymentWhereInput | PaymentWhereInput[];
    id?: StringFilter<"Payment"> | string;
    stripeSession?: StringFilter<"Payment"> | string;
    amount?:
      | DecimalFilter<"Payment">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus;
    intent_id?: StringNullableFilter<"Payment"> | string | null;
    reservationId?: StringFilter<"Payment"> | string;
    createdAt?: DateTimeFilter<"Payment"> | Date | string;
    updatedAt?: DateTimeFilter<"Payment"> | Date | string;
    reservation?: XOR<ReservationScalarRelationFilter, ReservationWhereInput>;
  };

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder;
    stripeSession?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    intent_id?: SortOrderInput | SortOrder;
    reservationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    reservation?: ReservationOrderByWithRelationInput;
  };

  export type PaymentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      stripeSession?: string;
      AND?: PaymentWhereInput | PaymentWhereInput[];
      OR?: PaymentWhereInput[];
      NOT?: PaymentWhereInput | PaymentWhereInput[];
      amount?:
        | DecimalFilter<"Payment">
        | Decimal
        | DecimalJsLike
        | number
        | string;
      status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus;
      intent_id?: StringNullableFilter<"Payment"> | string | null;
      reservationId?: StringFilter<"Payment"> | string;
      createdAt?: DateTimeFilter<"Payment"> | Date | string;
      updatedAt?: DateTimeFilter<"Payment"> | Date | string;
      reservation?: XOR<ReservationScalarRelationFilter, ReservationWhereInput>;
    },
    "id" | "stripeSession"
  >;

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder;
    stripeSession?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    intent_id?: SortOrderInput | SortOrder;
    reservationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PaymentCountOrderByAggregateInput;
    _avg?: PaymentAvgOrderByAggregateInput;
    _max?: PaymentMaxOrderByAggregateInput;
    _min?: PaymentMinOrderByAggregateInput;
    _sum?: PaymentSumOrderByAggregateInput;
  };

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?:
      | PaymentScalarWhereWithAggregatesInput
      | PaymentScalarWhereWithAggregatesInput[];
    OR?: PaymentScalarWhereWithAggregatesInput[];
    NOT?:
      | PaymentScalarWhereWithAggregatesInput
      | PaymentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Payment"> | string;
    stripeSession?: StringWithAggregatesFilter<"Payment"> | string;
    amount?:
      | DecimalWithAggregatesFilter<"Payment">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumPaymentStatusWithAggregatesFilter<"Payment">
      | $Enums.PaymentStatus;
    intent_id?: StringNullableWithAggregatesFilter<"Payment"> | string | null;
    reservationId?: StringWithAggregatesFilter<"Payment"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string;
  };

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[];
    OR?: DocumentWhereInput[];
    NOT?: DocumentWhereInput | DocumentWhereInput[];
    id?: StringFilter<"Document"> | string;
    name?: StringFilter<"Document"> | string;
    type?: StringFilter<"Document"> | string;
    url?: StringFilter<"Document"> | string;
    uploadedAt?: DateTimeFilter<"Document"> | Date | string;
    userId?: StringFilter<"Document"> | string;
    reservationId?: StringNullableFilter<"Document"> | string | null;
    Reservation?: XOR<
      ReservationNullableScalarRelationFilter,
      ReservationWhereInput
    > | null;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    userId?: SortOrder;
    reservationId?: SortOrderInput | SortOrder;
    Reservation?: ReservationOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
  };

  export type DocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DocumentWhereInput | DocumentWhereInput[];
      OR?: DocumentWhereInput[];
      NOT?: DocumentWhereInput | DocumentWhereInput[];
      name?: StringFilter<"Document"> | string;
      type?: StringFilter<"Document"> | string;
      url?: StringFilter<"Document"> | string;
      uploadedAt?: DateTimeFilter<"Document"> | Date | string;
      userId?: StringFilter<"Document"> | string;
      reservationId?: StringNullableFilter<"Document"> | string | null;
      Reservation?: XOR<
        ReservationNullableScalarRelationFilter,
        ReservationWhereInput
      > | null;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id"
  >;

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    userId?: SortOrder;
    reservationId?: SortOrderInput | SortOrder;
    _count?: DocumentCountOrderByAggregateInput;
    _max?: DocumentMaxOrderByAggregateInput;
    _min?: DocumentMinOrderByAggregateInput;
  };

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?:
      | DocumentScalarWhereWithAggregatesInput
      | DocumentScalarWhereWithAggregatesInput[];
    OR?: DocumentScalarWhereWithAggregatesInput[];
    NOT?:
      | DocumentScalarWhereWithAggregatesInput
      | DocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Document"> | string;
    name?: StringWithAggregatesFilter<"Document"> | string;
    type?: StringWithAggregatesFilter<"Document"> | string;
    url?: StringWithAggregatesFilter<"Document"> | string;
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string;
    userId?: StringWithAggregatesFilter<"Document"> | string;
    reservationId?:
      | StringNullableWithAggregatesFilter<"Document">
      | string
      | null;
  };

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[];
    OR?: ImageWhereInput[];
    NOT?: ImageWhereInput | ImageWhereInput[];
    id?: StringFilter<"Image"> | string;
    url?: StringFilter<"Image"> | string;
    uploadedAt?: DateTimeFilter<"Image"> | Date | string;
    position?: IntFilter<"Image"> | number;
    vehicleId?: IntNullableFilter<"Image"> | number | null;
    vehicle?: XOR<
      VehicleNullableScalarRelationFilter,
      VehicleWhereInput
    > | null;
  };

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    position?: SortOrder;
    vehicleId?: SortOrderInput | SortOrder;
    vehicle?: VehicleOrderByWithRelationInput;
  };

  export type ImageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ImageWhereInput | ImageWhereInput[];
      OR?: ImageWhereInput[];
      NOT?: ImageWhereInput | ImageWhereInput[];
      url?: StringFilter<"Image"> | string;
      uploadedAt?: DateTimeFilter<"Image"> | Date | string;
      position?: IntFilter<"Image"> | number;
      vehicleId?: IntNullableFilter<"Image"> | number | null;
      vehicle?: XOR<
        VehicleNullableScalarRelationFilter,
        VehicleWhereInput
      > | null;
    },
    "id"
  >;

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    position?: SortOrder;
    vehicleId?: SortOrderInput | SortOrder;
    _count?: ImageCountOrderByAggregateInput;
    _avg?: ImageAvgOrderByAggregateInput;
    _max?: ImageMaxOrderByAggregateInput;
    _min?: ImageMinOrderByAggregateInput;
    _sum?: ImageSumOrderByAggregateInput;
  };

  export type ImageScalarWhereWithAggregatesInput = {
    AND?:
      | ImageScalarWhereWithAggregatesInput
      | ImageScalarWhereWithAggregatesInput[];
    OR?: ImageScalarWhereWithAggregatesInput[];
    NOT?:
      | ImageScalarWhereWithAggregatesInput
      | ImageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Image"> | string;
    url?: StringWithAggregatesFilter<"Image"> | string;
    uploadedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string;
    position?: IntWithAggregatesFilter<"Image"> | number;
    vehicleId?: IntNullableWithAggregatesFilter<"Image"> | number | null;
  };

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
    OR?: PushSubscriptionWhereInput[];
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
    id?: StringFilter<"PushSubscription"> | string;
    endpoint?: StringFilter<"PushSubscription"> | string;
    keys?: JsonFilter<"PushSubscription">;
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string;
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string;
    userId?: StringFilter<"PushSubscription"> | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    keys?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    User?: UserOrderByWithRelationInput;
  };

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      endpoint?: string;
      AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
      OR?: PushSubscriptionWhereInput[];
      NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
      keys?: JsonFilter<"PushSubscription">;
      createdAt?: DateTimeFilter<"PushSubscription"> | Date | string;
      updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string;
      userId?: StringFilter<"PushSubscription"> | string;
      User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "endpoint"
  >;

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    keys?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    _count?: PushSubscriptionCountOrderByAggregateInput;
    _max?: PushSubscriptionMaxOrderByAggregateInput;
    _min?: PushSubscriptionMinOrderByAggregateInput;
  };

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?:
      | PushSubscriptionScalarWhereWithAggregatesInput
      | PushSubscriptionScalarWhereWithAggregatesInput[];
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[];
    NOT?:
      | PushSubscriptionScalarWhereWithAggregatesInput
      | PushSubscriptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"PushSubscription"> | string;
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string;
    keys?: JsonWithAggregatesFilter<"PushSubscription">;
    createdAt?:
      | DateTimeWithAggregatesFilter<"PushSubscription">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"PushSubscription">
      | Date
      | string;
    userId?: StringWithAggregatesFilter<"PushSubscription"> | string;
  };

  export type OnboardingWhereInput = {
    AND?: OnboardingWhereInput | OnboardingWhereInput[];
    OR?: OnboardingWhereInput[];
    NOT?: OnboardingWhereInput | OnboardingWhereInput[];
    id?: StringFilter<"Onboarding"> | string;
    userId?: StringFilter<"Onboarding"> | string;
    tour?: StringFilter<"Onboarding"> | string;
    completed?: BoolFilter<"Onboarding"> | boolean;
    createdAt?: DateTimeFilter<"Onboarding"> | Date | string;
    updatedAt?: DateTimeFilter<"Onboarding"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type OnboardingOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    tour?: SortOrder;
    completed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type OnboardingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      tour?: string;
      AND?: OnboardingWhereInput | OnboardingWhereInput[];
      OR?: OnboardingWhereInput[];
      NOT?: OnboardingWhereInput | OnboardingWhereInput[];
      userId?: StringFilter<"Onboarding"> | string;
      completed?: BoolFilter<"Onboarding"> | boolean;
      createdAt?: DateTimeFilter<"Onboarding"> | Date | string;
      updatedAt?: DateTimeFilter<"Onboarding"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "tour"
  >;

  export type OnboardingOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    tour?: SortOrder;
    completed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: OnboardingCountOrderByAggregateInput;
    _max?: OnboardingMaxOrderByAggregateInput;
    _min?: OnboardingMinOrderByAggregateInput;
  };

  export type OnboardingScalarWhereWithAggregatesInput = {
    AND?:
      | OnboardingScalarWhereWithAggregatesInput
      | OnboardingScalarWhereWithAggregatesInput[];
    OR?: OnboardingScalarWhereWithAggregatesInput[];
    NOT?:
      | OnboardingScalarWhereWithAggregatesInput
      | OnboardingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Onboarding"> | string;
    userId?: StringWithAggregatesFilter<"Onboarding"> | string;
    tour?: StringWithAggregatesFilter<"Onboarding"> | string;
    completed?: BoolWithAggregatesFilter<"Onboarding"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Onboarding"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Onboarding"> | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type PreferencesCreateInput = {
    id?: string;
    UserNotifications?: boolean;
    ReservationNotifications?: boolean;
    LeadNotifications?: boolean;
    ContactNotifications?: boolean;
    PaymentNotifications?: boolean;
    ReviewNotifications?: boolean;
    user: UserCreateNestedOneWithoutNotificationsPreferencesInput;
  };

  export type PreferencesUncheckedCreateInput = {
    id?: string;
    userId: string;
    UserNotifications?: boolean;
    ReservationNotifications?: boolean;
    LeadNotifications?: boolean;
    ContactNotifications?: boolean;
    PaymentNotifications?: boolean;
    ReviewNotifications?: boolean;
  };

  export type PreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    UserNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReservationNotifications?: BoolFieldUpdateOperationsInput | boolean;
    LeadNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ContactNotifications?: BoolFieldUpdateOperationsInput | boolean;
    PaymentNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReviewNotifications?: BoolFieldUpdateOperationsInput | boolean;
    user?: UserUpdateOneRequiredWithoutNotificationsPreferencesNestedInput;
  };

  export type PreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    UserNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReservationNotifications?: BoolFieldUpdateOperationsInput | boolean;
    LeadNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ContactNotifications?: BoolFieldUpdateOperationsInput | boolean;
    PaymentNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReviewNotifications?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type PreferencesCreateManyInput = {
    id?: string;
    userId: string;
    UserNotifications?: boolean;
    ReservationNotifications?: boolean;
    LeadNotifications?: boolean;
    ContactNotifications?: boolean;
    PaymentNotifications?: boolean;
    ReviewNotifications?: boolean;
  };

  export type PreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    UserNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReservationNotifications?: BoolFieldUpdateOperationsInput | boolean;
    LeadNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ContactNotifications?: BoolFieldUpdateOperationsInput | boolean;
    PaymentNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReviewNotifications?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type PreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    UserNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReservationNotifications?: BoolFieldUpdateOperationsInput | boolean;
    LeadNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ContactNotifications?: BoolFieldUpdateOperationsInput | boolean;
    PaymentNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReviewNotifications?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AccountCreateInput = {
    type: string;
    provider: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    providerAccountId: string;
    user: UserCreateNestedOneWithoutAccountInput;
  };

  export type AccountUncheckedCreateInput = {
    id?: number;
    userId: string;
    type: string;
    provider: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    providerAccountId: string;
  };

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    user?: UserUpdateOneRequiredWithoutAccountNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type AccountCreateManyInput = {
    id?: number;
    userId: string;
    type: string;
    provider: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    providerAccountId: string;
  };

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type ReservationCreateInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentCreateNestedManyWithoutReservationInput;
    payments?: PaymentCreateNestedManyWithoutReservationInput;
    user: UserCreateNestedOneWithoutReservationInput;
    vehicle?: VehicleCreateNestedOneWithoutReservationsInput;
    statusHistory?: StatusChangeCreateNestedManyWithoutReservationInput;
  };

  export type ReservationUncheckedCreateInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    vehicleId?: number | null;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentUncheckedCreateNestedManyWithoutReservationInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput;
    statusHistory?: StatusChangeUncheckedCreateNestedManyWithoutReservationInput;
  };

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUpdateManyWithoutReservationNestedInput;
    user?: UserUpdateOneRequiredWithoutReservationNestedInput;
    vehicle?: VehicleUpdateOneWithoutReservationsNestedInput;
    statusHistory?: StatusChangeUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUncheckedUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput;
    statusHistory?: StatusChangeUncheckedUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationCreateManyInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    vehicleId?: number | null;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DraftReservationCreateInput = {
    id?: string;
    name: string;
    email: string;
    phone: string;
    vehicleId?: number | null;
    message?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dropoffDate: string;
    dropoffHour: string;
    dropoffLocation: string;
    pickupDate: string;
    pickupHour: string;
    pickupLocation: string;
  };

  export type DraftReservationUncheckedCreateInput = {
    id?: string;
    name: string;
    email: string;
    phone: string;
    vehicleId?: number | null;
    message?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dropoffDate: string;
    dropoffHour: string;
    dropoffLocation: string;
    pickupDate: string;
    pickupHour: string;
    pickupLocation: string;
  };

  export type DraftReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupDate?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
  };

  export type DraftReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupDate?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
  };

  export type DraftReservationCreateManyInput = {
    id?: string;
    name: string;
    email: string;
    phone: string;
    vehicleId?: number | null;
    message?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dropoffDate: string;
    dropoffHour: string;
    dropoffLocation: string;
    pickupDate: string;
    pickupHour: string;
    pickupLocation: string;
  };

  export type DraftReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupDate?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
  };

  export type DraftReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: StringFieldUpdateOperationsInput | string;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupDate?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
  };

  export type StatusChangeCreateInput = {
    id?: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changeAt?: Date | string;
    user?: UserCreateNestedOneWithoutStatusChangeInput;
    reservation: ReservationCreateNestedOneWithoutStatusHistoryInput;
  };

  export type StatusChangeUncheckedCreateInput = {
    id?: string;
    reservationId: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changedBy?: string | null;
    changeAt?: Date | string;
  };

  export type StatusChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutStatusChangeNestedInput;
    reservation?: ReservationUpdateOneRequiredWithoutStatusHistoryNestedInput;
  };

  export type StatusChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reservationId?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StatusChangeCreateManyInput = {
    id?: string;
    reservationId: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changedBy?: string | null;
    changeAt?: Date | string;
  };

  export type StatusChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StatusChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reservationId?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateInput = {
    id: string;
    expires: Date | string;
    sessionToken: string;
    User: UserCreateNestedOneWithoutSessionInput;
  };

  export type SessionUncheckedCreateInput = {
    id: string;
    userId: string;
    expires: Date | string;
    sessionToken: string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    User?: UserUpdateOneRequiredWithoutSessionNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
  };

  export type SessionCreateManyInput = {
    id: string;
    userId: string;
    expires: Date | string;
    sessionToken: string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
  };

  export type VerificationTokenCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateManyInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VehicleCreateInput = {
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ImageCreateNestedManyWithoutVehicleInput;
    maintenanceBlocks?: MaintenanceBlockCreateNestedManyWithoutVehicleInput;
    reservations?: ReservationCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleUncheckedCreateInput = {
    id?: number;
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ImageUncheckedCreateNestedManyWithoutVehicleInput;
    maintenanceBlocks?: MaintenanceBlockUncheckedCreateNestedManyWithoutVehicleInput;
    reservations?: ReservationUncheckedCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleUpdateInput = {
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ImageUpdateManyWithoutVehicleNestedInput;
    maintenanceBlocks?: MaintenanceBlockUpdateManyWithoutVehicleNestedInput;
    reservations?: ReservationUpdateManyWithoutVehicleNestedInput;
  };

  export type VehicleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number;
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ImageUncheckedUpdateManyWithoutVehicleNestedInput;
    maintenanceBlocks?: MaintenanceBlockUncheckedUpdateManyWithoutVehicleNestedInput;
    reservations?: ReservationUncheckedUpdateManyWithoutVehicleNestedInput;
  };

  export type VehicleCreateManyInput = {
    id?: number;
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type VehicleUpdateManyMutationInput = {
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VehicleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number;
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MaintenanceBlockCreateInput = {
    id?: string;
    reason: string;
    startDate: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    vehicle: VehicleCreateNestedOneWithoutMaintenanceBlocksInput;
  };

  export type MaintenanceBlockUncheckedCreateInput = {
    id?: string;
    vehicleId: number;
    reason: string;
    startDate: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MaintenanceBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    vehicle?: VehicleUpdateOneRequiredWithoutMaintenanceBlocksNestedInput;
  };

  export type MaintenanceBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    vehicleId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MaintenanceBlockCreateManyInput = {
    id?: string;
    vehicleId: number;
    reason: string;
    startDate: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MaintenanceBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MaintenanceBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    vehicleId?: IntFieldUpdateOperationsInput | number;
    reason?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentCreateInput = {
    id?: string;
    stripeSession: string;
    amount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.PaymentStatus;
    intent_id?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    reservation: ReservationCreateNestedOneWithoutPaymentsInput;
  };

  export type PaymentUncheckedCreateInput = {
    id?: string;
    stripeSession: string;
    amount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.PaymentStatus;
    intent_id?: string | null;
    reservationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    stripeSession?: StringFieldUpdateOperationsInput | string;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    intent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reservation?: ReservationUpdateOneRequiredWithoutPaymentsNestedInput;
  };

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    stripeSession?: StringFieldUpdateOperationsInput | string;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    intent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    reservationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentCreateManyInput = {
    id?: string;
    stripeSession: string;
    amount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.PaymentStatus;
    intent_id?: string | null;
    reservationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    stripeSession?: StringFieldUpdateOperationsInput | string;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    intent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    stripeSession?: StringFieldUpdateOperationsInput | string;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    intent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    reservationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    Reservation?: ReservationCreateNestedOneWithoutContractsInput;
    User: UserCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    userId: string;
    reservationId?: string | null;
  };

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Reservation?: ReservationUpdateOneWithoutContractsNestedInput;
    User?: UserUpdateOneRequiredWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DocumentCreateManyInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    userId: string;
    reservationId?: string | null;
  };

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ImageCreateInput = {
    id?: string;
    url: string;
    uploadedAt?: Date | string;
    position: number;
    vehicle?: VehicleCreateNestedOneWithoutImagesInput;
  };

  export type ImageUncheckedCreateInput = {
    id?: string;
    url: string;
    uploadedAt?: Date | string;
    position: number;
    vehicleId?: number | null;
  };

  export type ImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    position?: IntFieldUpdateOperationsInput | number;
    vehicle?: VehicleUpdateOneWithoutImagesNestedInput;
  };

  export type ImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    position?: IntFieldUpdateOperationsInput | number;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type ImageCreateManyInput = {
    id?: string;
    url: string;
    uploadedAt?: Date | string;
    position: number;
    vehicleId?: number | null;
  };

  export type ImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type ImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    position?: IntFieldUpdateOperationsInput | number;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
  };

  export type PushSubscriptionCreateInput = {
    id?: string;
    endpoint: string;
    keys: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutPushSubscriptionInput;
  };

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string;
    endpoint: string;
    keys: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
  };

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    keys?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutPushSubscriptionNestedInput;
  };

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    keys?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type PushSubscriptionCreateManyInput = {
    id?: string;
    endpoint: string;
    keys: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
  };

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    keys?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    keys?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type OnboardingCreateInput = {
    id?: string;
    tour?: string;
    completed?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutOnboardingInput;
  };

  export type OnboardingUncheckedCreateInput = {
    id?: string;
    userId: string;
    tour?: string;
    completed?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OnboardingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tour?: StringFieldUpdateOperationsInput | string;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutOnboardingNestedInput;
  };

  export type OnboardingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    tour?: StringFieldUpdateOperationsInput | string;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OnboardingCreateManyInput = {
    id?: string;
    userId: string;
    tour?: string;
    completed?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OnboardingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tour?: StringFieldUpdateOperationsInput | string;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OnboardingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    tour?: StringFieldUpdateOperationsInput | string;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput;
    some?: DocumentWhereInput;
    none?: DocumentWhereInput;
  };

  export type OnboardingListRelationFilter = {
    every?: OnboardingWhereInput;
    some?: OnboardingWhereInput;
    none?: OnboardingWhereInput;
  };

  export type PreferencesNullableScalarRelationFilter = {
    is?: PreferencesWhereInput | null;
    isNot?: PreferencesWhereInput | null;
  };

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput;
    some?: PushSubscriptionWhereInput;
    none?: PushSubscriptionWhereInput;
  };

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput;
    some?: ReservationWhereInput;
    none?: ReservationWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type StatusChangeListRelationFilter = {
    every?: StatusChangeWhereInput;
    some?: StatusChangeWhereInput;
    none?: StatusChangeWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OnboardingOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type StatusChangeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    phone?: SortOrder;
    isAdmin?: SortOrder;
    isVerified?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    phone?: SortOrder;
    isAdmin?: SortOrder;
    isVerified?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    phone?: SortOrder;
    isAdmin?: SortOrder;
    isVerified?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type PreferencesCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    UserNotifications?: SortOrder;
    ReservationNotifications?: SortOrder;
    LeadNotifications?: SortOrder;
    ContactNotifications?: SortOrder;
    PaymentNotifications?: SortOrder;
    ReviewNotifications?: SortOrder;
  };

  export type PreferencesMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    UserNotifications?: SortOrder;
    ReservationNotifications?: SortOrder;
    LeadNotifications?: SortOrder;
    ContactNotifications?: SortOrder;
    PaymentNotifications?: SortOrder;
    ReviewNotifications?: SortOrder;
  };

  export type PreferencesMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    UserNotifications?: SortOrder;
    ReservationNotifications?: SortOrder;
    LeadNotifications?: SortOrder;
    ContactNotifications?: SortOrder;
    PaymentNotifications?: SortOrder;
    ReviewNotifications?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
    providerAccountId?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder;
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
    providerAccountId?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
    providerAccountId?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder;
    expires_at?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type EnumReservationStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ReservationStatus
      | EnumReservationStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumReservationStatusFilter<$PrismaModel>
      | $Enums.ReservationStatus;
  };

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput;
    some?: PaymentWhereInput;
    none?: PaymentWhereInput;
  };

  export type VehicleNullableScalarRelationFilter = {
    is?: VehicleWhereInput | null;
    isNot?: VehicleWhereInput | null;
  };

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder;
    pickupDate?: SortOrder;
    dropoffDate?: SortOrder;
    pickupLocation?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupHour?: SortOrder;
    dropoffHour?: SortOrder;
    dailyRate?: SortOrder;
    totalDays?: SortOrder;
    subtotal?: SortOrder;
    tax?: SortOrder;
    totalAmount?: SortOrder;
    amountPaid?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    notes?: SortOrder;
    specialRequests?: SortOrder;
    vehicleId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReservationAvgOrderByAggregateInput = {
    dailyRate?: SortOrder;
    totalDays?: SortOrder;
    subtotal?: SortOrder;
    tax?: SortOrder;
    totalAmount?: SortOrder;
    amountPaid?: SortOrder;
    vehicleId?: SortOrder;
  };

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder;
    pickupDate?: SortOrder;
    dropoffDate?: SortOrder;
    pickupLocation?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupHour?: SortOrder;
    dropoffHour?: SortOrder;
    dailyRate?: SortOrder;
    totalDays?: SortOrder;
    subtotal?: SortOrder;
    tax?: SortOrder;
    totalAmount?: SortOrder;
    amountPaid?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    notes?: SortOrder;
    specialRequests?: SortOrder;
    vehicleId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder;
    pickupDate?: SortOrder;
    dropoffDate?: SortOrder;
    pickupLocation?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupHour?: SortOrder;
    dropoffHour?: SortOrder;
    dailyRate?: SortOrder;
    totalDays?: SortOrder;
    subtotal?: SortOrder;
    tax?: SortOrder;
    totalAmount?: SortOrder;
    amountPaid?: SortOrder;
    status?: SortOrder;
    paymentStatus?: SortOrder;
    notes?: SortOrder;
    specialRequests?: SortOrder;
    vehicleId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReservationSumOrderByAggregateInput = {
    dailyRate?: SortOrder;
    totalDays?: SortOrder;
    subtotal?: SortOrder;
    tax?: SortOrder;
    totalAmount?: SortOrder;
    amountPaid?: SortOrder;
    vehicleId?: SortOrder;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type EnumReservationStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.ReservationStatus
        | EnumReservationStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.ReservationStatus[]
        | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.ReservationStatus[]
        | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.ReservationStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumReservationStatusFilter<$PrismaModel>;
      _max?: NestedEnumReservationStatusFilter<$PrismaModel>;
    };

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type DraftReservationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    vehicleId?: SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dropoffDate?: SortOrder;
    dropoffHour?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupDate?: SortOrder;
    pickupHour?: SortOrder;
    pickupLocation?: SortOrder;
  };

  export type DraftReservationAvgOrderByAggregateInput = {
    vehicleId?: SortOrder;
  };

  export type DraftReservationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    vehicleId?: SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dropoffDate?: SortOrder;
    dropoffHour?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupDate?: SortOrder;
    pickupHour?: SortOrder;
    pickupLocation?: SortOrder;
  };

  export type DraftReservationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    vehicleId?: SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dropoffDate?: SortOrder;
    dropoffHour?: SortOrder;
    dropoffLocation?: SortOrder;
    pickupDate?: SortOrder;
    pickupHour?: SortOrder;
    pickupLocation?: SortOrder;
  };

  export type DraftReservationSumOrderByAggregateInput = {
    vehicleId?: SortOrder;
  };

  export type EnumReservationStatusNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ReservationStatus
      | EnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumReservationStatusNullableFilter<$PrismaModel>
      | $Enums.ReservationStatus
      | null;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type ReservationScalarRelationFilter = {
    is?: ReservationWhereInput;
    isNot?: ReservationWhereInput;
  };

  export type StatusChangeCountOrderByAggregateInput = {
    id?: SortOrder;
    reservationId?: SortOrder;
    fromStatus?: SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrder;
    changedBy?: SortOrder;
    changeAt?: SortOrder;
  };

  export type StatusChangeMaxOrderByAggregateInput = {
    id?: SortOrder;
    reservationId?: SortOrder;
    fromStatus?: SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrder;
    changedBy?: SortOrder;
    changeAt?: SortOrder;
  };

  export type StatusChangeMinOrderByAggregateInput = {
    id?: SortOrder;
    reservationId?: SortOrder;
    fromStatus?: SortOrder;
    toStatus?: SortOrder;
    reason?: SortOrder;
    changedBy?: SortOrder;
    changeAt?: SortOrder;
  };

  export type EnumReservationStatusNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ReservationStatus
      | EnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumReservationStatusNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.ReservationStatus
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumReservationStatusNullableFilter<$PrismaModel>;
    _max?: NestedEnumReservationStatusNullableFilter<$PrismaModel>;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    sessionToken?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    sessionToken?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    sessionToken?: SortOrder;
  };

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string;
    token: string;
  };

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type EnumVehicleCategoryFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleCategory
      | EnumVehicleCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleCategoryFilter<$PrismaModel>
      | $Enums.VehicleCategory;
  };

  export type EnumVehicleTransmissionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleTransmission
      | EnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleTransmissionFilter<$PrismaModel>
      | $Enums.VehicleTransmission;
  };

  export type EnumVehicleFuelTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleFuelType
      | EnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleFuelTypeFilter<$PrismaModel>
      | $Enums.VehicleFuelType;
  };

  export type EnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleStatus
      | EnumVehicleStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type ImageListRelationFilter = {
    every?: ImageWhereInput;
    some?: ImageWhereInput;
    none?: ImageWhereInput;
  };

  export type MaintenanceBlockListRelationFilter = {
    every?: MaintenanceBlockWhereInput;
    some?: MaintenanceBlockWhereInput;
    none?: MaintenanceBlockWhereInput;
  };

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MaintenanceBlockOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder;
    make?: SortOrder;
    model?: SortOrder;
    category?: SortOrder;
    year?: SortOrder;
    color?: SortOrder;
    transmission?: SortOrder;
    fuel_type?: SortOrder;
    licensePlate?: SortOrder;
    status?: SortOrder;
    features?: SortOrder;
    dailyRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VehicleAvgOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    dailyRate?: SortOrder;
  };

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder;
    make?: SortOrder;
    model?: SortOrder;
    category?: SortOrder;
    year?: SortOrder;
    color?: SortOrder;
    transmission?: SortOrder;
    fuel_type?: SortOrder;
    licensePlate?: SortOrder;
    status?: SortOrder;
    dailyRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder;
    make?: SortOrder;
    model?: SortOrder;
    category?: SortOrder;
    year?: SortOrder;
    color?: SortOrder;
    transmission?: SortOrder;
    fuel_type?: SortOrder;
    licensePlate?: SortOrder;
    status?: SortOrder;
    dailyRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VehicleSumOrderByAggregateInput = {
    id?: SortOrder;
    year?: SortOrder;
    dailyRate?: SortOrder;
  };

  export type EnumVehicleCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleCategory
      | EnumVehicleCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleCategoryWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleCategory;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleCategoryFilter<$PrismaModel>;
    _max?: NestedEnumVehicleCategoryFilter<$PrismaModel>;
  };

  export type EnumVehicleTransmissionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.VehicleTransmission
      | EnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleTransmissionWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleTransmission;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleTransmissionFilter<$PrismaModel>;
    _max?: NestedEnumVehicleTransmissionFilter<$PrismaModel>;
  };

  export type EnumVehicleFuelTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleFuelType
      | EnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleFuelTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleFuelType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleFuelTypeFilter<$PrismaModel>;
    _max?: NestedEnumVehicleFuelTypeFilter<$PrismaModel>;
  };

  export type EnumVehicleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleStatus
      | EnumVehicleStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>;
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type VehicleScalarRelationFilter = {
    is?: VehicleWhereInput;
    isNot?: VehicleWhereInput;
  };

  export type MaintenanceBlockCountOrderByAggregateInput = {
    id?: SortOrder;
    vehicleId?: SortOrder;
    reason?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MaintenanceBlockAvgOrderByAggregateInput = {
    vehicleId?: SortOrder;
  };

  export type MaintenanceBlockMaxOrderByAggregateInput = {
    id?: SortOrder;
    vehicleId?: SortOrder;
    reason?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MaintenanceBlockMinOrderByAggregateInput = {
    id?: SortOrder;
    vehicleId?: SortOrder;
    reason?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MaintenanceBlockSumOrderByAggregateInput = {
    vehicleId?: SortOrder;
  };

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder;
    stripeSession?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    intent_id?: SortOrder;
    reservationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder;
    stripeSession?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    intent_id?: SortOrder;
    reservationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder;
    stripeSession?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    intent_id?: SortOrder;
    reservationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type ReservationNullableScalarRelationFilter = {
    is?: ReservationWhereInput | null;
    isNot?: ReservationWhereInput | null;
  };

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    userId?: SortOrder;
    reservationId?: SortOrder;
  };

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    userId?: SortOrder;
    reservationId?: SortOrder;
  };

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    type?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    userId?: SortOrder;
    reservationId?: SortOrder;
  };

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    position?: SortOrder;
    vehicleId?: SortOrder;
  };

  export type ImageAvgOrderByAggregateInput = {
    position?: SortOrder;
    vehicleId?: SortOrder;
  };

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    position?: SortOrder;
    vehicleId?: SortOrder;
  };

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder;
    url?: SortOrder;
    uploadedAt?: SortOrder;
    position?: SortOrder;
    vehicleId?: SortOrder;
  };

  export type ImageSumOrderByAggregateInput = {
    position?: SortOrder;
    vehicleId?: SortOrder;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, "path">>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    keys?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
  };

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
  };

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder;
    endpoint?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type OnboardingCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    tour?: SortOrder;
    completed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OnboardingMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    tour?: SortOrder;
    completed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OnboardingMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    tour?: SortOrder;
    completed?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          DocumentCreateWithoutUserInput,
          DocumentUncheckedCreateWithoutUserInput
        >
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type OnboardingCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          OnboardingCreateWithoutUserInput,
          OnboardingUncheckedCreateWithoutUserInput
        >
      | OnboardingCreateWithoutUserInput[]
      | OnboardingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OnboardingCreateOrConnectWithoutUserInput
      | OnboardingCreateOrConnectWithoutUserInput[];
    createMany?: OnboardingCreateManyUserInputEnvelope;
    connect?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
  };

  export type PreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<
      PreferencesCreateWithoutUserInput,
      PreferencesUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput;
    connect?: PreferencesWhereUniqueInput;
  };

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
  };

  export type ReservationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ReservationCreateWithoutUserInput,
          ReservationUncheckedCreateWithoutUserInput
        >
      | ReservationCreateWithoutUserInput[]
      | ReservationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutUserInput
      | ReservationCreateOrConnectWithoutUserInput[];
    createMany?: ReservationCreateManyUserInputEnvelope;
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type StatusChangeCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutUserInput,
          StatusChangeUncheckedCreateWithoutUserInput
        >
      | StatusChangeCreateWithoutUserInput[]
      | StatusChangeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutUserInput
      | StatusChangeCreateOrConnectWithoutUserInput[];
    createMany?: StatusChangeCreateManyUserInputEnvelope;
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          DocumentCreateWithoutUserInput,
          DocumentUncheckedCreateWithoutUserInput
        >
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type OnboardingUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          OnboardingCreateWithoutUserInput,
          OnboardingUncheckedCreateWithoutUserInput
        >
      | OnboardingCreateWithoutUserInput[]
      | OnboardingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OnboardingCreateOrConnectWithoutUserInput
      | OnboardingCreateOrConnectWithoutUserInput[];
    createMany?: OnboardingCreateManyUserInputEnvelope;
    connect?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
  };

  export type PreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      PreferencesCreateWithoutUserInput,
      PreferencesUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput;
    connect?: PreferencesWhereUniqueInput;
  };

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
  };

  export type ReservationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ReservationCreateWithoutUserInput,
          ReservationUncheckedCreateWithoutUserInput
        >
      | ReservationCreateWithoutUserInput[]
      | ReservationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutUserInput
      | ReservationCreateOrConnectWithoutUserInput[];
    createMany?: ReservationCreateManyUserInputEnvelope;
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type StatusChangeUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutUserInput,
          StatusChangeUncheckedCreateWithoutUserInput
        >
      | StatusChangeCreateWithoutUserInput[]
      | StatusChangeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutUserInput
      | StatusChangeCreateOrConnectWithoutUserInput[];
    createMany?: StatusChangeCreateManyUserInputEnvelope;
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          DocumentCreateWithoutUserInput,
          DocumentUncheckedCreateWithoutUserInput
        >
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutUserInput
      | DocumentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutUserInput
      | DocumentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutUserInput
      | DocumentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type OnboardingUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          OnboardingCreateWithoutUserInput,
          OnboardingUncheckedCreateWithoutUserInput
        >
      | OnboardingCreateWithoutUserInput[]
      | OnboardingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OnboardingCreateOrConnectWithoutUserInput
      | OnboardingCreateOrConnectWithoutUserInput[];
    upsert?:
      | OnboardingUpsertWithWhereUniqueWithoutUserInput
      | OnboardingUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OnboardingCreateManyUserInputEnvelope;
    set?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    disconnect?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    delete?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    connect?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    update?:
      | OnboardingUpdateWithWhereUniqueWithoutUserInput
      | OnboardingUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OnboardingUpdateManyWithWhereWithoutUserInput
      | OnboardingUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OnboardingScalarWhereInput | OnboardingScalarWhereInput[];
  };

  export type PreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      PreferencesCreateWithoutUserInput,
      PreferencesUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput;
    upsert?: PreferencesUpsertWithoutUserInput;
    disconnect?: PreferencesWhereInput | boolean;
    delete?: PreferencesWhereInput | boolean;
    connect?: PreferencesWhereUniqueInput;
    update?: XOR<
      XOR<
        PreferencesUpdateToOneWithWhereWithoutUserInput,
        PreferencesUpdateWithoutUserInput
      >,
      PreferencesUncheckedUpdateWithoutUserInput
    >;
  };

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    upsert?:
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[];
    disconnect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    delete?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    update?:
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PushSubscriptionScalarWhereInput
      | PushSubscriptionScalarWhereInput[];
  };

  export type ReservationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ReservationCreateWithoutUserInput,
          ReservationUncheckedCreateWithoutUserInput
        >
      | ReservationCreateWithoutUserInput[]
      | ReservationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutUserInput
      | ReservationCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReservationUpsertWithWhereUniqueWithoutUserInput
      | ReservationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReservationCreateManyUserInputEnvelope;
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    update?:
      | ReservationUpdateWithWhereUniqueWithoutUserInput
      | ReservationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReservationUpdateManyWithWhereWithoutUserInput
      | ReservationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type StatusChangeUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutUserInput,
          StatusChangeUncheckedCreateWithoutUserInput
        >
      | StatusChangeCreateWithoutUserInput[]
      | StatusChangeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutUserInput
      | StatusChangeCreateOrConnectWithoutUserInput[];
    upsert?:
      | StatusChangeUpsertWithWhereUniqueWithoutUserInput
      | StatusChangeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: StatusChangeCreateManyUserInputEnvelope;
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    update?:
      | StatusChangeUpdateWithWhereUniqueWithoutUserInput
      | StatusChangeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | StatusChangeUpdateManyWithWhereWithoutUserInput
      | StatusChangeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          DocumentCreateWithoutUserInput,
          DocumentUncheckedCreateWithoutUserInput
        >
      | DocumentCreateWithoutUserInput[]
      | DocumentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutUserInput
      | DocumentCreateOrConnectWithoutUserInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutUserInput
      | DocumentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DocumentCreateManyUserInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutUserInput
      | DocumentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutUserInput
      | DocumentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type OnboardingUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          OnboardingCreateWithoutUserInput,
          OnboardingUncheckedCreateWithoutUserInput
        >
      | OnboardingCreateWithoutUserInput[]
      | OnboardingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OnboardingCreateOrConnectWithoutUserInput
      | OnboardingCreateOrConnectWithoutUserInput[];
    upsert?:
      | OnboardingUpsertWithWhereUniqueWithoutUserInput
      | OnboardingUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OnboardingCreateManyUserInputEnvelope;
    set?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    disconnect?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    delete?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    connect?: OnboardingWhereUniqueInput | OnboardingWhereUniqueInput[];
    update?:
      | OnboardingUpdateWithWhereUniqueWithoutUserInput
      | OnboardingUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OnboardingUpdateManyWithWhereWithoutUserInput
      | OnboardingUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OnboardingScalarWhereInput | OnboardingScalarWhereInput[];
  };

  export type PreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      PreferencesCreateWithoutUserInput,
      PreferencesUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PreferencesCreateOrConnectWithoutUserInput;
    upsert?: PreferencesUpsertWithoutUserInput;
    disconnect?: PreferencesWhereInput | boolean;
    delete?: PreferencesWhereInput | boolean;
    connect?: PreferencesWhereUniqueInput;
    update?: XOR<
      XOR<
        PreferencesUpdateToOneWithWhereWithoutUserInput,
        PreferencesUpdateWithoutUserInput
      >,
      PreferencesUncheckedUpdateWithoutUserInput
    >;
  };

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    upsert?:
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[];
    disconnect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    delete?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    update?:
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PushSubscriptionScalarWhereInput
      | PushSubscriptionScalarWhereInput[];
  };

  export type ReservationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ReservationCreateWithoutUserInput,
          ReservationUncheckedCreateWithoutUserInput
        >
      | ReservationCreateWithoutUserInput[]
      | ReservationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutUserInput
      | ReservationCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReservationUpsertWithWhereUniqueWithoutUserInput
      | ReservationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReservationCreateManyUserInputEnvelope;
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    update?:
      | ReservationUpdateWithWhereUniqueWithoutUserInput
      | ReservationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReservationUpdateManyWithWhereWithoutUserInput
      | ReservationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type StatusChangeUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutUserInput,
          StatusChangeUncheckedCreateWithoutUserInput
        >
      | StatusChangeCreateWithoutUserInput[]
      | StatusChangeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutUserInput
      | StatusChangeCreateOrConnectWithoutUserInput[];
    upsert?:
      | StatusChangeUpsertWithWhereUniqueWithoutUserInput
      | StatusChangeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: StatusChangeCreateManyUserInputEnvelope;
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    update?:
      | StatusChangeUpdateWithWhereUniqueWithoutUserInput
      | StatusChangeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | StatusChangeUpdateManyWithWhereWithoutUserInput
      | StatusChangeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutNotificationsPreferencesInput = {
    create?: XOR<
      UserCreateWithoutNotificationsPreferencesInput,
      UserUncheckedCreateWithoutNotificationsPreferencesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsPreferencesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutNotificationsPreferencesNestedInput =
    {
      create?: XOR<
        UserCreateWithoutNotificationsPreferencesInput,
        UserUncheckedCreateWithoutNotificationsPreferencesInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutNotificationsPreferencesInput;
      upsert?: UserUpsertWithoutNotificationsPreferencesInput;
      connect?: UserWhereUniqueInput;
      update?: XOR<
        XOR<
          UserUpdateToOneWithWhereWithoutNotificationsPreferencesInput,
          UserUpdateWithoutNotificationsPreferencesInput
        >,
        UserUncheckedUpdateWithoutNotificationsPreferencesInput
      >;
    };

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<
      UserCreateWithoutAccountInput,
      UserUncheckedCreateWithoutAccountInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<
      UserCreateWithoutAccountInput,
      UserUncheckedCreateWithoutAccountInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput;
    upsert?: UserUpsertWithoutAccountInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAccountInput,
        UserUpdateWithoutAccountInput
      >,
      UserUncheckedUpdateWithoutAccountInput
    >;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type DocumentCreateNestedManyWithoutReservationInput = {
    create?:
      | XOR<
          DocumentCreateWithoutReservationInput,
          DocumentUncheckedCreateWithoutReservationInput
        >
      | DocumentCreateWithoutReservationInput[]
      | DocumentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutReservationInput
      | DocumentCreateOrConnectWithoutReservationInput[];
    createMany?: DocumentCreateManyReservationInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type PaymentCreateNestedManyWithoutReservationInput = {
    create?:
      | XOR<
          PaymentCreateWithoutReservationInput,
          PaymentUncheckedCreateWithoutReservationInput
        >
      | PaymentCreateWithoutReservationInput[]
      | PaymentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutReservationInput
      | PaymentCreateOrConnectWithoutReservationInput[];
    createMany?: PaymentCreateManyReservationInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type UserCreateNestedOneWithoutReservationInput = {
    create?: XOR<
      UserCreateWithoutReservationInput,
      UserUncheckedCreateWithoutReservationInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReservationInput;
    connect?: UserWhereUniqueInput;
  };

  export type VehicleCreateNestedOneWithoutReservationsInput = {
    create?: XOR<
      VehicleCreateWithoutReservationsInput,
      VehicleUncheckedCreateWithoutReservationsInput
    >;
    connectOrCreate?: VehicleCreateOrConnectWithoutReservationsInput;
    connect?: VehicleWhereUniqueInput;
  };

  export type StatusChangeCreateNestedManyWithoutReservationInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutReservationInput,
          StatusChangeUncheckedCreateWithoutReservationInput
        >
      | StatusChangeCreateWithoutReservationInput[]
      | StatusChangeUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutReservationInput
      | StatusChangeCreateOrConnectWithoutReservationInput[];
    createMany?: StatusChangeCreateManyReservationInputEnvelope;
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
  };

  export type DocumentUncheckedCreateNestedManyWithoutReservationInput = {
    create?:
      | XOR<
          DocumentCreateWithoutReservationInput,
          DocumentUncheckedCreateWithoutReservationInput
        >
      | DocumentCreateWithoutReservationInput[]
      | DocumentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutReservationInput
      | DocumentCreateOrConnectWithoutReservationInput[];
    createMany?: DocumentCreateManyReservationInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type PaymentUncheckedCreateNestedManyWithoutReservationInput = {
    create?:
      | XOR<
          PaymentCreateWithoutReservationInput,
          PaymentUncheckedCreateWithoutReservationInput
        >
      | PaymentCreateWithoutReservationInput[]
      | PaymentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutReservationInput
      | PaymentCreateOrConnectWithoutReservationInput[];
    createMany?: PaymentCreateManyReservationInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type StatusChangeUncheckedCreateNestedManyWithoutReservationInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutReservationInput,
          StatusChangeUncheckedCreateWithoutReservationInput
        >
      | StatusChangeCreateWithoutReservationInput[]
      | StatusChangeUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutReservationInput
      | StatusChangeCreateOrConnectWithoutReservationInput[];
    createMany?: StatusChangeCreateManyReservationInputEnvelope;
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type EnumReservationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReservationStatus;
  };

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus;
  };

  export type DocumentUpdateManyWithoutReservationNestedInput = {
    create?:
      | XOR<
          DocumentCreateWithoutReservationInput,
          DocumentUncheckedCreateWithoutReservationInput
        >
      | DocumentCreateWithoutReservationInput[]
      | DocumentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutReservationInput
      | DocumentCreateOrConnectWithoutReservationInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutReservationInput
      | DocumentUpsertWithWhereUniqueWithoutReservationInput[];
    createMany?: DocumentCreateManyReservationInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutReservationInput
      | DocumentUpdateWithWhereUniqueWithoutReservationInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutReservationInput
      | DocumentUpdateManyWithWhereWithoutReservationInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type PaymentUpdateManyWithoutReservationNestedInput = {
    create?:
      | XOR<
          PaymentCreateWithoutReservationInput,
          PaymentUncheckedCreateWithoutReservationInput
        >
      | PaymentCreateWithoutReservationInput[]
      | PaymentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutReservationInput
      | PaymentCreateOrConnectWithoutReservationInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutReservationInput
      | PaymentUpsertWithWhereUniqueWithoutReservationInput[];
    createMany?: PaymentCreateManyReservationInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutReservationInput
      | PaymentUpdateWithWhereUniqueWithoutReservationInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutReservationInput
      | PaymentUpdateManyWithWhereWithoutReservationInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type UserUpdateOneRequiredWithoutReservationNestedInput = {
    create?: XOR<
      UserCreateWithoutReservationInput,
      UserUncheckedCreateWithoutReservationInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReservationInput;
    upsert?: UserUpsertWithoutReservationInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutReservationInput,
        UserUpdateWithoutReservationInput
      >,
      UserUncheckedUpdateWithoutReservationInput
    >;
  };

  export type VehicleUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<
      VehicleCreateWithoutReservationsInput,
      VehicleUncheckedCreateWithoutReservationsInput
    >;
    connectOrCreate?: VehicleCreateOrConnectWithoutReservationsInput;
    upsert?: VehicleUpsertWithoutReservationsInput;
    disconnect?: VehicleWhereInput | boolean;
    delete?: VehicleWhereInput | boolean;
    connect?: VehicleWhereUniqueInput;
    update?: XOR<
      XOR<
        VehicleUpdateToOneWithWhereWithoutReservationsInput,
        VehicleUpdateWithoutReservationsInput
      >,
      VehicleUncheckedUpdateWithoutReservationsInput
    >;
  };

  export type StatusChangeUpdateManyWithoutReservationNestedInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutReservationInput,
          StatusChangeUncheckedCreateWithoutReservationInput
        >
      | StatusChangeCreateWithoutReservationInput[]
      | StatusChangeUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutReservationInput
      | StatusChangeCreateOrConnectWithoutReservationInput[];
    upsert?:
      | StatusChangeUpsertWithWhereUniqueWithoutReservationInput
      | StatusChangeUpsertWithWhereUniqueWithoutReservationInput[];
    createMany?: StatusChangeCreateManyReservationInputEnvelope;
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    update?:
      | StatusChangeUpdateWithWhereUniqueWithoutReservationInput
      | StatusChangeUpdateWithWhereUniqueWithoutReservationInput[];
    updateMany?:
      | StatusChangeUpdateManyWithWhereWithoutReservationInput
      | StatusChangeUpdateManyWithWhereWithoutReservationInput[];
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[];
  };

  export type DocumentUncheckedUpdateManyWithoutReservationNestedInput = {
    create?:
      | XOR<
          DocumentCreateWithoutReservationInput,
          DocumentUncheckedCreateWithoutReservationInput
        >
      | DocumentCreateWithoutReservationInput[]
      | DocumentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutReservationInput
      | DocumentCreateOrConnectWithoutReservationInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutReservationInput
      | DocumentUpsertWithWhereUniqueWithoutReservationInput[];
    createMany?: DocumentCreateManyReservationInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutReservationInput
      | DocumentUpdateWithWhereUniqueWithoutReservationInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutReservationInput
      | DocumentUpdateManyWithWhereWithoutReservationInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type PaymentUncheckedUpdateManyWithoutReservationNestedInput = {
    create?:
      | XOR<
          PaymentCreateWithoutReservationInput,
          PaymentUncheckedCreateWithoutReservationInput
        >
      | PaymentCreateWithoutReservationInput[]
      | PaymentUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutReservationInput
      | PaymentCreateOrConnectWithoutReservationInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutReservationInput
      | PaymentUpsertWithWhereUniqueWithoutReservationInput[];
    createMany?: PaymentCreateManyReservationInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutReservationInput
      | PaymentUpdateWithWhereUniqueWithoutReservationInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutReservationInput
      | PaymentUpdateManyWithWhereWithoutReservationInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type StatusChangeUncheckedUpdateManyWithoutReservationNestedInput = {
    create?:
      | XOR<
          StatusChangeCreateWithoutReservationInput,
          StatusChangeUncheckedCreateWithoutReservationInput
        >
      | StatusChangeCreateWithoutReservationInput[]
      | StatusChangeUncheckedCreateWithoutReservationInput[];
    connectOrCreate?:
      | StatusChangeCreateOrConnectWithoutReservationInput
      | StatusChangeCreateOrConnectWithoutReservationInput[];
    upsert?:
      | StatusChangeUpsertWithWhereUniqueWithoutReservationInput
      | StatusChangeUpsertWithWhereUniqueWithoutReservationInput[];
    createMany?: StatusChangeCreateManyReservationInputEnvelope;
    set?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    disconnect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    delete?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    connect?: StatusChangeWhereUniqueInput | StatusChangeWhereUniqueInput[];
    update?:
      | StatusChangeUpdateWithWhereUniqueWithoutReservationInput
      | StatusChangeUpdateWithWhereUniqueWithoutReservationInput[];
    updateMany?:
      | StatusChangeUpdateManyWithWhereWithoutReservationInput
      | StatusChangeUpdateManyWithWhereWithoutReservationInput[];
    deleteMany?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutStatusChangeInput = {
    create?: XOR<
      UserCreateWithoutStatusChangeInput,
      UserUncheckedCreateWithoutStatusChangeInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangeInput;
    connect?: UserWhereUniqueInput;
  };

  export type ReservationCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<
      ReservationCreateWithoutStatusHistoryInput,
      ReservationUncheckedCreateWithoutStatusHistoryInput
    >;
    connectOrCreate?: ReservationCreateOrConnectWithoutStatusHistoryInput;
    connect?: ReservationWhereUniqueInput;
  };

  export type NullableEnumReservationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReservationStatus | null;
  };

  export type UserUpdateOneWithoutStatusChangeNestedInput = {
    create?: XOR<
      UserCreateWithoutStatusChangeInput,
      UserUncheckedCreateWithoutStatusChangeInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangeInput;
    upsert?: UserUpsertWithoutStatusChangeInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutStatusChangeInput,
        UserUpdateWithoutStatusChangeInput
      >,
      UserUncheckedUpdateWithoutStatusChangeInput
    >;
  };

  export type ReservationUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<
      ReservationCreateWithoutStatusHistoryInput,
      ReservationUncheckedCreateWithoutStatusHistoryInput
    >;
    connectOrCreate?: ReservationCreateOrConnectWithoutStatusHistoryInput;
    upsert?: ReservationUpsertWithoutStatusHistoryInput;
    connect?: ReservationWhereUniqueInput;
    update?: XOR<
      XOR<
        ReservationUpdateToOneWithWhereWithoutStatusHistoryInput,
        ReservationUpdateWithoutStatusHistoryInput
      >,
      ReservationUncheckedUpdateWithoutStatusHistoryInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<
      UserCreateWithoutSessionInput,
      UserUncheckedCreateWithoutSessionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<
      UserCreateWithoutSessionInput,
      UserUncheckedCreateWithoutSessionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput;
    upsert?: UserUpsertWithoutSessionInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSessionInput,
        UserUpdateWithoutSessionInput
      >,
      UserUncheckedUpdateWithoutSessionInput
    >;
  };

  export type VehicleCreatefeaturesInput = {
    set: string[];
  };

  export type ImageCreateNestedManyWithoutVehicleInput = {
    create?:
      | XOR<
          ImageCreateWithoutVehicleInput,
          ImageUncheckedCreateWithoutVehicleInput
        >
      | ImageCreateWithoutVehicleInput[]
      | ImageUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ImageCreateOrConnectWithoutVehicleInput
      | ImageCreateOrConnectWithoutVehicleInput[];
    createMany?: ImageCreateManyVehicleInputEnvelope;
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
  };

  export type MaintenanceBlockCreateNestedManyWithoutVehicleInput = {
    create?:
      | XOR<
          MaintenanceBlockCreateWithoutVehicleInput,
          MaintenanceBlockUncheckedCreateWithoutVehicleInput
        >
      | MaintenanceBlockCreateWithoutVehicleInput[]
      | MaintenanceBlockUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput[];
    createMany?: MaintenanceBlockCreateManyVehicleInputEnvelope;
    connect?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
  };

  export type ReservationCreateNestedManyWithoutVehicleInput = {
    create?:
      | XOR<
          ReservationCreateWithoutVehicleInput,
          ReservationUncheckedCreateWithoutVehicleInput
        >
      | ReservationCreateWithoutVehicleInput[]
      | ReservationUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutVehicleInput
      | ReservationCreateOrConnectWithoutVehicleInput[];
    createMany?: ReservationCreateManyVehicleInputEnvelope;
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
  };

  export type ImageUncheckedCreateNestedManyWithoutVehicleInput = {
    create?:
      | XOR<
          ImageCreateWithoutVehicleInput,
          ImageUncheckedCreateWithoutVehicleInput
        >
      | ImageCreateWithoutVehicleInput[]
      | ImageUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ImageCreateOrConnectWithoutVehicleInput
      | ImageCreateOrConnectWithoutVehicleInput[];
    createMany?: ImageCreateManyVehicleInputEnvelope;
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
  };

  export type MaintenanceBlockUncheckedCreateNestedManyWithoutVehicleInput = {
    create?:
      | XOR<
          MaintenanceBlockCreateWithoutVehicleInput,
          MaintenanceBlockUncheckedCreateWithoutVehicleInput
        >
      | MaintenanceBlockCreateWithoutVehicleInput[]
      | MaintenanceBlockUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput[];
    createMany?: MaintenanceBlockCreateManyVehicleInputEnvelope;
    connect?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
  };

  export type ReservationUncheckedCreateNestedManyWithoutVehicleInput = {
    create?:
      | XOR<
          ReservationCreateWithoutVehicleInput,
          ReservationUncheckedCreateWithoutVehicleInput
        >
      | ReservationCreateWithoutVehicleInput[]
      | ReservationUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutVehicleInput
      | ReservationCreateOrConnectWithoutVehicleInput[];
    createMany?: ReservationCreateManyVehicleInputEnvelope;
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
  };

  export type EnumVehicleCategoryFieldUpdateOperationsInput = {
    set?: $Enums.VehicleCategory;
  };

  export type EnumVehicleTransmissionFieldUpdateOperationsInput = {
    set?: $Enums.VehicleTransmission;
  };

  export type EnumVehicleFuelTypeFieldUpdateOperationsInput = {
    set?: $Enums.VehicleFuelType;
  };

  export type EnumVehicleStatusFieldUpdateOperationsInput = {
    set?: $Enums.VehicleStatus;
  };

  export type VehicleUpdatefeaturesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type ImageUpdateManyWithoutVehicleNestedInput = {
    create?:
      | XOR<
          ImageCreateWithoutVehicleInput,
          ImageUncheckedCreateWithoutVehicleInput
        >
      | ImageCreateWithoutVehicleInput[]
      | ImageUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ImageCreateOrConnectWithoutVehicleInput
      | ImageCreateOrConnectWithoutVehicleInput[];
    upsert?:
      | ImageUpsertWithWhereUniqueWithoutVehicleInput
      | ImageUpsertWithWhereUniqueWithoutVehicleInput[];
    createMany?: ImageCreateManyVehicleInputEnvelope;
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    update?:
      | ImageUpdateWithWhereUniqueWithoutVehicleInput
      | ImageUpdateWithWhereUniqueWithoutVehicleInput[];
    updateMany?:
      | ImageUpdateManyWithWhereWithoutVehicleInput
      | ImageUpdateManyWithWhereWithoutVehicleInput[];
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[];
  };

  export type MaintenanceBlockUpdateManyWithoutVehicleNestedInput = {
    create?:
      | XOR<
          MaintenanceBlockCreateWithoutVehicleInput,
          MaintenanceBlockUncheckedCreateWithoutVehicleInput
        >
      | MaintenanceBlockCreateWithoutVehicleInput[]
      | MaintenanceBlockUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput[];
    upsert?:
      | MaintenanceBlockUpsertWithWhereUniqueWithoutVehicleInput
      | MaintenanceBlockUpsertWithWhereUniqueWithoutVehicleInput[];
    createMany?: MaintenanceBlockCreateManyVehicleInputEnvelope;
    set?: MaintenanceBlockWhereUniqueInput | MaintenanceBlockWhereUniqueInput[];
    disconnect?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
    delete?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
    connect?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
    update?:
      | MaintenanceBlockUpdateWithWhereUniqueWithoutVehicleInput
      | MaintenanceBlockUpdateWithWhereUniqueWithoutVehicleInput[];
    updateMany?:
      | MaintenanceBlockUpdateManyWithWhereWithoutVehicleInput
      | MaintenanceBlockUpdateManyWithWhereWithoutVehicleInput[];
    deleteMany?:
      | MaintenanceBlockScalarWhereInput
      | MaintenanceBlockScalarWhereInput[];
  };

  export type ReservationUpdateManyWithoutVehicleNestedInput = {
    create?:
      | XOR<
          ReservationCreateWithoutVehicleInput,
          ReservationUncheckedCreateWithoutVehicleInput
        >
      | ReservationCreateWithoutVehicleInput[]
      | ReservationUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutVehicleInput
      | ReservationCreateOrConnectWithoutVehicleInput[];
    upsert?:
      | ReservationUpsertWithWhereUniqueWithoutVehicleInput
      | ReservationUpsertWithWhereUniqueWithoutVehicleInput[];
    createMany?: ReservationCreateManyVehicleInputEnvelope;
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    update?:
      | ReservationUpdateWithWhereUniqueWithoutVehicleInput
      | ReservationUpdateWithWhereUniqueWithoutVehicleInput[];
    updateMany?:
      | ReservationUpdateManyWithWhereWithoutVehicleInput
      | ReservationUpdateManyWithWhereWithoutVehicleInput[];
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[];
  };

  export type ImageUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?:
      | XOR<
          ImageCreateWithoutVehicleInput,
          ImageUncheckedCreateWithoutVehicleInput
        >
      | ImageCreateWithoutVehicleInput[]
      | ImageUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ImageCreateOrConnectWithoutVehicleInput
      | ImageCreateOrConnectWithoutVehicleInput[];
    upsert?:
      | ImageUpsertWithWhereUniqueWithoutVehicleInput
      | ImageUpsertWithWhereUniqueWithoutVehicleInput[];
    createMany?: ImageCreateManyVehicleInputEnvelope;
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[];
    update?:
      | ImageUpdateWithWhereUniqueWithoutVehicleInput
      | ImageUpdateWithWhereUniqueWithoutVehicleInput[];
    updateMany?:
      | ImageUpdateManyWithWhereWithoutVehicleInput
      | ImageUpdateManyWithWhereWithoutVehicleInput[];
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[];
  };

  export type MaintenanceBlockUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?:
      | XOR<
          MaintenanceBlockCreateWithoutVehicleInput,
          MaintenanceBlockUncheckedCreateWithoutVehicleInput
        >
      | MaintenanceBlockCreateWithoutVehicleInput[]
      | MaintenanceBlockUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput
      | MaintenanceBlockCreateOrConnectWithoutVehicleInput[];
    upsert?:
      | MaintenanceBlockUpsertWithWhereUniqueWithoutVehicleInput
      | MaintenanceBlockUpsertWithWhereUniqueWithoutVehicleInput[];
    createMany?: MaintenanceBlockCreateManyVehicleInputEnvelope;
    set?: MaintenanceBlockWhereUniqueInput | MaintenanceBlockWhereUniqueInput[];
    disconnect?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
    delete?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
    connect?:
      | MaintenanceBlockWhereUniqueInput
      | MaintenanceBlockWhereUniqueInput[];
    update?:
      | MaintenanceBlockUpdateWithWhereUniqueWithoutVehicleInput
      | MaintenanceBlockUpdateWithWhereUniqueWithoutVehicleInput[];
    updateMany?:
      | MaintenanceBlockUpdateManyWithWhereWithoutVehicleInput
      | MaintenanceBlockUpdateManyWithWhereWithoutVehicleInput[];
    deleteMany?:
      | MaintenanceBlockScalarWhereInput
      | MaintenanceBlockScalarWhereInput[];
  };

  export type ReservationUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?:
      | XOR<
          ReservationCreateWithoutVehicleInput,
          ReservationUncheckedCreateWithoutVehicleInput
        >
      | ReservationCreateWithoutVehicleInput[]
      | ReservationUncheckedCreateWithoutVehicleInput[];
    connectOrCreate?:
      | ReservationCreateOrConnectWithoutVehicleInput
      | ReservationCreateOrConnectWithoutVehicleInput[];
    upsert?:
      | ReservationUpsertWithWhereUniqueWithoutVehicleInput
      | ReservationUpsertWithWhereUniqueWithoutVehicleInput[];
    createMany?: ReservationCreateManyVehicleInputEnvelope;
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[];
    update?:
      | ReservationUpdateWithWhereUniqueWithoutVehicleInput
      | ReservationUpdateWithWhereUniqueWithoutVehicleInput[];
    updateMany?:
      | ReservationUpdateManyWithWhereWithoutVehicleInput
      | ReservationUpdateManyWithWhereWithoutVehicleInput[];
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[];
  };

  export type VehicleCreateNestedOneWithoutMaintenanceBlocksInput = {
    create?: XOR<
      VehicleCreateWithoutMaintenanceBlocksInput,
      VehicleUncheckedCreateWithoutMaintenanceBlocksInput
    >;
    connectOrCreate?: VehicleCreateOrConnectWithoutMaintenanceBlocksInput;
    connect?: VehicleWhereUniqueInput;
  };

  export type VehicleUpdateOneRequiredWithoutMaintenanceBlocksNestedInput = {
    create?: XOR<
      VehicleCreateWithoutMaintenanceBlocksInput,
      VehicleUncheckedCreateWithoutMaintenanceBlocksInput
    >;
    connectOrCreate?: VehicleCreateOrConnectWithoutMaintenanceBlocksInput;
    upsert?: VehicleUpsertWithoutMaintenanceBlocksInput;
    connect?: VehicleWhereUniqueInput;
    update?: XOR<
      XOR<
        VehicleUpdateToOneWithWhereWithoutMaintenanceBlocksInput,
        VehicleUpdateWithoutMaintenanceBlocksInput
      >,
      VehicleUncheckedUpdateWithoutMaintenanceBlocksInput
    >;
  };

  export type ReservationCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<
      ReservationCreateWithoutPaymentsInput,
      ReservationUncheckedCreateWithoutPaymentsInput
    >;
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentsInput;
    connect?: ReservationWhereUniqueInput;
  };

  export type ReservationUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<
      ReservationCreateWithoutPaymentsInput,
      ReservationUncheckedCreateWithoutPaymentsInput
    >;
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentsInput;
    upsert?: ReservationUpsertWithoutPaymentsInput;
    connect?: ReservationWhereUniqueInput;
    update?: XOR<
      XOR<
        ReservationUpdateToOneWithWhereWithoutPaymentsInput,
        ReservationUpdateWithoutPaymentsInput
      >,
      ReservationUncheckedUpdateWithoutPaymentsInput
    >;
  };

  export type ReservationCreateNestedOneWithoutContractsInput = {
    create?: XOR<
      ReservationCreateWithoutContractsInput,
      ReservationUncheckedCreateWithoutContractsInput
    >;
    connectOrCreate?: ReservationCreateOrConnectWithoutContractsInput;
    connect?: ReservationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<
      UserCreateWithoutDocumentsInput,
      UserUncheckedCreateWithoutDocumentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ReservationUpdateOneWithoutContractsNestedInput = {
    create?: XOR<
      ReservationCreateWithoutContractsInput,
      ReservationUncheckedCreateWithoutContractsInput
    >;
    connectOrCreate?: ReservationCreateOrConnectWithoutContractsInput;
    upsert?: ReservationUpsertWithoutContractsInput;
    disconnect?: ReservationWhereInput | boolean;
    delete?: ReservationWhereInput | boolean;
    connect?: ReservationWhereUniqueInput;
    update?: XOR<
      XOR<
        ReservationUpdateToOneWithWhereWithoutContractsInput,
        ReservationUpdateWithoutContractsInput
      >,
      ReservationUncheckedUpdateWithoutContractsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<
      UserCreateWithoutDocumentsInput,
      UserUncheckedCreateWithoutDocumentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput;
    upsert?: UserUpsertWithoutDocumentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutDocumentsInput,
        UserUpdateWithoutDocumentsInput
      >,
      UserUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type VehicleCreateNestedOneWithoutImagesInput = {
    create?: XOR<
      VehicleCreateWithoutImagesInput,
      VehicleUncheckedCreateWithoutImagesInput
    >;
    connectOrCreate?: VehicleCreateOrConnectWithoutImagesInput;
    connect?: VehicleWhereUniqueInput;
  };

  export type VehicleUpdateOneWithoutImagesNestedInput = {
    create?: XOR<
      VehicleCreateWithoutImagesInput,
      VehicleUncheckedCreateWithoutImagesInput
    >;
    connectOrCreate?: VehicleCreateOrConnectWithoutImagesInput;
    upsert?: VehicleUpsertWithoutImagesInput;
    disconnect?: VehicleWhereInput | boolean;
    delete?: VehicleWhereInput | boolean;
    connect?: VehicleWhereUniqueInput;
    update?: XOR<
      XOR<
        VehicleUpdateToOneWithWhereWithoutImagesInput,
        VehicleUpdateWithoutImagesInput
      >,
      VehicleUncheckedUpdateWithoutImagesInput
    >;
  };

  export type UserCreateNestedOneWithoutPushSubscriptionInput = {
    create?: XOR<
      UserCreateWithoutPushSubscriptionInput,
      UserUncheckedCreateWithoutPushSubscriptionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutPushSubscriptionNestedInput = {
    create?: XOR<
      UserCreateWithoutPushSubscriptionInput,
      UserUncheckedCreateWithoutPushSubscriptionInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionInput;
    upsert?: UserUpsertWithoutPushSubscriptionInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPushSubscriptionInput,
        UserUpdateWithoutPushSubscriptionInput
      >,
      UserUncheckedUpdateWithoutPushSubscriptionInput
    >;
  };

  export type UserCreateNestedOneWithoutOnboardingInput = {
    create?: XOR<
      UserCreateWithoutOnboardingInput,
      UserUncheckedCreateWithoutOnboardingInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutOnboardingNestedInput = {
    create?: XOR<
      UserCreateWithoutOnboardingInput,
      UserUncheckedCreateWithoutOnboardingInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput;
    upsert?: UserUpsertWithoutOnboardingInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutOnboardingInput,
        UserUpdateWithoutOnboardingInput
      >,
      UserUncheckedUpdateWithoutOnboardingInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
  };

  export type NestedEnumReservationStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ReservationStatus
      | EnumReservationStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumReservationStatusFilter<$PrismaModel>
      | $Enums.ReservationStatus;
  };

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedEnumReservationStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ReservationStatus
      | EnumReservationStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ReservationStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumReservationStatusFilter<$PrismaModel>;
    _max?: NestedEnumReservationStatusFilter<$PrismaModel>;
  };

  export type NestedEnumPaymentStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type NestedEnumReservationStatusNullableFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.ReservationStatus
        | EnumReservationStatusFieldRefInput<$PrismaModel>
        | null;
      in?:
        | $Enums.ReservationStatus[]
        | ListEnumReservationStatusFieldRefInput<$PrismaModel>
        | null;
      notIn?:
        | $Enums.ReservationStatus[]
        | ListEnumReservationStatusFieldRefInput<$PrismaModel>
        | null;
      not?:
        | NestedEnumReservationStatusNullableFilter<$PrismaModel>
        | $Enums.ReservationStatus
        | null;
    };

  export type NestedEnumReservationStatusNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ReservationStatus
      | EnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.ReservationStatus[]
      | ListEnumReservationStatusFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumReservationStatusNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.ReservationStatus
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumReservationStatusNullableFilter<$PrismaModel>;
    _max?: NestedEnumReservationStatusNullableFilter<$PrismaModel>;
  };

  export type NestedEnumVehicleCategoryFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleCategory
      | EnumVehicleCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleCategoryFilter<$PrismaModel>
      | $Enums.VehicleCategory;
  };

  export type NestedEnumVehicleTransmissionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleTransmission
      | EnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleTransmissionFilter<$PrismaModel>
      | $Enums.VehicleTransmission;
  };

  export type NestedEnumVehicleFuelTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleFuelType
      | EnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleFuelTypeFilter<$PrismaModel>
      | $Enums.VehicleFuelType;
  };

  export type NestedEnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.VehicleStatus
      | EnumVehicleStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus;
  };

  export type NestedEnumVehicleCategoryWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.VehicleCategory
      | EnumVehicleCategoryFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleCategory[]
      | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleCategoryWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleCategory;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleCategoryFilter<$PrismaModel>;
    _max?: NestedEnumVehicleCategoryFilter<$PrismaModel>;
  };

  export type NestedEnumVehicleTransmissionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.VehicleTransmission
      | EnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleTransmission[]
      | ListEnumVehicleTransmissionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleTransmissionWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleTransmission;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleTransmissionFilter<$PrismaModel>;
    _max?: NestedEnumVehicleTransmissionFilter<$PrismaModel>;
  };

  export type NestedEnumVehicleFuelTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.VehicleFuelType
      | EnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleFuelType[]
      | ListEnumVehicleFuelTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleFuelTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleFuelType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleFuelTypeFilter<$PrismaModel>;
    _max?: NestedEnumVehicleFuelTypeFilter<$PrismaModel>;
  };

  export type NestedEnumVehicleStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.VehicleStatus
      | EnumVehicleStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.VehicleStatus[]
      | ListEnumVehicleStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.VehicleStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>;
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, "path">>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type AccountCreateWithoutUserInput = {
    type: string;
    provider: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    providerAccountId: string;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: number;
    type: string;
    provider: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    providerAccountId: string;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type DocumentCreateWithoutUserInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    Reservation?: ReservationCreateNestedOneWithoutContractsInput;
  };

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    reservationId?: string | null;
  };

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput;
    create: XOR<
      DocumentCreateWithoutUserInput,
      DocumentUncheckedCreateWithoutUserInput
    >;
  };

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type OnboardingCreateWithoutUserInput = {
    id?: string;
    tour?: string;
    completed?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OnboardingUncheckedCreateWithoutUserInput = {
    id?: string;
    tour?: string;
    completed?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OnboardingCreateOrConnectWithoutUserInput = {
    where: OnboardingWhereUniqueInput;
    create: XOR<
      OnboardingCreateWithoutUserInput,
      OnboardingUncheckedCreateWithoutUserInput
    >;
  };

  export type OnboardingCreateManyUserInputEnvelope = {
    data: OnboardingCreateManyUserInput | OnboardingCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type PreferencesCreateWithoutUserInput = {
    id?: string;
    UserNotifications?: boolean;
    ReservationNotifications?: boolean;
    LeadNotifications?: boolean;
    ContactNotifications?: boolean;
    PaymentNotifications?: boolean;
    ReviewNotifications?: boolean;
  };

  export type PreferencesUncheckedCreateWithoutUserInput = {
    id?: string;
    UserNotifications?: boolean;
    ReservationNotifications?: boolean;
    LeadNotifications?: boolean;
    ContactNotifications?: boolean;
    PaymentNotifications?: boolean;
    ReviewNotifications?: boolean;
  };

  export type PreferencesCreateOrConnectWithoutUserInput = {
    where: PreferencesWhereUniqueInput;
    create: XOR<
      PreferencesCreateWithoutUserInput,
      PreferencesUncheckedCreateWithoutUserInput
    >;
  };

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string;
    endpoint: string;
    keys: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string;
    endpoint: string;
    keys: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput;
    create: XOR<
      PushSubscriptionCreateWithoutUserInput,
      PushSubscriptionUncheckedCreateWithoutUserInput
    >;
  };

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data:
      | PushSubscriptionCreateManyUserInput
      | PushSubscriptionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ReservationCreateWithoutUserInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentCreateNestedManyWithoutReservationInput;
    payments?: PaymentCreateNestedManyWithoutReservationInput;
    vehicle?: VehicleCreateNestedOneWithoutReservationsInput;
    statusHistory?: StatusChangeCreateNestedManyWithoutReservationInput;
  };

  export type ReservationUncheckedCreateWithoutUserInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    vehicleId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentUncheckedCreateNestedManyWithoutReservationInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput;
    statusHistory?: StatusChangeUncheckedCreateNestedManyWithoutReservationInput;
  };

  export type ReservationCreateOrConnectWithoutUserInput = {
    where: ReservationWhereUniqueInput;
    create: XOR<
      ReservationCreateWithoutUserInput,
      ReservationUncheckedCreateWithoutUserInput
    >;
  };

  export type ReservationCreateManyUserInputEnvelope = {
    data: ReservationCreateManyUserInput | ReservationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id: string;
    expires: Date | string;
    sessionToken: string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string;
    expires: Date | string;
    sessionToken: string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type StatusChangeCreateWithoutUserInput = {
    id?: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changeAt?: Date | string;
    reservation: ReservationCreateNestedOneWithoutStatusHistoryInput;
  };

  export type StatusChangeUncheckedCreateWithoutUserInput = {
    id?: string;
    reservationId: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changeAt?: Date | string;
  };

  export type StatusChangeCreateOrConnectWithoutUserInput = {
    where: StatusChangeWhereUniqueInput;
    create: XOR<
      StatusChangeCreateWithoutUserInput,
      StatusChangeUncheckedCreateWithoutUserInput
    >;
  };

  export type StatusChangeCreateManyUserInputEnvelope = {
    data: StatusChangeCreateManyUserInput | StatusChangeCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<
      AccountUpdateManyMutationInput,
      AccountUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: IntFilter<"Account"> | number;
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
    providerAccountId?: StringFilter<"Account"> | string;
  };

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput;
    update: XOR<
      DocumentUpdateWithoutUserInput,
      DocumentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      DocumentCreateWithoutUserInput,
      DocumentUncheckedCreateWithoutUserInput
    >;
  };

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput;
    data: XOR<
      DocumentUpdateWithoutUserInput,
      DocumentUncheckedUpdateWithoutUserInput
    >;
  };

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput;
    data: XOR<
      DocumentUpdateManyMutationInput,
      DocumentUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    OR?: DocumentScalarWhereInput[];
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    id?: StringFilter<"Document"> | string;
    name?: StringFilter<"Document"> | string;
    type?: StringFilter<"Document"> | string;
    url?: StringFilter<"Document"> | string;
    uploadedAt?: DateTimeFilter<"Document"> | Date | string;
    userId?: StringFilter<"Document"> | string;
    reservationId?: StringNullableFilter<"Document"> | string | null;
  };

  export type OnboardingUpsertWithWhereUniqueWithoutUserInput = {
    where: OnboardingWhereUniqueInput;
    update: XOR<
      OnboardingUpdateWithoutUserInput,
      OnboardingUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      OnboardingCreateWithoutUserInput,
      OnboardingUncheckedCreateWithoutUserInput
    >;
  };

  export type OnboardingUpdateWithWhereUniqueWithoutUserInput = {
    where: OnboardingWhereUniqueInput;
    data: XOR<
      OnboardingUpdateWithoutUserInput,
      OnboardingUncheckedUpdateWithoutUserInput
    >;
  };

  export type OnboardingUpdateManyWithWhereWithoutUserInput = {
    where: OnboardingScalarWhereInput;
    data: XOR<
      OnboardingUpdateManyMutationInput,
      OnboardingUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type OnboardingScalarWhereInput = {
    AND?: OnboardingScalarWhereInput | OnboardingScalarWhereInput[];
    OR?: OnboardingScalarWhereInput[];
    NOT?: OnboardingScalarWhereInput | OnboardingScalarWhereInput[];
    id?: StringFilter<"Onboarding"> | string;
    userId?: StringFilter<"Onboarding"> | string;
    tour?: StringFilter<"Onboarding"> | string;
    completed?: BoolFilter<"Onboarding"> | boolean;
    createdAt?: DateTimeFilter<"Onboarding"> | Date | string;
    updatedAt?: DateTimeFilter<"Onboarding"> | Date | string;
  };

  export type PreferencesUpsertWithoutUserInput = {
    update: XOR<
      PreferencesUpdateWithoutUserInput,
      PreferencesUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PreferencesCreateWithoutUserInput,
      PreferencesUncheckedCreateWithoutUserInput
    >;
    where?: PreferencesWhereInput;
  };

  export type PreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: PreferencesWhereInput;
    data: XOR<
      PreferencesUpdateWithoutUserInput,
      PreferencesUncheckedUpdateWithoutUserInput
    >;
  };

  export type PreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    UserNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReservationNotifications?: BoolFieldUpdateOperationsInput | boolean;
    LeadNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ContactNotifications?: BoolFieldUpdateOperationsInput | boolean;
    PaymentNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReviewNotifications?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type PreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    UserNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReservationNotifications?: BoolFieldUpdateOperationsInput | boolean;
    LeadNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ContactNotifications?: BoolFieldUpdateOperationsInput | boolean;
    PaymentNotifications?: BoolFieldUpdateOperationsInput | boolean;
    ReviewNotifications?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput;
    update: XOR<
      PushSubscriptionUpdateWithoutUserInput,
      PushSubscriptionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PushSubscriptionCreateWithoutUserInput,
      PushSubscriptionUncheckedCreateWithoutUserInput
    >;
  };

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput;
    data: XOR<
      PushSubscriptionUpdateWithoutUserInput,
      PushSubscriptionUncheckedUpdateWithoutUserInput
    >;
  };

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput;
    data: XOR<
      PushSubscriptionUpdateManyMutationInput,
      PushSubscriptionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[];
    OR?: PushSubscriptionScalarWhereInput[];
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[];
    id?: StringFilter<"PushSubscription"> | string;
    endpoint?: StringFilter<"PushSubscription"> | string;
    keys?: JsonFilter<"PushSubscription">;
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string;
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string;
    userId?: StringFilter<"PushSubscription"> | string;
  };

  export type ReservationUpsertWithWhereUniqueWithoutUserInput = {
    where: ReservationWhereUniqueInput;
    update: XOR<
      ReservationUpdateWithoutUserInput,
      ReservationUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ReservationCreateWithoutUserInput,
      ReservationUncheckedCreateWithoutUserInput
    >;
  };

  export type ReservationUpdateWithWhereUniqueWithoutUserInput = {
    where: ReservationWhereUniqueInput;
    data: XOR<
      ReservationUpdateWithoutUserInput,
      ReservationUncheckedUpdateWithoutUserInput
    >;
  };

  export type ReservationUpdateManyWithWhereWithoutUserInput = {
    where: ReservationScalarWhereInput;
    data: XOR<
      ReservationUpdateManyMutationInput,
      ReservationUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[];
    OR?: ReservationScalarWhereInput[];
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[];
    id?: StringFilter<"Reservation"> | string;
    pickupDate?: DateTimeFilter<"Reservation"> | Date | string;
    dropoffDate?: DateTimeFilter<"Reservation"> | Date | string;
    pickupLocation?: StringFilter<"Reservation"> | string;
    dropoffLocation?: StringFilter<"Reservation"> | string;
    pickupHour?: StringFilter<"Reservation"> | string;
    dropoffHour?: StringFilter<"Reservation"> | string;
    dailyRate?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFilter<"Reservation">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFilter<"Reservation">
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFilter<"Reservation">
      | $Enums.PaymentStatus;
    notes?: StringNullableFilter<"Reservation"> | string | null;
    specialRequests?: StringNullableFilter<"Reservation"> | string | null;
    vehicleId?: IntNullableFilter<"Reservation"> | number | null;
    userId?: StringFilter<"Reservation"> | string;
    createdAt?: DateTimeFilter<"Reservation"> | Date | string;
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<
      SessionUpdateManyMutationInput,
      SessionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
    sessionToken?: StringFilter<"Session"> | string;
  };

  export type StatusChangeUpsertWithWhereUniqueWithoutUserInput = {
    where: StatusChangeWhereUniqueInput;
    update: XOR<
      StatusChangeUpdateWithoutUserInput,
      StatusChangeUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      StatusChangeCreateWithoutUserInput,
      StatusChangeUncheckedCreateWithoutUserInput
    >;
  };

  export type StatusChangeUpdateWithWhereUniqueWithoutUserInput = {
    where: StatusChangeWhereUniqueInput;
    data: XOR<
      StatusChangeUpdateWithoutUserInput,
      StatusChangeUncheckedUpdateWithoutUserInput
    >;
  };

  export type StatusChangeUpdateManyWithWhereWithoutUserInput = {
    where: StatusChangeScalarWhereInput;
    data: XOR<
      StatusChangeUpdateManyMutationInput,
      StatusChangeUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type StatusChangeScalarWhereInput = {
    AND?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[];
    OR?: StatusChangeScalarWhereInput[];
    NOT?: StatusChangeScalarWhereInput | StatusChangeScalarWhereInput[];
    id?: StringFilter<"StatusChange"> | string;
    reservationId?: StringFilter<"StatusChange"> | string;
    fromStatus?:
      | EnumReservationStatusNullableFilter<"StatusChange">
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFilter<"StatusChange">
      | $Enums.ReservationStatus;
    reason?: StringNullableFilter<"StatusChange"> | string | null;
    changedBy?: StringNullableFilter<"StatusChange"> | string | null;
    changeAt?: DateTimeFilter<"StatusChange"> | Date | string;
  };

  export type UserCreateWithoutNotificationsPreferencesInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutNotificationsPreferencesInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutNotificationsPreferencesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNotificationsPreferencesInput,
      UserUncheckedCreateWithoutNotificationsPreferencesInput
    >;
  };

  export type UserUpsertWithoutNotificationsPreferencesInput = {
    update: XOR<
      UserUpdateWithoutNotificationsPreferencesInput,
      UserUncheckedUpdateWithoutNotificationsPreferencesInput
    >;
    create: XOR<
      UserCreateWithoutNotificationsPreferencesInput,
      UserUncheckedCreateWithoutNotificationsPreferencesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsPreferencesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutNotificationsPreferencesInput,
      UserUncheckedUpdateWithoutNotificationsPreferencesInput
    >;
  };

  export type UserUpdateWithoutNotificationsPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutAccountInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAccountInput,
      UserUncheckedCreateWithoutAccountInput
    >;
  };

  export type UserUpsertWithoutAccountInput = {
    update: XOR<
      UserUpdateWithoutAccountInput,
      UserUncheckedUpdateWithoutAccountInput
    >;
    create: XOR<
      UserCreateWithoutAccountInput,
      UserUncheckedCreateWithoutAccountInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAccountInput,
      UserUncheckedUpdateWithoutAccountInput
    >;
  };

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type DocumentCreateWithoutReservationInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    User: UserCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateWithoutReservationInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    userId: string;
  };

  export type DocumentCreateOrConnectWithoutReservationInput = {
    where: DocumentWhereUniqueInput;
    create: XOR<
      DocumentCreateWithoutReservationInput,
      DocumentUncheckedCreateWithoutReservationInput
    >;
  };

  export type DocumentCreateManyReservationInputEnvelope = {
    data:
      | DocumentCreateManyReservationInput
      | DocumentCreateManyReservationInput[];
    skipDuplicates?: boolean;
  };

  export type PaymentCreateWithoutReservationInput = {
    id?: string;
    stripeSession: string;
    amount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.PaymentStatus;
    intent_id?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUncheckedCreateWithoutReservationInput = {
    id?: string;
    stripeSession: string;
    amount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.PaymentStatus;
    intent_id?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentCreateOrConnectWithoutReservationInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<
      PaymentCreateWithoutReservationInput,
      PaymentUncheckedCreateWithoutReservationInput
    >;
  };

  export type PaymentCreateManyReservationInputEnvelope = {
    data:
      | PaymentCreateManyReservationInput
      | PaymentCreateManyReservationInput[];
    skipDuplicates?: boolean;
  };

  export type UserCreateWithoutReservationInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutReservationInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutReservationInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutReservationInput,
      UserUncheckedCreateWithoutReservationInput
    >;
  };

  export type VehicleCreateWithoutReservationsInput = {
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ImageCreateNestedManyWithoutVehicleInput;
    maintenanceBlocks?: MaintenanceBlockCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleUncheckedCreateWithoutReservationsInput = {
    id?: number;
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ImageUncheckedCreateNestedManyWithoutVehicleInput;
    maintenanceBlocks?: MaintenanceBlockUncheckedCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleCreateOrConnectWithoutReservationsInput = {
    where: VehicleWhereUniqueInput;
    create: XOR<
      VehicleCreateWithoutReservationsInput,
      VehicleUncheckedCreateWithoutReservationsInput
    >;
  };

  export type StatusChangeCreateWithoutReservationInput = {
    id?: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changeAt?: Date | string;
    user?: UserCreateNestedOneWithoutStatusChangeInput;
  };

  export type StatusChangeUncheckedCreateWithoutReservationInput = {
    id?: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changedBy?: string | null;
    changeAt?: Date | string;
  };

  export type StatusChangeCreateOrConnectWithoutReservationInput = {
    where: StatusChangeWhereUniqueInput;
    create: XOR<
      StatusChangeCreateWithoutReservationInput,
      StatusChangeUncheckedCreateWithoutReservationInput
    >;
  };

  export type StatusChangeCreateManyReservationInputEnvelope = {
    data:
      | StatusChangeCreateManyReservationInput
      | StatusChangeCreateManyReservationInput[];
    skipDuplicates?: boolean;
  };

  export type DocumentUpsertWithWhereUniqueWithoutReservationInput = {
    where: DocumentWhereUniqueInput;
    update: XOR<
      DocumentUpdateWithoutReservationInput,
      DocumentUncheckedUpdateWithoutReservationInput
    >;
    create: XOR<
      DocumentCreateWithoutReservationInput,
      DocumentUncheckedCreateWithoutReservationInput
    >;
  };

  export type DocumentUpdateWithWhereUniqueWithoutReservationInput = {
    where: DocumentWhereUniqueInput;
    data: XOR<
      DocumentUpdateWithoutReservationInput,
      DocumentUncheckedUpdateWithoutReservationInput
    >;
  };

  export type DocumentUpdateManyWithWhereWithoutReservationInput = {
    where: DocumentScalarWhereInput;
    data: XOR<
      DocumentUpdateManyMutationInput,
      DocumentUncheckedUpdateManyWithoutReservationInput
    >;
  };

  export type PaymentUpsertWithWhereUniqueWithoutReservationInput = {
    where: PaymentWhereUniqueInput;
    update: XOR<
      PaymentUpdateWithoutReservationInput,
      PaymentUncheckedUpdateWithoutReservationInput
    >;
    create: XOR<
      PaymentCreateWithoutReservationInput,
      PaymentUncheckedCreateWithoutReservationInput
    >;
  };

  export type PaymentUpdateWithWhereUniqueWithoutReservationInput = {
    where: PaymentWhereUniqueInput;
    data: XOR<
      PaymentUpdateWithoutReservationInput,
      PaymentUncheckedUpdateWithoutReservationInput
    >;
  };

  export type PaymentUpdateManyWithWhereWithoutReservationInput = {
    where: PaymentScalarWhereInput;
    data: XOR<
      PaymentUpdateManyMutationInput,
      PaymentUncheckedUpdateManyWithoutReservationInput
    >;
  };

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    OR?: PaymentScalarWhereInput[];
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    id?: StringFilter<"Payment"> | string;
    stripeSession?: StringFilter<"Payment"> | string;
    amount?:
      | DecimalFilter<"Payment">
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus;
    intent_id?: StringNullableFilter<"Payment"> | string | null;
    reservationId?: StringFilter<"Payment"> | string;
    createdAt?: DateTimeFilter<"Payment"> | Date | string;
    updatedAt?: DateTimeFilter<"Payment"> | Date | string;
  };

  export type UserUpsertWithoutReservationInput = {
    update: XOR<
      UserUpdateWithoutReservationInput,
      UserUncheckedUpdateWithoutReservationInput
    >;
    create: XOR<
      UserCreateWithoutReservationInput,
      UserUncheckedCreateWithoutReservationInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReservationInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutReservationInput,
      UserUncheckedUpdateWithoutReservationInput
    >;
  };

  export type UserUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type VehicleUpsertWithoutReservationsInput = {
    update: XOR<
      VehicleUpdateWithoutReservationsInput,
      VehicleUncheckedUpdateWithoutReservationsInput
    >;
    create: XOR<
      VehicleCreateWithoutReservationsInput,
      VehicleUncheckedCreateWithoutReservationsInput
    >;
    where?: VehicleWhereInput;
  };

  export type VehicleUpdateToOneWithWhereWithoutReservationsInput = {
    where?: VehicleWhereInput;
    data: XOR<
      VehicleUpdateWithoutReservationsInput,
      VehicleUncheckedUpdateWithoutReservationsInput
    >;
  };

  export type VehicleUpdateWithoutReservationsInput = {
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ImageUpdateManyWithoutVehicleNestedInput;
    maintenanceBlocks?: MaintenanceBlockUpdateManyWithoutVehicleNestedInput;
  };

  export type VehicleUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number;
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ImageUncheckedUpdateManyWithoutVehicleNestedInput;
    maintenanceBlocks?: MaintenanceBlockUncheckedUpdateManyWithoutVehicleNestedInput;
  };

  export type StatusChangeUpsertWithWhereUniqueWithoutReservationInput = {
    where: StatusChangeWhereUniqueInput;
    update: XOR<
      StatusChangeUpdateWithoutReservationInput,
      StatusChangeUncheckedUpdateWithoutReservationInput
    >;
    create: XOR<
      StatusChangeCreateWithoutReservationInput,
      StatusChangeUncheckedCreateWithoutReservationInput
    >;
  };

  export type StatusChangeUpdateWithWhereUniqueWithoutReservationInput = {
    where: StatusChangeWhereUniqueInput;
    data: XOR<
      StatusChangeUpdateWithoutReservationInput,
      StatusChangeUncheckedUpdateWithoutReservationInput
    >;
  };

  export type StatusChangeUpdateManyWithWhereWithoutReservationInput = {
    where: StatusChangeScalarWhereInput;
    data: XOR<
      StatusChangeUpdateManyMutationInput,
      StatusChangeUncheckedUpdateManyWithoutReservationInput
    >;
  };

  export type UserCreateWithoutStatusChangeInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutStatusChangeInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutStatusChangeInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutStatusChangeInput,
      UserUncheckedCreateWithoutStatusChangeInput
    >;
  };

  export type ReservationCreateWithoutStatusHistoryInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentCreateNestedManyWithoutReservationInput;
    payments?: PaymentCreateNestedManyWithoutReservationInput;
    user: UserCreateNestedOneWithoutReservationInput;
    vehicle?: VehicleCreateNestedOneWithoutReservationsInput;
  };

  export type ReservationUncheckedCreateWithoutStatusHistoryInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    vehicleId?: number | null;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentUncheckedCreateNestedManyWithoutReservationInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput;
  };

  export type ReservationCreateOrConnectWithoutStatusHistoryInput = {
    where: ReservationWhereUniqueInput;
    create: XOR<
      ReservationCreateWithoutStatusHistoryInput,
      ReservationUncheckedCreateWithoutStatusHistoryInput
    >;
  };

  export type UserUpsertWithoutStatusChangeInput = {
    update: XOR<
      UserUpdateWithoutStatusChangeInput,
      UserUncheckedUpdateWithoutStatusChangeInput
    >;
    create: XOR<
      UserCreateWithoutStatusChangeInput,
      UserUncheckedCreateWithoutStatusChangeInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutStatusChangeInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutStatusChangeInput,
      UserUncheckedUpdateWithoutStatusChangeInput
    >;
  };

  export type UserUpdateWithoutStatusChangeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutStatusChangeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ReservationUpsertWithoutStatusHistoryInput = {
    update: XOR<
      ReservationUpdateWithoutStatusHistoryInput,
      ReservationUncheckedUpdateWithoutStatusHistoryInput
    >;
    create: XOR<
      ReservationCreateWithoutStatusHistoryInput,
      ReservationUncheckedCreateWithoutStatusHistoryInput
    >;
    where?: ReservationWhereInput;
  };

  export type ReservationUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: ReservationWhereInput;
    data: XOR<
      ReservationUpdateWithoutStatusHistoryInput,
      ReservationUncheckedUpdateWithoutStatusHistoryInput
    >;
  };

  export type ReservationUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUpdateManyWithoutReservationNestedInput;
    user?: UserUpdateOneRequiredWithoutReservationNestedInput;
    vehicle?: VehicleUpdateOneWithoutReservationsNestedInput;
  };

  export type ReservationUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUncheckedUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput;
  };

  export type UserCreateWithoutSessionInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSessionInput,
      UserUncheckedCreateWithoutSessionInput
    >;
  };

  export type UserUpsertWithoutSessionInput = {
    update: XOR<
      UserUpdateWithoutSessionInput,
      UserUncheckedUpdateWithoutSessionInput
    >;
    create: XOR<
      UserCreateWithoutSessionInput,
      UserUncheckedCreateWithoutSessionInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSessionInput,
      UserUncheckedUpdateWithoutSessionInput
    >;
  };

  export type UserUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ImageCreateWithoutVehicleInput = {
    id?: string;
    url: string;
    uploadedAt?: Date | string;
    position: number;
  };

  export type ImageUncheckedCreateWithoutVehicleInput = {
    id?: string;
    url: string;
    uploadedAt?: Date | string;
    position: number;
  };

  export type ImageCreateOrConnectWithoutVehicleInput = {
    where: ImageWhereUniqueInput;
    create: XOR<
      ImageCreateWithoutVehicleInput,
      ImageUncheckedCreateWithoutVehicleInput
    >;
  };

  export type ImageCreateManyVehicleInputEnvelope = {
    data: ImageCreateManyVehicleInput | ImageCreateManyVehicleInput[];
    skipDuplicates?: boolean;
  };

  export type MaintenanceBlockCreateWithoutVehicleInput = {
    id?: string;
    reason: string;
    startDate: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MaintenanceBlockUncheckedCreateWithoutVehicleInput = {
    id?: string;
    reason: string;
    startDate: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MaintenanceBlockCreateOrConnectWithoutVehicleInput = {
    where: MaintenanceBlockWhereUniqueInput;
    create: XOR<
      MaintenanceBlockCreateWithoutVehicleInput,
      MaintenanceBlockUncheckedCreateWithoutVehicleInput
    >;
  };

  export type MaintenanceBlockCreateManyVehicleInputEnvelope = {
    data:
      | MaintenanceBlockCreateManyVehicleInput
      | MaintenanceBlockCreateManyVehicleInput[];
    skipDuplicates?: boolean;
  };

  export type ReservationCreateWithoutVehicleInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentCreateNestedManyWithoutReservationInput;
    payments?: PaymentCreateNestedManyWithoutReservationInput;
    user: UserCreateNestedOneWithoutReservationInput;
    statusHistory?: StatusChangeCreateNestedManyWithoutReservationInput;
  };

  export type ReservationUncheckedCreateWithoutVehicleInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentUncheckedCreateNestedManyWithoutReservationInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput;
    statusHistory?: StatusChangeUncheckedCreateNestedManyWithoutReservationInput;
  };

  export type ReservationCreateOrConnectWithoutVehicleInput = {
    where: ReservationWhereUniqueInput;
    create: XOR<
      ReservationCreateWithoutVehicleInput,
      ReservationUncheckedCreateWithoutVehicleInput
    >;
  };

  export type ReservationCreateManyVehicleInputEnvelope = {
    data:
      | ReservationCreateManyVehicleInput
      | ReservationCreateManyVehicleInput[];
    skipDuplicates?: boolean;
  };

  export type ImageUpsertWithWhereUniqueWithoutVehicleInput = {
    where: ImageWhereUniqueInput;
    update: XOR<
      ImageUpdateWithoutVehicleInput,
      ImageUncheckedUpdateWithoutVehicleInput
    >;
    create: XOR<
      ImageCreateWithoutVehicleInput,
      ImageUncheckedCreateWithoutVehicleInput
    >;
  };

  export type ImageUpdateWithWhereUniqueWithoutVehicleInput = {
    where: ImageWhereUniqueInput;
    data: XOR<
      ImageUpdateWithoutVehicleInput,
      ImageUncheckedUpdateWithoutVehicleInput
    >;
  };

  export type ImageUpdateManyWithWhereWithoutVehicleInput = {
    where: ImageScalarWhereInput;
    data: XOR<
      ImageUpdateManyMutationInput,
      ImageUncheckedUpdateManyWithoutVehicleInput
    >;
  };

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[];
    OR?: ImageScalarWhereInput[];
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[];
    id?: StringFilter<"Image"> | string;
    url?: StringFilter<"Image"> | string;
    uploadedAt?: DateTimeFilter<"Image"> | Date | string;
    position?: IntFilter<"Image"> | number;
    vehicleId?: IntNullableFilter<"Image"> | number | null;
  };

  export type MaintenanceBlockUpsertWithWhereUniqueWithoutVehicleInput = {
    where: MaintenanceBlockWhereUniqueInput;
    update: XOR<
      MaintenanceBlockUpdateWithoutVehicleInput,
      MaintenanceBlockUncheckedUpdateWithoutVehicleInput
    >;
    create: XOR<
      MaintenanceBlockCreateWithoutVehicleInput,
      MaintenanceBlockUncheckedCreateWithoutVehicleInput
    >;
  };

  export type MaintenanceBlockUpdateWithWhereUniqueWithoutVehicleInput = {
    where: MaintenanceBlockWhereUniqueInput;
    data: XOR<
      MaintenanceBlockUpdateWithoutVehicleInput,
      MaintenanceBlockUncheckedUpdateWithoutVehicleInput
    >;
  };

  export type MaintenanceBlockUpdateManyWithWhereWithoutVehicleInput = {
    where: MaintenanceBlockScalarWhereInput;
    data: XOR<
      MaintenanceBlockUpdateManyMutationInput,
      MaintenanceBlockUncheckedUpdateManyWithoutVehicleInput
    >;
  };

  export type MaintenanceBlockScalarWhereInput = {
    AND?: MaintenanceBlockScalarWhereInput | MaintenanceBlockScalarWhereInput[];
    OR?: MaintenanceBlockScalarWhereInput[];
    NOT?: MaintenanceBlockScalarWhereInput | MaintenanceBlockScalarWhereInput[];
    id?: StringFilter<"MaintenanceBlock"> | string;
    vehicleId?: IntFilter<"MaintenanceBlock"> | number;
    reason?: StringFilter<"MaintenanceBlock"> | string;
    startDate?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
    endDate?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
    createdAt?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
    updatedAt?: DateTimeFilter<"MaintenanceBlock"> | Date | string;
  };

  export type ReservationUpsertWithWhereUniqueWithoutVehicleInput = {
    where: ReservationWhereUniqueInput;
    update: XOR<
      ReservationUpdateWithoutVehicleInput,
      ReservationUncheckedUpdateWithoutVehicleInput
    >;
    create: XOR<
      ReservationCreateWithoutVehicleInput,
      ReservationUncheckedCreateWithoutVehicleInput
    >;
  };

  export type ReservationUpdateWithWhereUniqueWithoutVehicleInput = {
    where: ReservationWhereUniqueInput;
    data: XOR<
      ReservationUpdateWithoutVehicleInput,
      ReservationUncheckedUpdateWithoutVehicleInput
    >;
  };

  export type ReservationUpdateManyWithWhereWithoutVehicleInput = {
    where: ReservationScalarWhereInput;
    data: XOR<
      ReservationUpdateManyMutationInput,
      ReservationUncheckedUpdateManyWithoutVehicleInput
    >;
  };

  export type VehicleCreateWithoutMaintenanceBlocksInput = {
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ImageCreateNestedManyWithoutVehicleInput;
    reservations?: ReservationCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleUncheckedCreateWithoutMaintenanceBlocksInput = {
    id?: number;
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    images?: ImageUncheckedCreateNestedManyWithoutVehicleInput;
    reservations?: ReservationUncheckedCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleCreateOrConnectWithoutMaintenanceBlocksInput = {
    where: VehicleWhereUniqueInput;
    create: XOR<
      VehicleCreateWithoutMaintenanceBlocksInput,
      VehicleUncheckedCreateWithoutMaintenanceBlocksInput
    >;
  };

  export type VehicleUpsertWithoutMaintenanceBlocksInput = {
    update: XOR<
      VehicleUpdateWithoutMaintenanceBlocksInput,
      VehicleUncheckedUpdateWithoutMaintenanceBlocksInput
    >;
    create: XOR<
      VehicleCreateWithoutMaintenanceBlocksInput,
      VehicleUncheckedCreateWithoutMaintenanceBlocksInput
    >;
    where?: VehicleWhereInput;
  };

  export type VehicleUpdateToOneWithWhereWithoutMaintenanceBlocksInput = {
    where?: VehicleWhereInput;
    data: XOR<
      VehicleUpdateWithoutMaintenanceBlocksInput,
      VehicleUncheckedUpdateWithoutMaintenanceBlocksInput
    >;
  };

  export type VehicleUpdateWithoutMaintenanceBlocksInput = {
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ImageUpdateManyWithoutVehicleNestedInput;
    reservations?: ReservationUpdateManyWithoutVehicleNestedInput;
  };

  export type VehicleUncheckedUpdateWithoutMaintenanceBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number;
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    images?: ImageUncheckedUpdateManyWithoutVehicleNestedInput;
    reservations?: ReservationUncheckedUpdateManyWithoutVehicleNestedInput;
  };

  export type ReservationCreateWithoutPaymentsInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentCreateNestedManyWithoutReservationInput;
    user: UserCreateNestedOneWithoutReservationInput;
    vehicle?: VehicleCreateNestedOneWithoutReservationsInput;
    statusHistory?: StatusChangeCreateNestedManyWithoutReservationInput;
  };

  export type ReservationUncheckedCreateWithoutPaymentsInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    vehicleId?: number | null;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    contracts?: DocumentUncheckedCreateNestedManyWithoutReservationInput;
    statusHistory?: StatusChangeUncheckedCreateNestedManyWithoutReservationInput;
  };

  export type ReservationCreateOrConnectWithoutPaymentsInput = {
    where: ReservationWhereUniqueInput;
    create: XOR<
      ReservationCreateWithoutPaymentsInput,
      ReservationUncheckedCreateWithoutPaymentsInput
    >;
  };

  export type ReservationUpsertWithoutPaymentsInput = {
    update: XOR<
      ReservationUpdateWithoutPaymentsInput,
      ReservationUncheckedUpdateWithoutPaymentsInput
    >;
    create: XOR<
      ReservationCreateWithoutPaymentsInput,
      ReservationUncheckedCreateWithoutPaymentsInput
    >;
    where?: ReservationWhereInput;
  };

  export type ReservationUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ReservationWhereInput;
    data: XOR<
      ReservationUpdateWithoutPaymentsInput,
      ReservationUncheckedUpdateWithoutPaymentsInput
    >;
  };

  export type ReservationUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUpdateManyWithoutReservationNestedInput;
    user?: UserUpdateOneRequiredWithoutReservationNestedInput;
    vehicle?: VehicleUpdateOneWithoutReservationsNestedInput;
    statusHistory?: StatusChangeUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUncheckedUpdateManyWithoutReservationNestedInput;
    statusHistory?: StatusChangeUncheckedUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationCreateWithoutContractsInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    payments?: PaymentCreateNestedManyWithoutReservationInput;
    user: UserCreateNestedOneWithoutReservationInput;
    vehicle?: VehicleCreateNestedOneWithoutReservationsInput;
    statusHistory?: StatusChangeCreateNestedManyWithoutReservationInput;
  };

  export type ReservationUncheckedCreateWithoutContractsInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    vehicleId?: number | null;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput;
    statusHistory?: StatusChangeUncheckedCreateNestedManyWithoutReservationInput;
  };

  export type ReservationCreateOrConnectWithoutContractsInput = {
    where: ReservationWhereUniqueInput;
    create: XOR<
      ReservationCreateWithoutContractsInput,
      ReservationUncheckedCreateWithoutContractsInput
    >;
  };

  export type UserCreateWithoutDocumentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutDocumentsInput,
      UserUncheckedCreateWithoutDocumentsInput
    >;
  };

  export type ReservationUpsertWithoutContractsInput = {
    update: XOR<
      ReservationUpdateWithoutContractsInput,
      ReservationUncheckedUpdateWithoutContractsInput
    >;
    create: XOR<
      ReservationCreateWithoutContractsInput,
      ReservationUncheckedCreateWithoutContractsInput
    >;
    where?: ReservationWhereInput;
  };

  export type ReservationUpdateToOneWithWhereWithoutContractsInput = {
    where?: ReservationWhereInput;
    data: XOR<
      ReservationUpdateWithoutContractsInput,
      ReservationUncheckedUpdateWithoutContractsInput
    >;
  };

  export type ReservationUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    payments?: PaymentUpdateManyWithoutReservationNestedInput;
    user?: UserUpdateOneRequiredWithoutReservationNestedInput;
    vehicle?: VehicleUpdateOneWithoutReservationsNestedInput;
    statusHistory?: StatusChangeUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput;
    statusHistory?: StatusChangeUncheckedUpdateManyWithoutReservationNestedInput;
  };

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<
      UserUpdateWithoutDocumentsInput,
      UserUncheckedUpdateWithoutDocumentsInput
    >;
    create: XOR<
      UserCreateWithoutDocumentsInput,
      UserUncheckedCreateWithoutDocumentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutDocumentsInput,
      UserUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type VehicleCreateWithoutImagesInput = {
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maintenanceBlocks?: MaintenanceBlockCreateNestedManyWithoutVehicleInput;
    reservations?: ReservationCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleUncheckedCreateWithoutImagesInput = {
    id?: number;
    make: string;
    model: string;
    category: $Enums.VehicleCategory;
    year: number;
    color: string;
    transmission: $Enums.VehicleTransmission;
    fuel_type?: $Enums.VehicleFuelType;
    licensePlate: string;
    status?: $Enums.VehicleStatus;
    features?: VehicleCreatefeaturesInput | string[];
    dailyRate: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    maintenanceBlocks?: MaintenanceBlockUncheckedCreateNestedManyWithoutVehicleInput;
    reservations?: ReservationUncheckedCreateNestedManyWithoutVehicleInput;
  };

  export type VehicleCreateOrConnectWithoutImagesInput = {
    where: VehicleWhereUniqueInput;
    create: XOR<
      VehicleCreateWithoutImagesInput,
      VehicleUncheckedCreateWithoutImagesInput
    >;
  };

  export type VehicleUpsertWithoutImagesInput = {
    update: XOR<
      VehicleUpdateWithoutImagesInput,
      VehicleUncheckedUpdateWithoutImagesInput
    >;
    create: XOR<
      VehicleCreateWithoutImagesInput,
      VehicleUncheckedCreateWithoutImagesInput
    >;
    where?: VehicleWhereInput;
  };

  export type VehicleUpdateToOneWithWhereWithoutImagesInput = {
    where?: VehicleWhereInput;
    data: XOR<
      VehicleUpdateWithoutImagesInput,
      VehicleUncheckedUpdateWithoutImagesInput
    >;
  };

  export type VehicleUpdateWithoutImagesInput = {
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maintenanceBlocks?: MaintenanceBlockUpdateManyWithoutVehicleNestedInput;
    reservations?: ReservationUpdateManyWithoutVehicleNestedInput;
  };

  export type VehicleUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number;
    make?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    category?:
      | EnumVehicleCategoryFieldUpdateOperationsInput
      | $Enums.VehicleCategory;
    year?: IntFieldUpdateOperationsInput | number;
    color?: StringFieldUpdateOperationsInput | string;
    transmission?:
      | EnumVehicleTransmissionFieldUpdateOperationsInput
      | $Enums.VehicleTransmission;
    fuel_type?:
      | EnumVehicleFuelTypeFieldUpdateOperationsInput
      | $Enums.VehicleFuelType;
    licensePlate?: StringFieldUpdateOperationsInput | string;
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus;
    features?: VehicleUpdatefeaturesInput | string[];
    dailyRate?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    maintenanceBlocks?: MaintenanceBlockUncheckedUpdateManyWithoutVehicleNestedInput;
    reservations?: ReservationUncheckedUpdateManyWithoutVehicleNestedInput;
  };

  export type UserCreateWithoutPushSubscriptionInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutPushSubscriptionInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    Onboarding?: OnboardingUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutPushSubscriptionInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPushSubscriptionInput,
      UserUncheckedCreateWithoutPushSubscriptionInput
    >;
  };

  export type UserUpsertWithoutPushSubscriptionInput = {
    update: XOR<
      UserUpdateWithoutPushSubscriptionInput,
      UserUncheckedUpdateWithoutPushSubscriptionInput
    >;
    create: XOR<
      UserCreateWithoutPushSubscriptionInput,
      UserUncheckedCreateWithoutPushSubscriptionInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPushSubscriptionInput,
      UserUncheckedUpdateWithoutPushSubscriptionInput
    >;
  };

  export type UserUpdateWithoutPushSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutPushSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    Onboarding?: OnboardingUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutOnboardingInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountCreateNestedManyWithoutUserInput;
    documents?: DocumentCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput;
    Reservation?: ReservationCreateNestedManyWithoutUserInput;
    Session?: SessionCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutOnboardingInput = {
    id?: string;
    name?: string | null;
    email: string;
    emailVerified?: Date | string | null;
    image?: string | null;
    phone?: string | null;
    isAdmin?: boolean;
    isVerified?: boolean;
    Account?: AccountUncheckedCreateNestedManyWithoutUserInput;
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput;
    notificationsPreferences?: PreferencesUncheckedCreateNestedOneWithoutUserInput;
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUserInput;
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput;
    StatusChange?: StatusChangeUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutOnboardingInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutOnboardingInput,
      UserUncheckedCreateWithoutOnboardingInput
    >;
  };

  export type UserUpsertWithoutOnboardingInput = {
    update: XOR<
      UserUpdateWithoutOnboardingInput,
      UserUncheckedUpdateWithoutOnboardingInput
    >;
    create: XOR<
      UserCreateWithoutOnboardingInput,
      UserUncheckedCreateWithoutOnboardingInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOnboardingInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutOnboardingInput,
      UserUncheckedUpdateWithoutOnboardingInput
    >;
  };

  export type UserUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUpdateManyWithoutUserNestedInput;
    documents?: DocumentUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUpdateManyWithoutUserNestedInput;
    Session?: SessionUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    isAdmin?: BoolFieldUpdateOperationsInput | boolean;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    Account?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput;
    notificationsPreferences?: PreferencesUncheckedUpdateOneWithoutUserNestedInput;
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    Reservation?: ReservationUncheckedUpdateManyWithoutUserNestedInput;
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    StatusChange?: StatusChangeUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AccountCreateManyUserInput = {
    id?: number;
    type: string;
    provider: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    providerAccountId: string;
  };

  export type DocumentCreateManyUserInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    reservationId?: string | null;
  };

  export type OnboardingCreateManyUserInput = {
    id?: string;
    tour?: string;
    completed?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionCreateManyUserInput = {
    id?: string;
    endpoint: string;
    keys: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReservationCreateManyUserInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    vehicleId?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SessionCreateManyUserInput = {
    id: string;
    expires: Date | string;
    sessionToken: string;
  };

  export type StatusChangeCreateManyUserInput = {
    id?: string;
    reservationId: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changeAt?: Date | string;
  };

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Reservation?: ReservationUpdateOneWithoutContractsNestedInput;
  };

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OnboardingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tour?: StringFieldUpdateOperationsInput | string;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OnboardingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tour?: StringFieldUpdateOperationsInput | string;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OnboardingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    tour?: StringFieldUpdateOperationsInput | string;
    completed?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    keys?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    keys?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    keys?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReservationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUpdateManyWithoutReservationNestedInput;
    vehicle?: VehicleUpdateOneWithoutReservationsNestedInput;
    statusHistory?: StatusChangeUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUncheckedUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput;
    statusHistory?: StatusChangeUncheckedUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
  };

  export type StatusChangeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reservation?: ReservationUpdateOneRequiredWithoutStatusHistoryNestedInput;
  };

  export type StatusChangeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reservationId?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StatusChangeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reservationId?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateManyReservationInput = {
    id?: string;
    name: string;
    type: string;
    url: string;
    uploadedAt?: Date | string;
    userId: string;
  };

  export type PaymentCreateManyReservationInput = {
    id?: string;
    stripeSession: string;
    amount: Decimal | DecimalJsLike | number | string;
    status?: $Enums.PaymentStatus;
    intent_id?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type StatusChangeCreateManyReservationInput = {
    id?: string;
    fromStatus?: $Enums.ReservationStatus | null;
    toStatus: $Enums.ReservationStatus;
    reason?: string | null;
    changedBy?: string | null;
    changeAt?: Date | string;
  };

  export type DocumentUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type DocumentUncheckedUpdateManyWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type PaymentUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    stripeSession?: StringFieldUpdateOperationsInput | string;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    intent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    stripeSession?: StringFieldUpdateOperationsInput | string;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    intent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateManyWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    stripeSession?: StringFieldUpdateOperationsInput | string;
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    intent_id?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StatusChangeUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutStatusChangeNestedInput;
  };

  export type StatusChangeUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StatusChangeUncheckedUpdateManyWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fromStatus?:
      | NullableEnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus
      | null;
    toStatus?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    reason?: NullableStringFieldUpdateOperationsInput | string | null;
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    changeAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ImageCreateManyVehicleInput = {
    id?: string;
    url: string;
    uploadedAt?: Date | string;
    position: number;
  };

  export type MaintenanceBlockCreateManyVehicleInput = {
    id?: string;
    reason: string;
    startDate: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReservationCreateManyVehicleInput = {
    id?: string;
    pickupDate: Date | string;
    dropoffDate: Date | string;
    pickupLocation: string;
    dropoffLocation: string;
    pickupHour: string;
    dropoffHour: string;
    dailyRate: Decimal | DecimalJsLike | number | string;
    totalDays: Decimal | DecimalJsLike | number | string;
    subtotal: Decimal | DecimalJsLike | number | string;
    tax: Decimal | DecimalJsLike | number | string;
    totalAmount: Decimal | DecimalJsLike | number | string;
    amountPaid: Decimal | DecimalJsLike | number | string;
    status?: $Enums.ReservationStatus;
    paymentStatus?: $Enums.PaymentStatus;
    notes?: string | null;
    specialRequests?: string | null;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ImageUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type ImageUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type ImageUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    position?: IntFieldUpdateOperationsInput | number;
  };

  export type MaintenanceBlockUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MaintenanceBlockUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MaintenanceBlockUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReservationUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUpdateManyWithoutReservationNestedInput;
    user?: UserUpdateOneRequiredWithoutReservationNestedInput;
    statusHistory?: StatusChangeUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    contracts?: DocumentUncheckedUpdateManyWithoutReservationNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput;
    statusHistory?: StatusChangeUncheckedUpdateManyWithoutReservationNestedInput;
  };

  export type ReservationUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    dropoffDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    pickupLocation?: StringFieldUpdateOperationsInput | string;
    dropoffLocation?: StringFieldUpdateOperationsInput | string;
    pickupHour?: StringFieldUpdateOperationsInput | string;
    dropoffHour?: StringFieldUpdateOperationsInput | string;
    dailyRate?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalDays?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    tax?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    totalAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    amountPaid?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string;
    status?:
      | EnumReservationStatusFieldUpdateOperationsInput
      | $Enums.ReservationStatus;
    paymentStatus?:
      | EnumPaymentStatusFieldUpdateOperationsInput
      | $Enums.PaymentStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
